{"version":3,"sources":["skylark-jade.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-jade.js","sourcesContent":["define([], function () {\n    'use strict';\n    var exports = {};\n    var module = { exports: {} };\n    !function (e) {\n        if ('object' == typeof exports)\n            module.exports = e();\n        else if ('function' == typeof define && define.amd)\n            define(e);\n        else {\n            var f;\n            'undefined' != typeof window ? f = window : 'undefined' != typeof global ? f = global : 'undefined' != typeof self && (f = self), f.jade = e();\n        }\n    }(function () {\n        var define, module, exports;\n        return function e(t, n, r) {\n            function s(o, u) {\n                if (!n[o]) {\n                    if (!t[o]) {\n                        var a = typeof require == 'function' && require;\n                        if (!u && a)\n                            return a(o, !0);\n                        if (i)\n                            return i(o, !0);\n                        throw new Error(\"Cannot find module '\" + o + \"'\");\n                    }\n                    var f = n[o] = { exports: {} };\n                    t[o][0].call(f.exports, function (e) {\n                        var n = t[o][1][e];\n                        return s(n ? n : e);\n                    }, f, f.exports, e, t, n, r);\n                }\n                return n[o].exports;\n            }\n            var i = typeof require == 'function' && require;\n            for (var o = 0; o < r.length; o++)\n                s(r[o]);\n            return s;\n        }({\n            1: [\n                function (_dereq_, module, exports) {\n                    var nodes = _dereq_('./nodes');\n                    var filters = _dereq_('./filters');\n                    var doctypes = _dereq_('./doctypes');\n                    var runtime = _dereq_('./runtime');\n                    var utils = _dereq_('./utils');\n                    var selfClosing = _dereq_('./self-closing');\n                    var parseJSExpression = _dereq_('character-parser').parseMax;\n                    var constantinople = _dereq_('constantinople');\n                    function isConstant(src) {\n                        return constantinople(src, {\n                            jade: runtime,\n                            'jade_interp': undefined\n                        });\n                    }\n                    function toConstant(src) {\n                        return constantinople.toConstant(src, {\n                            jade: runtime,\n                            'jade_interp': undefined\n                        });\n                    }\n                    function errorAtNode(node, error) {\n                        error.line = node.line;\n                        error.filename = node.filename;\n                        return error;\n                    }\n                    var Compiler = module.exports = function Compiler(node, options) {\n                        this.options = options = options || {};\n                        this.node = node;\n                        this.hasCompiledDoctype = false;\n                        this.hasCompiledTag = false;\n                        this.pp = options.pretty || false;\n                        this.debug = false !== options.compileDebug;\n                        this.indents = 0;\n                        this.parentIndents = 0;\n                        this.terse = false;\n                        this.mixins = {};\n                        this.dynamicMixins = false;\n                        if (options.doctype)\n                            this.setDoctype(options.doctype);\n                    };\n                    Compiler.prototype = {\n                        compile: function () {\n                            this.buf = [];\n                            if (this.pp)\n                                this.buf.push('var jade_indent = [];');\n                            this.lastBufferedIdx = -1;\n                            this.visit(this.node);\n                            if (!this.dynamicMixins) {\n                                var mixinNames = Object.keys(this.mixins);\n                                for (var i = 0; i < mixinNames.length; i++) {\n                                    var mixin = this.mixins[mixinNames[i]];\n                                    if (!mixin.used) {\n                                        for (var x = 0; x < mixin.instances.length; x++) {\n                                            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++) {\n                                                this.buf[y] = '';\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            return this.buf.join('\\n');\n                        },\n                        setDoctype: function (name) {\n                            this.doctype = doctypes[name.toLowerCase()] || '<!DOCTYPE ' + name + '>';\n                            this.terse = this.doctype.toLowerCase() == '<!doctype html>';\n                            this.xml = 0 == this.doctype.indexOf('<?xml');\n                        },\n                        buffer: function (str, interpolate) {\n                            var self = this;\n                            if (interpolate) {\n                                var match = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(str);\n                                if (match) {\n                                    this.buffer(str.substr(0, match.index), false);\n                                    if (match[1]) {\n                                        this.buffer(match[2] + '{', false);\n                                        this.buffer(match[3], true);\n                                        return;\n                                    } else {\n                                        var rest = match[3];\n                                        var range = parseJSExpression(rest);\n                                        var code = ('!' == match[2] ? '' : 'jade.escape') + '((jade_interp = ' + range.src + \") == null ? '' : jade_interp)\";\n                                        this.bufferExpression(code);\n                                        this.buffer(rest.substr(range.end + 1), true);\n                                        return;\n                                    }\n                                }\n                            }\n                            str = JSON.stringify(str);\n                            str = str.substr(1, str.length - 2);\n                            if (this.lastBufferedIdx == this.buf.length) {\n                                if (this.lastBufferedType === 'code')\n                                    this.lastBuffered += ' + \"';\n                                this.lastBufferedType = 'text';\n                                this.lastBuffered += str;\n                                this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '\");';\n                            } else {\n                                this.buf.push('buf.push(\"' + str + '\");');\n                                this.lastBufferedType = 'text';\n                                this.bufferStartChar = '\"';\n                                this.lastBuffered = str;\n                                this.lastBufferedIdx = this.buf.length;\n                            }\n                        },\n                        bufferExpression: function (src) {\n                            if (isConstant(src)) {\n                                return this.buffer(toConstant(src) + '', false);\n                            }\n                            if (this.lastBufferedIdx == this.buf.length) {\n                                if (this.lastBufferedType === 'text')\n                                    this.lastBuffered += '\"';\n                                this.lastBufferedType = 'code';\n                                this.lastBuffered += ' + (' + src + ')';\n                                this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + ');';\n                            } else {\n                                this.buf.push('buf.push(' + src + ');');\n                                this.lastBufferedType = 'code';\n                                this.bufferStartChar = '';\n                                this.lastBuffered = '(' + src + ')';\n                                this.lastBufferedIdx = this.buf.length;\n                            }\n                        },\n                        prettyIndent: function (offset, newline) {\n                            offset = offset || 0;\n                            newline = newline ? '\\n' : '';\n                            this.buffer(newline + Array(this.indents + offset).join('  '));\n                            if (this.parentIndents)\n                                this.buf.push('buf.push.apply(buf, jade_indent);');\n                        },\n                        visit: function (node) {\n                            var debug = this.debug;\n                            if (debug) {\n                                this.buf.push('jade_debug.unshift({ lineno: ' + node.line + ', filename: ' + (node.filename ? JSON.stringify(node.filename) : 'jade_debug[0].filename') + ' });');\n                            }\n                            if (false === node.debug && this.debug) {\n                                this.buf.pop();\n                                this.buf.pop();\n                            }\n                            this.visitNode(node);\n                            if (debug)\n                                this.buf.push('jade_debug.shift();');\n                        },\n                        visitNode: function (node) {\n                            return this['visit' + node.type](node);\n                        },\n                        visitCase: function (node) {\n                            var _ = this.withinCase;\n                            this.withinCase = true;\n                            this.buf.push('switch (' + node.expr + '){');\n                            this.visit(node.block);\n                            this.buf.push('}');\n                            this.withinCase = _;\n                        },\n                        visitWhen: function (node) {\n                            if ('default' == node.expr) {\n                                this.buf.push('default:');\n                            } else {\n                                this.buf.push('case ' + node.expr + ':');\n                            }\n                            if (node.block) {\n                                this.visit(node.block);\n                                this.buf.push('  break;');\n                            }\n                        },\n                        visitLiteral: function (node) {\n                            this.buffer(node.str);\n                        },\n                        visitBlock: function (block) {\n                            var len = block.nodes.length, escape = this.escape, pp = this.pp;\n                            if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText)\n                                this.prettyIndent(1, true);\n                            for (var i = 0; i < len; ++i) {\n                                if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i - 1].isText)\n                                    this.prettyIndent(1, false);\n                                this.visit(block.nodes[i]);\n                                if (block.nodes[i + 1] && block.nodes[i].isText && block.nodes[i + 1].isText)\n                                    this.buffer('\\n');\n                            }\n                        },\n                        visitMixinBlock: function (block) {\n                            if (this.pp)\n                                this.buf.push(\"jade_indent.push('\" + Array(this.indents + 1).join('  ') + \"');\");\n                            this.buf.push('block && block();');\n                            if (this.pp)\n                                this.buf.push('jade_indent.pop();');\n                        },\n                        visitDoctype: function (doctype) {\n                            if (doctype && (doctype.val || !this.doctype)) {\n                                this.setDoctype(doctype.val || 'default');\n                            }\n                            if (this.doctype)\n                                this.buffer(this.doctype);\n                            this.hasCompiledDoctype = true;\n                        },\n                        visitMixin: function (mixin) {\n                            var name = 'jade_mixins[';\n                            var args = mixin.args || '';\n                            var block = mixin.block;\n                            var attrs = mixin.attrs;\n                            var attrsBlocks = mixin.attributeBlocks;\n                            var pp = this.pp;\n                            var dynamic = mixin.name[0] === '#';\n                            var key = mixin.name;\n                            if (dynamic)\n                                this.dynamicMixins = true;\n                            name += (dynamic ? mixin.name.substr(2, mixin.name.length - 3) : '\"' + mixin.name + '\"') + ']';\n                            this.mixins[key] = this.mixins[key] || {\n                                used: false,\n                                instances: []\n                            };\n                            if (mixin.call) {\n                                this.mixins[key].used = true;\n                                if (pp)\n                                    this.buf.push(\"jade_indent.push('\" + Array(this.indents + 1).join('  ') + \"');\");\n                                if (block || attrs.length || attrsBlocks.length) {\n                                    this.buf.push(name + '.call({');\n                                    if (block) {\n                                        this.buf.push('block: function(){');\n                                        this.parentIndents++;\n                                        var _indents = this.indents;\n                                        this.indents = 0;\n                                        this.visit(mixin.block);\n                                        this.indents = _indents;\n                                        this.parentIndents--;\n                                        if (attrs.length || attrsBlocks.length) {\n                                            this.buf.push('},');\n                                        } else {\n                                            this.buf.push('}');\n                                        }\n                                    }\n                                    if (attrsBlocks.length) {\n                                        if (attrs.length) {\n                                            var val = this.attrs(attrs);\n                                            attrsBlocks.unshift(val);\n                                        }\n                                        this.buf.push('attributes: jade.merge([' + attrsBlocks.join(',') + '])');\n                                    } else if (attrs.length) {\n                                        var val = this.attrs(attrs);\n                                        this.buf.push('attributes: ' + val);\n                                    }\n                                    if (args) {\n                                        this.buf.push('}, ' + args + ');');\n                                    } else {\n                                        this.buf.push('});');\n                                    }\n                                } else {\n                                    this.buf.push(name + '(' + args + ');');\n                                }\n                                if (pp)\n                                    this.buf.push('jade_indent.pop();');\n                            } else {\n                                var mixin_start = this.buf.length;\n                                this.buf.push(name + ' = function(' + args + '){');\n                                this.buf.push('var block = (this && this.block), attributes = (this && this.attributes) || {};');\n                                this.parentIndents++;\n                                this.visit(block);\n                                this.parentIndents--;\n                                this.buf.push('};');\n                                var mixin_end = this.buf.length;\n                                this.mixins[key].instances.push({\n                                    start: mixin_start,\n                                    end: mixin_end\n                                });\n                            }\n                        },\n                        visitTag: function (tag) {\n                            this.indents++;\n                            var name = tag.name, pp = this.pp, self = this;\n                            function bufferName() {\n                                if (tag.buffer)\n                                    self.bufferExpression(name);\n                                else\n                                    self.buffer(name);\n                            }\n                            if ('pre' == tag.name)\n                                this.escape = true;\n                            if (!this.hasCompiledTag) {\n                                if (!this.hasCompiledDoctype && 'html' == name) {\n                                    this.visitDoctype();\n                                }\n                                this.hasCompiledTag = true;\n                            }\n                            if (pp && !tag.isInline())\n                                this.prettyIndent(0, true);\n                            if (tag.selfClosing || !this.xml && selfClosing.indexOf(tag.name) !== -1) {\n                                this.buffer('<');\n                                bufferName();\n                                this.visitAttributes(tag.attrs, tag.attributeBlocks);\n                                this.terse ? this.buffer('>') : this.buffer('/>');\n                                if (tag.block && !(tag.block.type === 'Block' && tag.block.nodes.length === 0) && tag.block.nodes.some(function (tag) {\n                                        return tag.type !== 'Text' || !/^\\s*$/.test(tag.val);\n                                    })) {\n                                    throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));\n                                }\n                            } else {\n                                this.buffer('<');\n                                bufferName();\n                                this.visitAttributes(tag.attrs, tag.attributeBlocks);\n                                this.buffer('>');\n                                if (tag.code)\n                                    this.visitCode(tag.code);\n                                this.visit(tag.block);\n                                if (pp && !tag.isInline() && 'pre' != tag.name && !tag.canInline())\n                                    this.prettyIndent(0, true);\n                                this.buffer('</');\n                                bufferName();\n                                this.buffer('>');\n                            }\n                            if ('pre' == tag.name)\n                                this.escape = false;\n                            this.indents--;\n                        },\n                        visitFilter: function (filter) {\n                            var text = filter.block.nodes.map(function (node) {\n                                return node.val;\n                            }).join('\\n');\n                            filter.attrs.filename = this.options.filename;\n                            try {\n                                this.buffer(filters(filter.name, text, filter.attrs), true);\n                            } catch (err) {\n                                throw errorAtNode(filter, err);\n                            }\n                        },\n                        visitText: function (text) {\n                            this.buffer(text.val, true);\n                        },\n                        visitComment: function (comment) {\n                            if (!comment.buffer)\n                                return;\n                            if (this.pp)\n                                this.prettyIndent(1, true);\n                            this.buffer('<!--' + comment.val + '-->');\n                        },\n                        visitBlockComment: function (comment) {\n                            if (!comment.buffer)\n                                return;\n                            if (this.pp)\n                                this.prettyIndent(1, true);\n                            this.buffer('<!--' + comment.val);\n                            this.visit(comment.block);\n                            if (this.pp)\n                                this.prettyIndent(1, true);\n                            this.buffer('-->');\n                        },\n                        visitCode: function (code) {\n                            if (code.buffer) {\n                                var val = code.val.trimLeft();\n                                val = 'null == (jade_interp = ' + val + ') ? \"\" : jade_interp';\n                                if (code.escape)\n                                    val = 'jade.escape(' + val + ')';\n                                this.bufferExpression(val);\n                            } else {\n                                this.buf.push(code.val);\n                            }\n                            if (code.block) {\n                                if (!code.buffer)\n                                    this.buf.push('{');\n                                this.visit(code.block);\n                                if (!code.buffer)\n                                    this.buf.push('}');\n                            }\n                        },\n                        visitEach: function (each) {\n                            this.buf.push('' + '// iterate ' + each.obj + '\\n' + ';(function(){\\n' + '  var $$obj = ' + each.obj + ';\\n' + \"  if ('number' == typeof $$obj.length) {\\n\");\n                            if (each.alternative) {\n                                this.buf.push('  if ($$obj.length) {');\n                            }\n                            this.buf.push('' + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++) {\\n' + '      var ' + each.val + ' = $$obj[' + each.key + '];\\n');\n                            this.visit(each.block);\n                            this.buf.push('    }\\n');\n                            if (each.alternative) {\n                                this.buf.push('  } else {');\n                                this.visit(each.alternative);\n                                this.buf.push('  }');\n                            }\n                            this.buf.push('' + '  } else {\\n' + '    var $$l = 0;\\n' + '    for (var ' + each.key + ' in $$obj) {\\n' + '      $$l++;' + '      var ' + each.val + ' = $$obj[' + each.key + '];\\n');\n                            this.visit(each.block);\n                            this.buf.push('    }\\n');\n                            if (each.alternative) {\n                                this.buf.push('    if ($$l === 0) {');\n                                this.visit(each.alternative);\n                                this.buf.push('    }');\n                            }\n                            this.buf.push('  }\\n}).call(this);\\n');\n                        },\n                        visitAttributes: function (attrs, attributeBlocks) {\n                            if (attributeBlocks.length) {\n                                if (attrs.length) {\n                                    var val = this.attrs(attrs);\n                                    attributeBlocks.unshift(val);\n                                }\n                                this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(',') + ']), ' + JSON.stringify(this.terse) + ')');\n                            } else if (attrs.length) {\n                                this.attrs(attrs, true);\n                            }\n                        },\n                        attrs: function (attrs, buffer) {\n                            var buf = [];\n                            var classes = [];\n                            var classEscaping = [];\n                            attrs.forEach(function (attr) {\n                                var key = attr.name;\n                                var escaped = attr.escaped;\n                                if (key === 'class') {\n                                    classes.push(attr.val);\n                                    classEscaping.push(attr.escaped);\n                                } else if (isConstant(attr.val)) {\n                                    if (buffer) {\n                                        this.buffer(runtime.attr(key, toConstant(attr.val), escaped, this.terse));\n                                    } else {\n                                        var val = toConstant(attr.val);\n                                        if (escaped && !(key.indexOf('data') === 0 && typeof val !== 'string')) {\n                                            val = runtime.escape(val);\n                                        }\n                                        buf.push(JSON.stringify(key) + ': ' + JSON.stringify(val));\n                                    }\n                                } else {\n                                    if (buffer) {\n                                        this.bufferExpression('jade.attr(\"' + key + '\", ' + attr.val + ', ' + JSON.stringify(escaped) + ', ' + JSON.stringify(this.terse) + ')');\n                                    } else {\n                                        var val = attr.val;\n                                        if (escaped && !(key.indexOf('data') === 0)) {\n                                            val = 'jade.escape(' + val + ')';\n                                        } else if (escaped) {\n                                            val = '(typeof (jade_interp = ' + val + ') == \"string\" ? jade.escape(jade_interp) : jade_interp)';\n                                        }\n                                        buf.push(JSON.stringify(key) + ': ' + val);\n                                    }\n                                }\n                            }.bind(this));\n                            if (buffer) {\n                                if (classes.every(isConstant)) {\n                                    this.buffer(runtime.cls(classes.map(toConstant), classEscaping));\n                                } else {\n                                    this.bufferExpression('jade.cls([' + classes.join(',') + '], ' + JSON.stringify(classEscaping) + ')');\n                                }\n                            } else if (classes.length) {\n                                if (classes.every(isConstant)) {\n                                    classes = JSON.stringify(runtime.joinClasses(classes.map(toConstant).map(runtime.joinClasses).map(function (cls, i) {\n                                        return classEscaping[i] ? runtime.escape(cls) : cls;\n                                    })));\n                                } else {\n                                    classes = '(jade_interp = ' + JSON.stringify(classEscaping) + ',' + ' jade.joinClasses([' + classes.join(',') + '].map(jade.joinClasses).map(function (cls, i) {' + '   return jade_interp[i] ? jade.escape(cls) : cls' + ' }))' + ')';\n                                }\n                                if (classes.length)\n                                    buf.push('\"class\": ' + classes);\n                            }\n                            return '{' + buf.join(',') + '}';\n                        }\n                    };\n                },\n                {\n                    './doctypes': 2,\n                    './filters': 3,\n                    './nodes': 16,\n                    './runtime': 24,\n                    './self-closing': 25,\n                    './utils': 26,\n                    'character-parser': 33,\n                    'constantinople': 34\n                }\n            ],\n            2: [\n                function (_dereq_, module, exports) {\n                    module.exports = {\n                        'default': '<!DOCTYPE html>',\n                        'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>',\n                        'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n                        'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',\n                        'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',\n                        '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">',\n                        'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',\n                        'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n                    };\n                },\n                {}\n            ],\n            3: [\n                function (_dereq_, module, exports) {\n                    module.exports = filter;\n                    function filter(name, str, options) {\n                        if (typeof filter[name] === 'function') {\n                            var res = filter[name](str, options);\n                        } else {\n                            throw new Error('unknown filter \":' + name + '\"');\n                        }\n                        return res;\n                    }\n                },\n                {}\n            ],\n            4: [\n                function (_dereq_, module, exports) {\n                    module.exports = [\n                        'a',\n                        'abbr',\n                        'acronym',\n                        'b',\n                        'br',\n                        'code',\n                        'em',\n                        'font',\n                        'i',\n                        'img',\n                        'ins',\n                        'kbd',\n                        'map',\n                        'samp',\n                        'small',\n                        'span',\n                        'strong',\n                        'sub',\n                        'sup'\n                    ];\n                },\n                {}\n            ],\n            5: [\n                function (_dereq_, module, exports) {\n                    var Parser = _dereq_('./parser'), Lexer = _dereq_('./lexer'), Compiler = _dereq_('./compiler'), runtime = _dereq_('./runtime'), addWith = _dereq_('with'), fs = _dereq_('fs');\n                    exports.selfClosing = _dereq_('./self-closing');\n                    exports.doctypes = _dereq_('./doctypes');\n                    exports.filters = _dereq_('./filters');\n                    exports.utils = _dereq_('./utils');\n                    exports.Compiler = Compiler;\n                    exports.Parser = Parser;\n                    exports.Lexer = Lexer;\n                    exports.nodes = _dereq_('./nodes');\n                    exports.runtime = runtime;\n                    exports.cache = {};\n                    function parse(str, options) {\n                        var parser = new (options.parser || Parser)(str, options.filename, options);\n                        var tokens;\n                        try {\n                            tokens = parser.parse();\n                        } catch (err) {\n                            parser = parser.context();\n                            runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);\n                        }\n                        var compiler = new (options.compiler || Compiler)(tokens, options);\n                        var js;\n                        try {\n                            js = compiler.compile();\n                        } catch (err) {\n                            if (err.line && (err.filename || !options.filename)) {\n                                runtime.rethrow(err, err.filename, err.line, parser.input);\n                            }\n                        }\n                        if (options.debug) {\n                            console.error('\\nCompiled Function:\\n\\n\\x1B[90m%s\\x1B[0m', js.replace(/^/gm, '  '));\n                        }\n                        var globals = [];\n                        globals.push('jade');\n                        globals.push('jade_mixins');\n                        globals.push('jade_interp');\n                        globals.push('jade_debug');\n                        globals.push('buf');\n                        return '' + 'var buf = [];\\n' + 'var jade_mixins = {};\\n' + 'var jade_interp;\\n' + (options.self ? 'var self = locals || {};\\n' + js : addWith('locals || {}', '\\n' + js, globals)) + ';' + 'return buf.join(\"\");';\n                    }\n                    exports.compile = function (str, options) {\n                        var options = options || {}, filename = options.filename ? JSON.stringify(options.filename) : 'undefined', fn;\n                        str = String(str);\n                        if (options.compileDebug !== false) {\n                            fn = [\n                                'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];',\n                                'try {',\n                                parse(str, options),\n                                '} catch (err) {',\n                                '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + JSON.stringify(str) : '') + ');',\n                                '}'\n                            ].join('\\n');\n                        } else {\n                            fn = parse(str, options);\n                        }\n                        fn = new Function('locals, jade', fn);\n                        var res = function (locals) {\n                            return fn(locals, Object.create(runtime));\n                        };\n                        if (options.client) {\n                            res.toString = function () {\n                                var err = new Error('The `client` option is deprecated, use `jade.compileClient`');\n                                console.error(err.stack || err.message);\n                                return exports.compileClient(str, options);\n                            };\n                        }\n                        return res;\n                    };\n                    exports.compileClient = function (str, options) {\n                        var options = options || {}, filename = options.filename ? JSON.stringify(options.filename) : 'undefined', fn;\n                        str = String(str);\n                        if (options.compileDebug) {\n                            options.compileDebug = true;\n                            fn = [\n                                'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];',\n                                'try {',\n                                parse(str, options),\n                                '} catch (err) {',\n                                '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + JSON.stringify(str) + ');',\n                                '}'\n                            ].join('\\n');\n                        } else {\n                            options.compileDebug = false;\n                            fn = parse(str, options);\n                        }\n                        return 'function template(locals) {\\n' + fn + '\\n}';\n                    };\n                    exports.render = function (str, options, fn) {\n                        if ('function' == typeof options) {\n                            fn = options, options = undefined;\n                        }\n                        if (typeof fn === 'function') {\n                            var res;\n                            try {\n                                res = exports.render(str, options);\n                            } catch (ex) {\n                                return fn(ex);\n                            }\n                            return fn(null, res);\n                        }\n                        options = options || {};\n                        if (options.cache && !options.filename) {\n                            throw new Error('the \"filename\" option is required for caching');\n                        }\n                        var path = options.filename;\n                        var tmpl = options.cache ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options)) : exports.compile(str, options);\n                        return tmpl(options);\n                    };\n                    exports.renderFile = function (path, options, fn) {\n                        if ('function' == typeof options) {\n                            fn = options, options = undefined;\n                        }\n                        if (typeof fn === 'function') {\n                            var res;\n                            try {\n                                res = exports.renderFile(path, options);\n                            } catch (ex) {\n                                return fn(ex);\n                            }\n                            return fn(null, res);\n                        }\n                        options = options || {};\n                        var key = path + ':string';\n                        options.filename = path;\n                        var str = options.cache ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8')) : fs.readFileSync(path, 'utf8');\n                        return exports.render(str, options);\n                    };\n                    exports.compileFileClient = function (path, options) {\n                        options = options || {};\n                        var key = path + ':string';\n                        options.filename = path;\n                        var str = options.cache ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8')) : fs.readFileSync(path, 'utf8');\n                        return exports.compileClient(str, options);\n                    };\n                    exports.__express = exports.renderFile;\n                },\n                {\n                    './compiler': 1,\n                    './doctypes': 2,\n                    './filters': 3,\n                    './lexer': 6,\n                    './nodes': 16,\n                    './parser': 23,\n                    './runtime': 24,\n                    './self-closing': 25,\n                    './utils': 26,\n                    'fs': 27,\n                    'with': 46\n                }\n            ],\n            6: [\n                function (_dereq_, module, exports) {\n                    var utils = _dereq_('./utils');\n                    var characterParser = _dereq_('character-parser');\n                    var Lexer = module.exports = function Lexer(str, filename) {\n                        this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n                        this.filename = filename;\n                        this.deferredTokens = [];\n                        this.lastIndents = 0;\n                        this.lineno = 1;\n                        this.stash = [];\n                        this.indentStack = [];\n                        this.indentRe = null;\n                        this.pipeless = false;\n                    };\n                    function assertExpression(exp) {\n                        Function('', 'return (' + exp + ')');\n                    }\n                    function assertNestingCorrect(exp) {\n                        var res = characterParser(exp);\n                        if (res.isNesting()) {\n                            throw new Error('Nesting must match on expression `' + exp + '`');\n                        }\n                    }\n                    Lexer.prototype = {\n                        tok: function (type, val) {\n                            return {\n                                type: type,\n                                line: this.lineno,\n                                val: val\n                            };\n                        },\n                        consume: function (len) {\n                            this.input = this.input.substr(len);\n                        },\n                        scan: function (regexp, type) {\n                            var captures;\n                            if (captures = regexp.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                return this.tok(type, captures[1]);\n                            }\n                        },\n                        defer: function (tok) {\n                            this.deferredTokens.push(tok);\n                        },\n                        lookahead: function (n) {\n                            var fetch = n - this.stash.length;\n                            while (fetch-- > 0)\n                                this.stash.push(this.next());\n                            return this.stash[--n];\n                        },\n                        bracketExpression: function (skip) {\n                            skip = skip || 0;\n                            var start = this.input[skip];\n                            if (start != '(' && start != '{' && start != '[')\n                                throw new Error('unrecognized start character');\n                            var end = {\n                                '(': ')',\n                                '{': '}',\n                                '[': ']'\n                            }[start];\n                            var range = characterParser.parseMax(this.input, { start: skip + 1 });\n                            if (this.input[range.end] !== end)\n                                throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);\n                            return range;\n                        },\n                        stashed: function () {\n                            return this.stash.length && this.stash.shift();\n                        },\n                        deferred: function () {\n                            return this.deferredTokens.length && this.deferredTokens.shift();\n                        },\n                        eos: function () {\n                            if (this.input.length)\n                                return;\n                            if (this.indentStack.length) {\n                                this.indentStack.shift();\n                                return this.tok('outdent');\n                            } else {\n                                return this.tok('eos');\n                            }\n                        },\n                        blank: function () {\n                            var captures;\n                            if (captures = /^\\n *\\n/.exec(this.input)) {\n                                this.consume(captures[0].length - 1);\n                                ++this.lineno;\n                                if (this.pipeless)\n                                    return this.tok('text', '');\n                                return this.next();\n                            }\n                        },\n                        comment: function () {\n                            var captures;\n                            if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var tok = this.tok('comment', captures[2]);\n                                tok.buffer = '-' != captures[1];\n                                return tok;\n                            }\n                        },\n                        interpolation: function () {\n                            if (/^#\\{/.test(this.input)) {\n                                var match;\n                                try {\n                                    match = this.bracketExpression(1);\n                                } catch (ex) {\n                                    return;\n                                }\n                                this.consume(match.end + 1);\n                                return this.tok('interpolation', match.src);\n                            }\n                        },\n                        tag: function () {\n                            var captures;\n                            if (captures = /^(\\w[-:\\w]*)(\\/?)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var tok, name = captures[1];\n                                if (':' == name[name.length - 1]) {\n                                    name = name.slice(0, -1);\n                                    tok = this.tok('tag', name);\n                                    this.defer(this.tok(':'));\n                                    while (' ' == this.input[0])\n                                        this.input = this.input.substr(1);\n                                } else {\n                                    tok = this.tok('tag', name);\n                                }\n                                tok.selfClosing = !!captures[2];\n                                return tok;\n                            }\n                        },\n                        filter: function () {\n                            return this.scan(/^:([\\w\\-]+)/, 'filter');\n                        },\n                        doctype: function () {\n                            if (this.scan(/^!!! *([^\\n]+)?/, 'doctype')) {\n                                throw new Error('`!!!` is deprecated, you must now use `doctype`');\n                            }\n                            var node = this.scan(/^(?:doctype) *([^\\n]+)?/, 'doctype');\n                            if (node && node.val && node.val.trim() === '5') {\n                                throw new Error('`doctype 5` is deprecated, you must now use `doctype html`');\n                            }\n                            return node;\n                        },\n                        id: function () {\n                            return this.scan(/^#([\\w-]+)/, 'id');\n                        },\n                        className: function () {\n                            return this.scan(/^\\.([\\w-]+)/, 'class');\n                        },\n                        text: function () {\n                            return this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') || this.scan(/^(<[^\\n]*)/, 'text');\n                        },\n                        textFail: function () {\n                            var tok;\n                            if (tok = this.scan(/^([^\\.\\n][^\\n]+)/, 'text')) {\n                                console.warn('Warning: missing space before text for line ' + this.lineno + ' of jade file \"' + this.filename + '\"');\n                                return tok;\n                            }\n                        },\n                        dot: function () {\n                            return this.scan(/^\\./, 'dot');\n                        },\n                        'extends': function () {\n                            return this.scan(/^extends? +([^\\n]+)/, 'extends');\n                        },\n                        prepend: function () {\n                            var captures;\n                            if (captures = /^prepend +([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var mode = 'prepend', name = captures[1], tok = this.tok('block', name);\n                                tok.mode = mode;\n                                return tok;\n                            }\n                        },\n                        append: function () {\n                            var captures;\n                            if (captures = /^append +([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var mode = 'append', name = captures[1], tok = this.tok('block', name);\n                                tok.mode = mode;\n                                return tok;\n                            }\n                        },\n                        block: function () {\n                            var captures;\n                            if (captures = /^block\\b *(?:(prepend|append) +)?([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var mode = captures[1] || 'replace', name = captures[2], tok = this.tok('block', name);\n                                tok.mode = mode;\n                                return tok;\n                            }\n                        },\n                        mixinBlock: function () {\n                            var captures;\n                            if (captures = /^block\\s*(\\n|$)/.exec(this.input)) {\n                                this.consume(captures[0].length - 1);\n                                return this.tok('mixin-block');\n                            }\n                        },\n                        yield: function () {\n                            return this.scan(/^yield */, 'yield');\n                        },\n                        include: function () {\n                            return this.scan(/^include +([^\\n]+)/, 'include');\n                        },\n                        includeFiltered: function () {\n                            var captures;\n                            if (captures = /^include:([\\w\\-]+) +([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var filter = captures[1];\n                                var path = captures[2];\n                                var tok = this.tok('include', path);\n                                tok.filter = filter;\n                                return tok;\n                            }\n                        },\n                        'case': function () {\n                            return this.scan(/^case +([^\\n]+)/, 'case');\n                        },\n                        when: function () {\n                            return this.scan(/^when +([^:\\n]+)/, 'when');\n                        },\n                        'default': function () {\n                            return this.scan(/^default */, 'default');\n                        },\n                        call: function () {\n                            var tok, captures;\n                            if (captures = /^\\+(([-\\w]+)|(#\\{))/.exec(this.input)) {\n                                if (captures[2]) {\n                                    this.consume(captures[0].length);\n                                    tok = this.tok('call', captures[2]);\n                                } else {\n                                    var match;\n                                    try {\n                                        match = this.bracketExpression(2);\n                                    } catch (ex) {\n                                        return;\n                                    }\n                                    this.consume(match.end + 1);\n                                    assertExpression(match.src);\n                                    tok = this.tok('call', '#{' + match.src + '}');\n                                }\n                                if (captures = /^ *\\(/.exec(this.input)) {\n                                    try {\n                                        var range = this.bracketExpression(captures[0].length - 1);\n                                        if (!/^ *[-\\w]+ *=/.test(range.src)) {\n                                            this.consume(range.end + 1);\n                                            tok.args = range.src;\n                                        }\n                                    } catch (ex) {\n                                    }\n                                }\n                                return tok;\n                            }\n                        },\n                        mixin: function () {\n                            var captures;\n                            if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var tok = this.tok('mixin', captures[1]);\n                                tok.args = captures[2];\n                                return tok;\n                            }\n                        },\n                        conditional: function () {\n                            var captures;\n                            if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var type = captures[1];\n                                var js = captures[2];\n                                var isIf = false;\n                                var isElse = false;\n                                switch (type) {\n                                case 'if':\n                                    assertExpression(js);\n                                    js = 'if (' + js + ')';\n                                    isIf = true;\n                                    break;\n                                case 'unless':\n                                    assertExpression(js);\n                                    js = 'if (!(' + js + '))';\n                                    isIf = true;\n                                    break;\n                                case 'else if':\n                                    assertExpression(js);\n                                    js = 'else if (' + js + ')';\n                                    isIf = true;\n                                    isElse = true;\n                                    break;\n                                case 'else':\n                                    if (js && js.trim()) {\n                                        throw new Error('`else` cannot have a condition, perhaps you meant `else if`');\n                                    }\n                                    js = 'else';\n                                    isElse = true;\n                                    break;\n                                }\n                                var tok = this.tok('code', js);\n                                tok.isElse = isElse;\n                                tok.isIf = isIf;\n                                tok.requiresBlock = true;\n                                return tok;\n                            }\n                        },\n                        'while': function () {\n                            var captures;\n                            if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                assertExpression(captures[1]);\n                                var tok = this.tok('code', 'while (' + captures[1] + ')');\n                                tok.requiresBlock = true;\n                                return tok;\n                            }\n                        },\n                        each: function () {\n                            var captures;\n                            if (captures = /^(?:- *)?(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var tok = this.tok('each', captures[1]);\n                                tok.key = captures[2] || '$index';\n                                assertExpression(captures[3]);\n                                tok.code = captures[3];\n                                return tok;\n                            }\n                        },\n                        code: function () {\n                            var captures;\n                            if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n                                this.consume(captures[0].length);\n                                var flags = captures[1];\n                                captures[1] = captures[2];\n                                var tok = this.tok('code', captures[1]);\n                                tok.escape = flags.charAt(0) === '=';\n                                tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';\n                                if (tok.buffer)\n                                    assertExpression(captures[1]);\n                                return tok;\n                            }\n                        },\n                        attrs: function () {\n                            if ('(' == this.input.charAt(0)) {\n                                var index = this.bracketExpression().end, str = this.input.substr(1, index - 1), tok = this.tok('attrs');\n                                assertNestingCorrect(str);\n                                var quote = '';\n                                var interpolate = function (attr) {\n                                    return attr.replace(/(\\\\)?#\\{(.+)/g, function (_, escape, expr) {\n                                        if (escape)\n                                            return _;\n                                        try {\n                                            var range = characterParser.parseMax(expr);\n                                            if (expr[range.end] !== '}')\n                                                return _.substr(0, 2) + interpolate(_.substr(2));\n                                            assertExpression(range.src);\n                                            return quote + ' + (' + range.src + ') + ' + quote + interpolate(expr.substr(range.end + 1));\n                                        } catch (ex) {\n                                            return _.substr(0, 2) + interpolate(_.substr(2));\n                                        }\n                                    });\n                                };\n                                this.consume(index + 1);\n                                tok.attrs = [];\n                                var escapedAttr = true;\n                                var key = '';\n                                var val = '';\n                                var interpolatable = '';\n                                var state = characterParser.defaultState();\n                                var loc = 'key';\n                                var isEndOfAttribute = function (i) {\n                                    if (key.trim() === '')\n                                        return false;\n                                    if (i === str.length)\n                                        return true;\n                                    if (loc === 'key') {\n                                        if (str[i] === ' ' || str[i] === '\\n') {\n                                            for (var x = i; x < str.length; x++) {\n                                                if (str[x] != ' ' && str[x] != '\\n') {\n                                                    if (str[x] === '=' || str[x] === '!' || str[x] === ',')\n                                                        return false;\n                                                    else\n                                                        return true;\n                                                }\n                                            }\n                                        }\n                                        return str[i] === ',';\n                                    } else if (loc === 'value' && !state.isNesting()) {\n                                        try {\n                                            Function('', 'return (' + val + ');');\n                                            if (str[i] === ' ' || str[i] === '\\n') {\n                                                for (var x = i; x < str.length; x++) {\n                                                    if (str[x] != ' ' && str[x] != '\\n') {\n                                                        if (characterParser.isPunctuator(str[x]) && str[x] != '\"' && str[x] != \"'\")\n                                                            return false;\n                                                        else\n                                                            return true;\n                                                    }\n                                                }\n                                            }\n                                            return str[i] === ',';\n                                        } catch (ex) {\n                                            return false;\n                                        }\n                                    }\n                                };\n                                this.lineno += str.split('\\n').length - 1;\n                                for (var i = 0; i <= str.length; i++) {\n                                    if (isEndOfAttribute(i)) {\n                                        val = val.trim();\n                                        if (val)\n                                            assertExpression(val);\n                                        key = key.trim();\n                                        key = key.replace(/^['\"]|['\"]$/g, '');\n                                        tok.attrs.push({\n                                            name: key,\n                                            val: '' == val ? true : val,\n                                            escaped: escapedAttr\n                                        });\n                                        key = val = '';\n                                        loc = 'key';\n                                        escapedAttr = false;\n                                    } else {\n                                        switch (loc) {\n                                        case 'key-char':\n                                            if (str[i] === quote) {\n                                                loc = 'key';\n                                                if (i + 1 < str.length && [\n                                                        ' ',\n                                                        ',',\n                                                        '!',\n                                                        '=',\n                                                        '\\n'\n                                                    ].indexOf(str[i + 1]) === -1)\n                                                    throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\\\n`, `,`, `!` or `=`');\n                                            } else {\n                                                key += str[i];\n                                            }\n                                            break;\n                                        case 'key':\n                                            if (key === '' && (str[i] === '\"' || str[i] === \"'\")) {\n                                                loc = 'key-char';\n                                                quote = str[i];\n                                            } else if (str[i] === '!' || str[i] === '=') {\n                                                escapedAttr = str[i] !== '!';\n                                                if (str[i] === '!')\n                                                    i++;\n                                                if (str[i] !== '=')\n                                                    throw new Error('Unexpected character ' + str[i] + ' expected `=`');\n                                                loc = 'value';\n                                                state = characterParser.defaultState();\n                                            } else {\n                                                key += str[i];\n                                            }\n                                            break;\n                                        case 'value':\n                                            state = characterParser.parseChar(str[i], state);\n                                            if (state.isString()) {\n                                                loc = 'string';\n                                                quote = str[i];\n                                                interpolatable = str[i];\n                                            } else {\n                                                val += str[i];\n                                            }\n                                            break;\n                                        case 'string':\n                                            state = characterParser.parseChar(str[i], state);\n                                            interpolatable += str[i];\n                                            if (!state.isString()) {\n                                                loc = 'value';\n                                                val += interpolate(interpolatable);\n                                            }\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ('/' == this.input.charAt(0)) {\n                                    this.consume(1);\n                                    tok.selfClosing = true;\n                                }\n                                return tok;\n                            }\n                        },\n                        attributesBlock: function () {\n                            var captures;\n                            if (/^&attributes\\b/.test(this.input)) {\n                                this.consume(11);\n                                var args = this.bracketExpression();\n                                this.consume(args.end + 1);\n                                return this.tok('&attributes', args.src);\n                            }\n                        },\n                        indent: function () {\n                            var captures, re;\n                            if (this.indentRe) {\n                                captures = this.indentRe.exec(this.input);\n                            } else {\n                                re = /^\\n(\\t*) */;\n                                captures = re.exec(this.input);\n                                if (captures && !captures[1].length) {\n                                    re = /^\\n( *)/;\n                                    captures = re.exec(this.input);\n                                }\n                                if (captures && captures[1].length)\n                                    this.indentRe = re;\n                            }\n                            if (captures) {\n                                var tok, indents = captures[1].length;\n                                ++this.lineno;\n                                this.consume(indents + 1);\n                                if (' ' == this.input[0] || '\\t' == this.input[0]) {\n                                    throw new Error('Invalid indentation, you can use tabs or spaces but not both');\n                                }\n                                if ('\\n' == this.input[0])\n                                    return this.tok('newline');\n                                if (this.indentStack.length && indents < this.indentStack[0]) {\n                                    while (this.indentStack.length && this.indentStack[0] > indents) {\n                                        this.stash.push(this.tok('outdent'));\n                                        this.indentStack.shift();\n                                    }\n                                    tok = this.stash.pop();\n                                } else if (indents && indents != this.indentStack[0]) {\n                                    this.indentStack.unshift(indents);\n                                    tok = this.tok('indent', indents);\n                                } else {\n                                    tok = this.tok('newline');\n                                }\n                                return tok;\n                            }\n                        },\n                        pipelessText: function () {\n                            if (this.pipeless) {\n                                if ('\\n' == this.input[0])\n                                    return;\n                                var i = this.input.indexOf('\\n');\n                                if (-1 == i)\n                                    i = this.input.length;\n                                var str = this.input.substr(0, i);\n                                this.consume(str.length);\n                                return this.tok('text', str);\n                            }\n                        },\n                        colon: function () {\n                            return this.scan(/^: */, ':');\n                        },\n                        fail: function () {\n                            if (/^ ($|\\n)/.test(this.input)) {\n                                this.consume(1);\n                                return this.next();\n                            }\n                            throw new Error('unexpected text ' + this.input.substr(0, 5));\n                        },\n                        advance: function () {\n                            return this.stashed() || this.next();\n                        },\n                        next: function () {\n                            return this.deferred() || this.blank() || this.eos() || this.pipelessText() || this.yield() || this.doctype() || this.interpolation() || this['case']() || this.when() || this['default']() || this['extends']() || this.append() || this.prepend() || this.block() || this.mixinBlock() || this.include() || this.includeFiltered() || this.mixin() || this.call() || this.conditional() || this.each() || this['while']() || this.tag() || this.filter() || this.code() || this.id() || this.className() || this.attrs() || this.attributesBlock() || this.indent() || this.text() || this.comment() || this.colon() || this.dot() || this.textFail() || this.fail();\n                        }\n                    };\n                },\n                {\n                    './utils': 26,\n                    'character-parser': 33\n                }\n            ],\n            7: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Attrs = module.exports = function Attrs() {\n                        this.attributeNames = [];\n                        this.attrs = [];\n                        this.attributeBlocks = [];\n                    };\n                    Attrs.prototype = Object.create(Node.prototype);\n                    Attrs.prototype.constructor = Attrs;\n                    Attrs.prototype.type = 'Attrs';\n                    Attrs.prototype.setAttribute = function (name, val, escaped) {\n                        if (name !== 'class' && this.attributeNames.indexOf(name) !== -1) {\n                            throw new Error('Duplicate attribute \"' + name + '\" is not allowed.');\n                        }\n                        this.attributeNames.push(name);\n                        this.attrs.push({\n                            name: name,\n                            val: val,\n                            escaped: escaped\n                        });\n                        return this;\n                    };\n                    Attrs.prototype.removeAttribute = function (name) {\n                        var err = new Error('attrs.removeAttribute is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        for (var i = 0, len = this.attrs.length; i < len; ++i) {\n                            if (this.attrs[i] && this.attrs[i].name == name) {\n                                delete this.attrs[i];\n                            }\n                        }\n                    };\n                    Attrs.prototype.getAttribute = function (name) {\n                        var err = new Error('attrs.getAttribute is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        for (var i = 0, len = this.attrs.length; i < len; ++i) {\n                            if (this.attrs[i] && this.attrs[i].name == name) {\n                                return this.attrs[i].val;\n                            }\n                        }\n                    };\n                    Attrs.prototype.addAttributes = function (src) {\n                        this.attributeBlocks.push(src);\n                    };\n                },\n                { './node': 20 }\n            ],\n            8: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var BlockComment = module.exports = function BlockComment(val, block, buffer) {\n                        this.block = block;\n                        this.val = val;\n                        this.buffer = buffer;\n                    };\n                    BlockComment.prototype = Object.create(Node.prototype);\n                    BlockComment.prototype.constructor = BlockComment;\n                    BlockComment.prototype.type = 'BlockComment';\n                },\n                { './node': 20 }\n            ],\n            9: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Block = module.exports = function Block(node) {\n                        this.nodes = [];\n                        if (node)\n                            this.push(node);\n                    };\n                    Block.prototype = Object.create(Node.prototype);\n                    Block.prototype.constructor = Block;\n                    Block.prototype.type = 'Block';\n                    Block.prototype.isBlock = true;\n                    Block.prototype.replace = function (other) {\n                        var err = new Error('block.replace is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        other.nodes = this.nodes;\n                    };\n                    Block.prototype.push = function (node) {\n                        return this.nodes.push(node);\n                    };\n                    Block.prototype.isEmpty = function () {\n                        return 0 == this.nodes.length;\n                    };\n                    Block.prototype.unshift = function (node) {\n                        return this.nodes.unshift(node);\n                    };\n                    Block.prototype.includeBlock = function () {\n                        var ret = this, node;\n                        for (var i = 0, len = this.nodes.length; i < len; ++i) {\n                            node = this.nodes[i];\n                            if (node.yield)\n                                return node;\n                            else if (node.textOnly)\n                                continue;\n                            else if (node.includeBlock)\n                                ret = node.includeBlock();\n                            else if (node.block && !node.block.isEmpty())\n                                ret = node.block.includeBlock();\n                            if (ret.yield)\n                                return ret;\n                        }\n                        return ret;\n                    };\n                    Block.prototype.clone = function () {\n                        var err = new Error('block.clone is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        var clone = new Block();\n                        for (var i = 0, len = this.nodes.length; i < len; ++i) {\n                            clone.push(this.nodes[i].clone());\n                        }\n                        return clone;\n                    };\n                },\n                { './node': 20 }\n            ],\n            10: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Case = exports = module.exports = function Case(expr, block) {\n                        this.expr = expr;\n                        this.block = block;\n                    };\n                    Case.prototype = Object.create(Node.prototype);\n                    Case.prototype.constructor = Case;\n                    Case.prototype.type = 'Case';\n                    var When = exports.When = function When(expr, block) {\n                        this.expr = expr;\n                        this.block = block;\n                        this.debug = false;\n                    };\n                    When.prototype = Object.create(Node.prototype);\n                    When.prototype.constructor = When;\n                    When.prototype.type = 'When';\n                },\n                { './node': 20 }\n            ],\n            11: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Code = module.exports = function Code(val, buffer, escape) {\n                        this.val = val;\n                        this.buffer = buffer;\n                        this.escape = escape;\n                        if (val.match(/^ *else/))\n                            this.debug = false;\n                    };\n                    Code.prototype = Object.create(Node.prototype);\n                    Code.prototype.constructor = Code;\n                    Code.prototype.type = 'Code';\n                },\n                { './node': 20 }\n            ],\n            12: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Comment = module.exports = function Comment(val, buffer) {\n                        this.val = val;\n                        this.buffer = buffer;\n                    };\n                    Comment.prototype = Object.create(Node.prototype);\n                    Comment.prototype.constructor = Comment;\n                    Comment.prototype.type = 'Comment';\n                },\n                { './node': 20 }\n            ],\n            13: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Doctype = module.exports = function Doctype(val) {\n                        this.val = val;\n                    };\n                    Doctype.prototype = Object.create(Node.prototype);\n                    Doctype.prototype.constructor = Doctype;\n                    Doctype.prototype.type = 'Doctype';\n                },\n                { './node': 20 }\n            ],\n            14: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Each = module.exports = function Each(obj, val, key, block) {\n                        this.obj = obj;\n                        this.val = val;\n                        this.key = key;\n                        this.block = block;\n                    };\n                    Each.prototype = Object.create(Node.prototype);\n                    Each.prototype.constructor = Each;\n                    Each.prototype.type = 'Each';\n                },\n                { './node': 20 }\n            ],\n            15: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Filter = module.exports = function Filter(name, block, attrs) {\n                        this.name = name;\n                        this.block = block;\n                        this.attrs = attrs;\n                    };\n                    Filter.prototype = Object.create(Node.prototype);\n                    Filter.prototype.constructor = Filter;\n                    Filter.prototype.type = 'Filter';\n                },\n                { './node': 20 }\n            ],\n            16: [\n                function (_dereq_, module, exports) {\n                    exports.Node = _dereq_('./node');\n                    exports.Tag = _dereq_('./tag');\n                    exports.Code = _dereq_('./code');\n                    exports.Each = _dereq_('./each');\n                    exports.Case = _dereq_('./case');\n                    exports.Text = _dereq_('./text');\n                    exports.Block = _dereq_('./block');\n                    exports.MixinBlock = _dereq_('./mixin-block');\n                    exports.Mixin = _dereq_('./mixin');\n                    exports.Filter = _dereq_('./filter');\n                    exports.Comment = _dereq_('./comment');\n                    exports.Literal = _dereq_('./literal');\n                    exports.BlockComment = _dereq_('./block-comment');\n                    exports.Doctype = _dereq_('./doctype');\n                },\n                {\n                    './block': 9,\n                    './block-comment': 8,\n                    './case': 10,\n                    './code': 11,\n                    './comment': 12,\n                    './doctype': 13,\n                    './each': 14,\n                    './filter': 15,\n                    './literal': 17,\n                    './mixin': 19,\n                    './mixin-block': 18,\n                    './node': 20,\n                    './tag': 21,\n                    './text': 22\n                }\n            ],\n            17: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Literal = module.exports = function Literal(str) {\n                        this.str = str;\n                    };\n                    Literal.prototype = Object.create(Node.prototype);\n                    Literal.prototype.constructor = Literal;\n                    Literal.prototype.type = 'Literal';\n                },\n                { './node': 20 }\n            ],\n            18: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var MixinBlock = module.exports = function MixinBlock() {\n                    };\n                    MixinBlock.prototype = Object.create(Node.prototype);\n                    MixinBlock.prototype.constructor = MixinBlock;\n                    MixinBlock.prototype.type = 'MixinBlock';\n                },\n                { './node': 20 }\n            ],\n            19: [\n                function (_dereq_, module, exports) {\n                    var Attrs = _dereq_('./attrs');\n                    var Mixin = module.exports = function Mixin(name, args, block, call) {\n                        Attrs.call(this);\n                        this.name = name;\n                        this.args = args;\n                        this.block = block;\n                        this.call = call;\n                    };\n                    Mixin.prototype = Object.create(Attrs.prototype);\n                    Mixin.prototype.constructor = Mixin;\n                    Mixin.prototype.type = 'Mixin';\n                },\n                { './attrs': 7 }\n            ],\n            20: [\n                function (_dereq_, module, exports) {\n                    var Node = module.exports = function Node() {\n                    };\n                    Node.prototype.clone = function () {\n                        var err = new Error('node.clone is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        return this;\n                    };\n                    Node.prototype.type = '';\n                },\n                {}\n            ],\n            21: [\n                function (_dereq_, module, exports) {\n                    var Attrs = _dereq_('./attrs');\n                    var Block = _dereq_('./block');\n                    var inlineTags = _dereq_('../inline-tags');\n                    var Tag = module.exports = function Tag(name, block) {\n                        Attrs.call(this);\n                        this.name = name;\n                        this.block = block || new Block();\n                    };\n                    Tag.prototype = Object.create(Attrs.prototype);\n                    Tag.prototype.constructor = Tag;\n                    Tag.prototype.type = 'Tag';\n                    Tag.prototype.clone = function () {\n                        var err = new Error('tag.clone is deprecated and will be removed in v2.0.0');\n                        console.warn(err.stack);\n                        var clone = new Tag(this.name, this.block.clone());\n                        clone.line = this.line;\n                        clone.attrs = this.attrs;\n                        clone.textOnly = this.textOnly;\n                        return clone;\n                    };\n                    Tag.prototype.isInline = function () {\n                        return ~inlineTags.indexOf(this.name);\n                    };\n                    Tag.prototype.canInline = function () {\n                        var nodes = this.block.nodes;\n                        function isInline(node) {\n                            if (node.isBlock)\n                                return node.nodes.every(isInline);\n                            return node.isText || node.isInline && node.isInline();\n                        }\n                        if (!nodes.length)\n                            return true;\n                        if (1 == nodes.length)\n                            return isInline(nodes[0]);\n                        if (this.block.nodes.every(isInline)) {\n                            for (var i = 1, len = nodes.length; i < len; ++i) {\n                                if (nodes[i - 1].isText && nodes[i].isText)\n                                    return false;\n                            }\n                            return true;\n                        }\n                        return false;\n                    };\n                },\n                {\n                    '../inline-tags': 4,\n                    './attrs': 7,\n                    './block': 9\n                }\n            ],\n            22: [\n                function (_dereq_, module, exports) {\n                    var Node = _dereq_('./node');\n                    var Text = module.exports = function Text(line) {\n                        this.val = line;\n                    };\n                    Text.prototype = Object.create(Node.prototype);\n                    Text.prototype.constructor = Text;\n                    Text.prototype.type = 'Text';\n                    Text.prototype.isText = true;\n                },\n                { './node': 20 }\n            ],\n            23: [\n                function (_dereq_, module, exports) {\n                    var Lexer = _dereq_('./lexer');\n                    var nodes = _dereq_('./nodes');\n                    var utils = _dereq_('./utils');\n                    var filters = _dereq_('./filters');\n                    var path = _dereq_('path');\n                    var constantinople = _dereq_('constantinople');\n                    var parseJSExpression = _dereq_('character-parser').parseMax;\n                    var extname = path.extname;\n                    var Parser = exports = module.exports = function Parser(str, filename, options) {\n                        this.input = str.replace(/^\\uFEFF/, '');\n                        this.lexer = new Lexer(this.input, filename);\n                        this.filename = filename;\n                        this.blocks = {};\n                        this.mixins = {};\n                        this.options = options;\n                        this.contexts = [this];\n                        this.inMixin = false;\n                    };\n                    Parser.prototype = {\n                        constructor: Parser,\n                        context: function (parser) {\n                            if (parser) {\n                                this.contexts.push(parser);\n                            } else {\n                                return this.contexts.pop();\n                            }\n                        },\n                        advance: function () {\n                            return this.lexer.advance();\n                        },\n                        peek: function () {\n                            return this.lookahead(1);\n                        },\n                        line: function () {\n                            return this.lexer.lineno;\n                        },\n                        lookahead: function (n) {\n                            return this.lexer.lookahead(n);\n                        },\n                        parse: function () {\n                            var block = new nodes.Block(), parser;\n                            block.line = 0;\n                            block.filename = this.filename;\n                            while ('eos' != this.peek().type) {\n                                if ('newline' == this.peek().type) {\n                                    this.advance();\n                                } else {\n                                    var next = this.peek();\n                                    var expr = this.parseExpr();\n                                    expr.filename = expr.filename || this.filename;\n                                    expr.line = next.line;\n                                    block.push(expr);\n                                }\n                            }\n                            if (parser = this.extending) {\n                                this.context(parser);\n                                var ast = parser.parse();\n                                this.context();\n                                for (var name in this.mixins)\n                                    ast.unshift(this.mixins[name]);\n                                return ast;\n                            }\n                            return block;\n                        },\n                        expect: function (type) {\n                            if (this.peek().type === type) {\n                                return this.advance();\n                            } else {\n                                throw new Error('expected \"' + type + '\", but got \"' + this.peek().type + '\"');\n                            }\n                        },\n                        accept: function (type) {\n                            if (this.peek().type === type) {\n                                return this.advance();\n                            }\n                        },\n                        parseExpr: function () {\n                            switch (this.peek().type) {\n                            case 'tag':\n                                return this.parseTag();\n                            case 'mixin':\n                                return this.parseMixin();\n                            case 'block':\n                                return this.parseBlock();\n                            case 'mixin-block':\n                                return this.parseMixinBlock();\n                            case 'case':\n                                return this.parseCase();\n                            case 'extends':\n                                return this.parseExtends();\n                            case 'include':\n                                return this.parseInclude();\n                            case 'doctype':\n                                return this.parseDoctype();\n                            case 'filter':\n                                return this.parseFilter();\n                            case 'comment':\n                                return this.parseComment();\n                            case 'text':\n                                return this.parseText();\n                            case 'each':\n                                return this.parseEach();\n                            case 'code':\n                                return this.parseCode();\n                            case 'call':\n                                return this.parseCall();\n                            case 'interpolation':\n                                return this.parseInterpolation();\n                            case 'yield':\n                                this.advance();\n                                var block = new nodes.Block();\n                                block.yield = true;\n                                return block;\n                            case 'id':\n                            case 'class':\n                                var tok = this.advance();\n                                this.lexer.defer(this.lexer.tok('tag', 'div'));\n                                this.lexer.defer(tok);\n                                return this.parseExpr();\n                            default:\n                                throw new Error('unexpected token \"' + this.peek().type + '\"');\n                            }\n                        },\n                        parseText: function () {\n                            var tok = this.expect('text');\n                            var tokens = this.parseTextWithInlineTags(tok.val);\n                            if (tokens.length === 1)\n                                return tokens[0];\n                            var node = new nodes.Block();\n                            for (var i = 0; i < tokens.length; i++) {\n                                node.push(tokens[i]);\n                            }\n                            ;\n                            return node;\n                        },\n                        parseBlockExpansion: function () {\n                            if (':' == this.peek().type) {\n                                this.advance();\n                                return new nodes.Block(this.parseExpr());\n                            } else {\n                                return this.block();\n                            }\n                        },\n                        parseCase: function () {\n                            var val = this.expect('case').val;\n                            var node = new nodes.Case(val);\n                            node.line = this.line();\n                            var block = new nodes.Block();\n                            block.line = this.line();\n                            block.filename = this.filename;\n                            this.expect('indent');\n                            while ('outdent' != this.peek().type) {\n                                switch (this.peek().type) {\n                                case 'newline':\n                                    this.advance();\n                                    break;\n                                case 'when':\n                                    block.push(this.parseWhen());\n                                    break;\n                                case 'default':\n                                    block.push(this.parseDefault());\n                                    break;\n                                default:\n                                    throw new Error('Unexpected token \"' + this.peek().type + '\", expected \"when\", \"default\" or \"newline\"');\n                                }\n                            }\n                            this.expect('outdent');\n                            node.block = block;\n                            return node;\n                        },\n                        parseWhen: function () {\n                            var val = this.expect('when').val;\n                            if (this.peek().type !== 'newline')\n                                return new nodes.Case.When(val, this.parseBlockExpansion());\n                            else\n                                return new nodes.Case.When(val);\n                        },\n                        parseDefault: function () {\n                            this.expect('default');\n                            return new nodes.Case.When('default', this.parseBlockExpansion());\n                        },\n                        parseCode: function (afterIf) {\n                            var tok = this.expect('code');\n                            var node = new nodes.Code(tok.val, tok.buffer, tok.escape);\n                            var block;\n                            node.line = this.line();\n                            if (tok.isElse && !tok.hasIf) {\n                                throw new Error('Unexpected else without if');\n                            }\n                            block = 'indent' == this.peek().type;\n                            if (block) {\n                                node.block = this.block();\n                            }\n                            if (tok.requiresBlock && !block) {\n                                node.block = new nodes.Block();\n                            }\n                            if (tok.isIf && this.peek().isElse) {\n                                this.peek().hasIf = true;\n                            } else if (tok.isIf && this.peek().type === 'newline' && this.lookahead(2).isElse) {\n                                this.lookahead(2).hasIf = true;\n                            }\n                            return node;\n                        },\n                        parseComment: function () {\n                            var tok = this.expect('comment');\n                            var node;\n                            if ('indent' == this.peek().type) {\n                                this.lexer.pipeless = true;\n                                node = new nodes.BlockComment(tok.val, this.parseTextBlock(), tok.buffer);\n                                this.lexer.pipeless = false;\n                            } else {\n                                node = new nodes.Comment(tok.val, tok.buffer);\n                            }\n                            node.line = this.line();\n                            return node;\n                        },\n                        parseDoctype: function () {\n                            var tok = this.expect('doctype');\n                            var node = new nodes.Doctype(tok.val);\n                            node.line = this.line();\n                            return node;\n                        },\n                        parseFilter: function () {\n                            var tok = this.expect('filter');\n                            var attrs = this.accept('attrs');\n                            var block;\n                            if ('indent' == this.peek().type) {\n                                this.lexer.pipeless = true;\n                                block = this.parseTextBlock();\n                                this.lexer.pipeless = false;\n                            } else {\n                                block = new nodes.Block();\n                            }\n                            var options = {};\n                            if (attrs) {\n                                attrs.attrs.forEach(function (attribute) {\n                                    options[attribute.name] = constantinople.toConstant(attribute.val);\n                                });\n                            }\n                            var node = new nodes.Filter(tok.val, block, options);\n                            node.line = this.line();\n                            return node;\n                        },\n                        parseEach: function () {\n                            var tok = this.expect('each');\n                            var node = new nodes.Each(tok.code, tok.val, tok.key);\n                            node.line = this.line();\n                            node.block = this.block();\n                            if (this.peek().type == 'code' && this.peek().val == 'else') {\n                                this.advance();\n                                node.alternative = this.block();\n                            }\n                            return node;\n                        },\n                        resolvePath: function (path, purpose) {\n                            var p = _dereq_('path');\n                            var dirname = p.dirname;\n                            var basename = p.basename;\n                            var join = p.join;\n                            if (path[0] !== '/' && !this.filename)\n                                throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');\n                            if (path[0] === '/' && !this.options.basedir)\n                                throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');\n                            path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);\n                            if (basename(path).indexOf('.') === -1)\n                                path += '.jade';\n                            return path;\n                        },\n                        parseExtends: function () {\n                            var fs = _dereq_('fs');\n                            var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');\n                            if ('.jade' != path.substr(-5))\n                                path += '.jade';\n                            var str = fs.readFileSync(path, 'utf8');\n                            var parser = new this.constructor(str, path, this.options);\n                            parser.blocks = this.blocks;\n                            parser.contexts = this.contexts;\n                            this.extending = parser;\n                            return new nodes.Literal('');\n                        },\n                        parseBlock: function () {\n                            var block = this.expect('block');\n                            var mode = block.mode;\n                            var name = block.val.trim();\n                            block = 'indent' == this.peek().type ? this.block() : new nodes.Block(new nodes.Literal(''));\n                            var prev = this.blocks[name] || {\n                                prepended: [],\n                                appended: []\n                            };\n                            if (prev.mode === 'replace')\n                                return this.blocks[name] = prev;\n                            var allNodes = prev.prepended.concat(block.nodes).concat(prev.appended);\n                            switch (mode) {\n                            case 'append':\n                                prev.appended = prev.parser === this ? prev.appended.concat(block.nodes) : block.nodes.concat(prev.appended);\n                                break;\n                            case 'prepend':\n                                prev.prepended = prev.parser === this ? block.nodes.concat(prev.prepended) : prev.prepended.concat(block.nodes);\n                                break;\n                            }\n                            block.nodes = allNodes;\n                            block.appended = prev.appended;\n                            block.prepended = prev.prepended;\n                            block.mode = mode;\n                            block.parser = this;\n                            return this.blocks[name] = block;\n                        },\n                        parseMixinBlock: function () {\n                            var block = this.expect('mixin-block');\n                            if (!this.inMixin) {\n                                throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.');\n                            }\n                            return new nodes.MixinBlock();\n                        },\n                        parseInclude: function () {\n                            var fs = _dereq_('fs');\n                            var tok = this.expect('include');\n                            var path = this.resolvePath(tok.val.trim(), 'include');\n                            if (tok.filter) {\n                                var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n                                str = filters(tok.filter, str, { filename: path });\n                                return new nodes.Literal(str);\n                            }\n                            if ('.jade' != path.substr(-5)) {\n                                var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n                                return new nodes.Literal(str);\n                            }\n                            var str = fs.readFileSync(path, 'utf8');\n                            var parser = new this.constructor(str, path, this.options);\n                            parser.blocks = utils.merge({}, this.blocks);\n                            parser.mixins = this.mixins;\n                            this.context(parser);\n                            var ast = parser.parse();\n                            this.context();\n                            ast.filename = path;\n                            if ('indent' == this.peek().type) {\n                                ast.includeBlock().push(this.block());\n                            }\n                            return ast;\n                        },\n                        parseCall: function () {\n                            var tok = this.expect('call');\n                            var name = tok.val;\n                            var args = tok.args;\n                            var mixin = new nodes.Mixin(name, args, new nodes.Block(), true);\n                            this.tag(mixin);\n                            if (mixin.code) {\n                                mixin.block.push(mixin.code);\n                                mixin.code = null;\n                            }\n                            if (mixin.block.isEmpty())\n                                mixin.block = null;\n                            return mixin;\n                        },\n                        parseMixin: function () {\n                            var tok = this.expect('mixin');\n                            var name = tok.val;\n                            var args = tok.args;\n                            var mixin;\n                            if ('indent' == this.peek().type) {\n                                this.inMixin = true;\n                                mixin = new nodes.Mixin(name, args, this.block(), false);\n                                this.mixins[name] = mixin;\n                                this.inMixin = false;\n                                return mixin;\n                            } else {\n                                return new nodes.Mixin(name, args, null, true);\n                            }\n                        },\n                        parseTextWithInlineTags: function (str) {\n                            var line = this.line();\n                            var match = /(\\\\)?#\\[((?:.|\\n)*)$/.exec(str);\n                            if (match) {\n                                if (match[1]) {\n                                    var text = new nodes.Text(str.substr(0, match.index) + '#[');\n                                    text.line = line;\n                                    var rest = this.parseTextWithInlineTags(match[2]);\n                                    if (rest[0].type === 'Text') {\n                                        text.val += rest[0].val;\n                                        rest.shift();\n                                    }\n                                    return [text].concat(rest);\n                                } else {\n                                    var text = new nodes.Text(str.substr(0, match.index));\n                                    text.line = line;\n                                    var buffer = [text];\n                                    var rest = match[2];\n                                    var range = parseJSExpression(rest);\n                                    var inner = new Parser(range.src, this.filename, this.options);\n                                    buffer.push(inner.parse());\n                                    return buffer.concat(this.parseTextWithInlineTags(rest.substr(range.end + 1)));\n                                }\n                            } else {\n                                var text = new nodes.Text(str);\n                                text.line = line;\n                                return [text];\n                            }\n                        },\n                        parseTextBlock: function () {\n                            var block = new nodes.Block();\n                            block.line = this.line();\n                            var spaces = this.expect('indent').val;\n                            if (null == this._spaces)\n                                this._spaces = spaces;\n                            var indent = Array(spaces - this._spaces + 1).join(' ');\n                            while ('outdent' != this.peek().type) {\n                                switch (this.peek().type) {\n                                case 'newline':\n                                    this.advance();\n                                    break;\n                                case 'indent':\n                                    this.parseTextBlock(true).nodes.forEach(function (node) {\n                                        block.push(node);\n                                    });\n                                    break;\n                                default:\n                                    var texts = this.parseTextWithInlineTags(indent + this.advance().val);\n                                    texts.forEach(function (text) {\n                                        block.push(text);\n                                    });\n                                }\n                            }\n                            if (spaces == this._spaces)\n                                this._spaces = null;\n                            this.expect('outdent');\n                            return block;\n                        },\n                        block: function () {\n                            var block = new nodes.Block();\n                            block.line = this.line();\n                            block.filename = this.filename;\n                            this.expect('indent');\n                            while ('outdent' != this.peek().type) {\n                                if ('newline' == this.peek().type) {\n                                    this.advance();\n                                } else {\n                                    var expr = this.parseExpr();\n                                    expr.filename = this.filename;\n                                    block.push(expr);\n                                }\n                            }\n                            this.expect('outdent');\n                            return block;\n                        },\n                        parseInterpolation: function () {\n                            var tok = this.advance();\n                            var tag = new nodes.Tag(tok.val);\n                            tag.buffer = true;\n                            return this.tag(tag);\n                        },\n                        parseTag: function () {\n                            var tok = this.advance();\n                            var tag = new nodes.Tag(tok.val);\n                            tag.selfClosing = tok.selfClosing;\n                            return this.tag(tag);\n                        },\n                        tag: function (tag) {\n                            tag.line = this.line();\n                            var seenAttrs = false;\n                            out:\n                                while (true) {\n                                    switch (this.peek().type) {\n                                    case 'id':\n                                    case 'class':\n                                        var tok = this.advance();\n                                        tag.setAttribute(tok.type, \"'\" + tok.val + \"'\");\n                                        continue;\n                                    case 'attrs':\n                                        if (seenAttrs) {\n                                            console.warn(this.filename + ', line ' + this.peek().line + ':\\nYou should not have jade tags with multiple attributes.');\n                                        }\n                                        seenAttrs = true;\n                                        var tok = this.advance();\n                                        var attrs = tok.attrs;\n                                        if (tok.selfClosing)\n                                            tag.selfClosing = true;\n                                        for (var i = 0; i < attrs.length; i++) {\n                                            tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped);\n                                        }\n                                        continue;\n                                    case '&attributes':\n                                        var tok = this.advance();\n                                        tag.addAttributes(tok.val);\n                                        break;\n                                    default:\n                                        break out;\n                                    }\n                                }\n                            if ('dot' == this.peek().type) {\n                                tag.textOnly = true;\n                                this.advance();\n                            }\n                            switch (this.peek().type) {\n                            case 'text':\n                                tag.block.push(this.parseText());\n                                break;\n                            case 'code':\n                                tag.code = this.parseCode();\n                                break;\n                            case ':':\n                                this.advance();\n                                tag.block = new nodes.Block();\n                                tag.block.push(this.parseExpr());\n                                break;\n                            case 'newline':\n                            case 'indent':\n                            case 'outdent':\n                            case 'eos':\n                                break;\n                            default:\n                                throw new Error('Unexpected token `' + this.peek().type + '` expected `text`, `code`, `:`, `newline` or `eos`');\n                            }\n                            while ('newline' == this.peek().type)\n                                this.advance();\n                            if ('indent' == this.peek().type) {\n                                if (tag.textOnly) {\n                                    this.lexer.pipeless = true;\n                                    tag.block = this.parseTextBlock();\n                                    this.lexer.pipeless = false;\n                                } else {\n                                    var block = this.block();\n                                    for (var i = 0, len = block.nodes.length; i < len; ++i) {\n                                        tag.block.push(block.nodes[i]);\n                                    }\n                                }\n                            }\n                            return tag;\n                        }\n                    };\n                },\n                {\n                    './filters': 3,\n                    './lexer': 6,\n                    './nodes': 16,\n                    './utils': 26,\n                    'character-parser': 33,\n                    'constantinople': 34,\n                    'fs': 27,\n                    'path': 30\n                }\n            ],\n            24: [\n                function (_dereq_, module, exports) {\n                    exports.merge = function merge(a, b) {\n                        if (arguments.length === 1) {\n                            var attrs = a[0];\n                            for (var i = 1; i < a.length; i++) {\n                                attrs = merge(attrs, a[i]);\n                            }\n                            return attrs;\n                        }\n                        var ac = a['class'];\n                        var bc = b['class'];\n                        if (ac || bc) {\n                            ac = ac || [];\n                            bc = bc || [];\n                            if (!Array.isArray(ac))\n                                ac = [ac];\n                            if (!Array.isArray(bc))\n                                bc = [bc];\n                            a['class'] = ac.concat(bc).filter(nulls);\n                        }\n                        for (var key in b) {\n                            if (key != 'class') {\n                                a[key] = b[key];\n                            }\n                        }\n                        return a;\n                    };\n                    function nulls(val) {\n                        return val != null && val !== '';\n                    }\n                    exports.joinClasses = joinClasses;\n                    function joinClasses(val) {\n                        return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\n                    }\n                    exports.cls = function cls(classes, escaped) {\n                        var buf = [];\n                        for (var i = 0; i < classes.length; i++) {\n                            if (escaped && escaped[i]) {\n                                buf.push(exports.escape(joinClasses([classes[i]])));\n                            } else {\n                                buf.push(joinClasses(classes[i]));\n                            }\n                        }\n                        var text = joinClasses(buf);\n                        if (text.length) {\n                            return ' class=\"' + text + '\"';\n                        } else {\n                            return '';\n                        }\n                    };\n                    exports.attr = function attr(key, val, escaped, terse) {\n                        if ('boolean' == typeof val || null == val) {\n                            if (val) {\n                                return ' ' + (terse ? key : key + '=\"' + key + '\"');\n                            } else {\n                                return '';\n                            }\n                        } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n                            return ' ' + key + \"='\" + JSON.stringify(val).replace(/'/g, '&apos;') + \"'\";\n                        } else if (escaped) {\n                            return ' ' + key + '=\"' + exports.escape(val) + '\"';\n                        } else {\n                            return ' ' + key + '=\"' + val + '\"';\n                        }\n                    };\n                    exports.attrs = function attrs(obj, terse) {\n                        var buf = [];\n                        var keys = Object.keys(obj);\n                        if (keys.length) {\n                            for (var i = 0; i < keys.length; ++i) {\n                                var key = keys[i], val = obj[key];\n                                if ('class' == key) {\n                                    if (val = joinClasses(val)) {\n                                        buf.push(' ' + key + '=\"' + val + '\"');\n                                    }\n                                } else {\n                                    buf.push(exports.attr(key, val, false, terse));\n                                }\n                            }\n                        }\n                        return buf.join('');\n                    };\n                    exports.escape = function escape(html) {\n                        var result = String(html).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n                        if (result === '' + html)\n                            return html;\n                        else\n                            return result;\n                    };\n                    exports.rethrow = function rethrow(err, filename, lineno, str) {\n                        if (!(err instanceof Error))\n                            throw err;\n                        if ((typeof window != 'undefined' || !filename) && !str) {\n                            err.message += ' on line ' + lineno;\n                            throw err;\n                        }\n                        try {\n                            str = str || _dereq_('fs').readFileSync(filename, 'utf8');\n                        } catch (ex) {\n                            rethrow(err, null, lineno);\n                        }\n                        var context = 3, lines = str.split('\\n'), start = Math.max(lineno - context, 0), end = Math.min(lines.length, lineno + context);\n                        var context = lines.slice(start, end).map(function (line, i) {\n                            var curr = i + start + 1;\n                            return (curr == lineno ? '  > ' : '    ') + curr + '| ' + line;\n                        }).join('\\n');\n                        err.path = filename;\n                        err.message = (filename || 'Jade') + ':' + lineno + '\\n' + context + '\\n\\n' + err.message;\n                        throw err;\n                    };\n                },\n                { 'fs': 27 }\n            ],\n            25: [\n                function (_dereq_, module, exports) {\n                    module.exports = [\n                        'area',\n                        'base',\n                        'br',\n                        'col',\n                        'embed',\n                        'hr',\n                        'img',\n                        'input',\n                        'keygen',\n                        'link',\n                        'menuitem',\n                        'meta',\n                        'param',\n                        'source',\n                        'track',\n                        'wbr'\n                    ];\n                },\n                {}\n            ],\n            26: [\n                function (_dereq_, module, exports) {\n                    exports.merge = function (a, b) {\n                        for (var key in b)\n                            a[key] = b[key];\n                        return a;\n                    };\n                },\n                {}\n            ],\n            27: [\n                function (_dereq_, module, exports) {\n                },\n                {}\n            ],\n            28: [\n                function (_dereq_, module, exports) {\n                    if (typeof Object.create === 'function') {\n                        module.exports = function inherits(ctor, superCtor) {\n                            ctor.super_ = superCtor;\n                            ctor.prototype = Object.create(superCtor.prototype, {\n                                constructor: {\n                                    value: ctor,\n                                    enumerable: false,\n                                    writable: true,\n                                    configurable: true\n                                }\n                            });\n                        };\n                    } else {\n                        module.exports = function inherits(ctor, superCtor) {\n                            ctor.super_ = superCtor;\n                            var TempCtor = function () {\n                            };\n                            TempCtor.prototype = superCtor.prototype;\n                            ctor.prototype = new TempCtor();\n                            ctor.prototype.constructor = ctor;\n                        };\n                    }\n                },\n                {}\n            ],\n            29: [\n                function (_dereq_, module, exports) {\n                    var process = module.exports = {};\n                    process.nextTick = function () {\n                        var canSetImmediate = typeof window !== 'undefined' && window.setImmediate;\n                        var canPost = typeof window !== 'undefined' && window.postMessage && window.addEventListener;\n                        if (canSetImmediate) {\n                            return function (f) {\n                                return window.setImmediate(f);\n                            };\n                        }\n                        if (canPost) {\n                            var queue = [];\n                            window.addEventListener('message', function (ev) {\n                                var source = ev.source;\n                                if ((source === window || source === null) && ev.data === 'process-tick') {\n                                    ev.stopPropagation();\n                                    if (queue.length > 0) {\n                                        var fn = queue.shift();\n                                        fn();\n                                    }\n                                }\n                            }, true);\n                            return function nextTick(fn) {\n                                queue.push(fn);\n                                window.postMessage('process-tick', '*');\n                            };\n                        }\n                        return function nextTick(fn) {\n                            setTimeout(fn, 0);\n                        };\n                    }();\n                    process.title = 'browser';\n                    process.browser = true;\n                    process.env = {};\n                    process.argv = [];\n                    process.binding = function (name) {\n                        throw new Error('process.binding is not supported');\n                    };\n                    process.cwd = function () {\n                        return '/';\n                    };\n                    process.chdir = function (dir) {\n                        throw new Error('process.chdir is not supported');\n                    };\n                },\n                {}\n            ],\n            30: [\n                function (_dereq_, module, exports) {\n                    (function (process) {\n                        function normalizeArray(parts, allowAboveRoot) {\n                            var up = 0;\n                            for (var i = parts.length - 1; i >= 0; i--) {\n                                var last = parts[i];\n                                if (last === '.') {\n                                    parts.splice(i, 1);\n                                } else if (last === '..') {\n                                    parts.splice(i, 1);\n                                    up++;\n                                } else if (up) {\n                                    parts.splice(i, 1);\n                                    up--;\n                                }\n                            }\n                            if (allowAboveRoot) {\n                                for (; up--; up) {\n                                    parts.unshift('..');\n                                }\n                            }\n                            return parts;\n                        }\n                        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                        var splitPath = function (filename) {\n                            return splitPathRe.exec(filename).slice(1);\n                        };\n                        exports.resolve = function () {\n                            var resolvedPath = '', resolvedAbsolute = false;\n                            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n                                var path = i >= 0 ? arguments[i] : process.cwd();\n                                if (typeof path !== 'string') {\n                                    throw new TypeError('Arguments to path.resolve must be strings');\n                                } else if (!path) {\n                                    continue;\n                                }\n                                resolvedPath = path + '/' + resolvedPath;\n                                resolvedAbsolute = path.charAt(0) === '/';\n                            }\n                            resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n                                return !!p;\n                            }), !resolvedAbsolute).join('/');\n                            return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n                        };\n                        exports.normalize = function (path) {\n                            var isAbsolute = exports.isAbsolute(path), trailingSlash = substr(path, -1) === '/';\n                            path = normalizeArray(filter(path.split('/'), function (p) {\n                                return !!p;\n                            }), !isAbsolute).join('/');\n                            if (!path && !isAbsolute) {\n                                path = '.';\n                            }\n                            if (path && trailingSlash) {\n                                path += '/';\n                            }\n                            return (isAbsolute ? '/' : '') + path;\n                        };\n                        exports.isAbsolute = function (path) {\n                            return path.charAt(0) === '/';\n                        };\n                        exports.join = function () {\n                            var paths = Array.prototype.slice.call(arguments, 0);\n                            return exports.normalize(filter(paths, function (p, index) {\n                                if (typeof p !== 'string') {\n                                    throw new TypeError('Arguments to path.join must be strings');\n                                }\n                                return p;\n                            }).join('/'));\n                        };\n                        exports.relative = function (from, to) {\n                            from = exports.resolve(from).substr(1);\n                            to = exports.resolve(to).substr(1);\n                            function trim(arr) {\n                                var start = 0;\n                                for (; start < arr.length; start++) {\n                                    if (arr[start] !== '')\n                                        break;\n                                }\n                                var end = arr.length - 1;\n                                for (; end >= 0; end--) {\n                                    if (arr[end] !== '')\n                                        break;\n                                }\n                                if (start > end)\n                                    return [];\n                                return arr.slice(start, end - start + 1);\n                            }\n                            var fromParts = trim(from.split('/'));\n                            var toParts = trim(to.split('/'));\n                            var length = Math.min(fromParts.length, toParts.length);\n                            var samePartsLength = length;\n                            for (var i = 0; i < length; i++) {\n                                if (fromParts[i] !== toParts[i]) {\n                                    samePartsLength = i;\n                                    break;\n                                }\n                            }\n                            var outputParts = [];\n                            for (var i = samePartsLength; i < fromParts.length; i++) {\n                                outputParts.push('..');\n                            }\n                            outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                            return outputParts.join('/');\n                        };\n                        exports.sep = '/';\n                        exports.delimiter = ':';\n                        exports.dirname = function (path) {\n                            var result = splitPath(path), root = result[0], dir = result[1];\n                            if (!root && !dir) {\n                                return '.';\n                            }\n                            if (dir) {\n                                dir = dir.substr(0, dir.length - 1);\n                            }\n                            return root + dir;\n                        };\n                        exports.basename = function (path, ext) {\n                            var f = splitPath(path)[2];\n                            if (ext && f.substr(-1 * ext.length) === ext) {\n                                f = f.substr(0, f.length - ext.length);\n                            }\n                            return f;\n                        };\n                        exports.extname = function (path) {\n                            return splitPath(path)[3];\n                        };\n                        function filter(xs, f) {\n                            if (xs.filter)\n                                return xs.filter(f);\n                            var res = [];\n                            for (var i = 0; i < xs.length; i++) {\n                                if (f(xs[i], i, xs))\n                                    res.push(xs[i]);\n                            }\n                            return res;\n                        }\n                        var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n                            return str.substr(start, len);\n                        } : function (str, start, len) {\n                            if (start < 0)\n                                start = str.length + start;\n                            return str.substr(start, len);\n                        };\n                    }.call(this, _dereq_('/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js')));\n                },\n                { '/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js': 29 }\n            ],\n            31: [\n                function (_dereq_, module, exports) {\n                    module.exports = function isBuffer(arg) {\n                        return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n                    };\n                },\n                {}\n            ],\n            32: [\n                function (_dereq_, module, exports) {\n                    (function (process, global) {\n                        var formatRegExp = /%[sdj%]/g;\n                        exports.format = function (f) {\n                            if (!isString(f)) {\n                                var objects = [];\n                                for (var i = 0; i < arguments.length; i++) {\n                                    objects.push(inspect(arguments[i]));\n                                }\n                                return objects.join(' ');\n                            }\n                            var i = 1;\n                            var args = arguments;\n                            var len = args.length;\n                            var str = String(f).replace(formatRegExp, function (x) {\n                                if (x === '%%')\n                                    return '%';\n                                if (i >= len)\n                                    return x;\n                                switch (x) {\n                                case '%s':\n                                    return String(args[i++]);\n                                case '%d':\n                                    return Number(args[i++]);\n                                case '%j':\n                                    try {\n                                        return JSON.stringify(args[i++]);\n                                    } catch (_) {\n                                        return '[Circular]';\n                                    }\n                                default:\n                                    return x;\n                                }\n                            });\n                            for (var x = args[i]; i < len; x = args[++i]) {\n                                if (isNull(x) || !isObject(x)) {\n                                    str += ' ' + x;\n                                } else {\n                                    str += ' ' + inspect(x);\n                                }\n                            }\n                            return str;\n                        };\n                        exports.deprecate = function (fn, msg) {\n                            if (isUndefined(global.process)) {\n                                return function () {\n                                    return exports.deprecate(fn, msg).apply(this, arguments);\n                                };\n                            }\n                            if (process.noDeprecation === true) {\n                                return fn;\n                            }\n                            var warned = false;\n                            function deprecated() {\n                                if (!warned) {\n                                    if (process.throwDeprecation) {\n                                        throw new Error(msg);\n                                    } else if (process.traceDeprecation) {\n                                        console.trace(msg);\n                                    } else {\n                                        console.error(msg);\n                                    }\n                                    warned = true;\n                                }\n                                return fn.apply(this, arguments);\n                            }\n                            return deprecated;\n                        };\n                        var debugs = {};\n                        var debugEnviron;\n                        exports.debuglog = function (set) {\n                            if (isUndefined(debugEnviron))\n                                debugEnviron = process.env.NODE_DEBUG || '';\n                            set = set.toUpperCase();\n                            if (!debugs[set]) {\n                                if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n                                    var pid = process.pid;\n                                    debugs[set] = function () {\n                                        var msg = exports.format.apply(exports, arguments);\n                                        console.error('%s %d: %s', set, pid, msg);\n                                    };\n                                } else {\n                                    debugs[set] = function () {\n                                    };\n                                }\n                            }\n                            return debugs[set];\n                        };\n                        function inspect(obj, opts) {\n                            var ctx = {\n                                seen: [],\n                                stylize: stylizeNoColor\n                            };\n                            if (arguments.length >= 3)\n                                ctx.depth = arguments[2];\n                            if (arguments.length >= 4)\n                                ctx.colors = arguments[3];\n                            if (isBoolean(opts)) {\n                                ctx.showHidden = opts;\n                            } else if (opts) {\n                                exports._extend(ctx, opts);\n                            }\n                            if (isUndefined(ctx.showHidden))\n                                ctx.showHidden = false;\n                            if (isUndefined(ctx.depth))\n                                ctx.depth = 2;\n                            if (isUndefined(ctx.colors))\n                                ctx.colors = false;\n                            if (isUndefined(ctx.customInspect))\n                                ctx.customInspect = true;\n                            if (ctx.colors)\n                                ctx.stylize = stylizeWithColor;\n                            return formatValue(ctx, obj, ctx.depth);\n                        }\n                        exports.inspect = inspect;\n                        inspect.colors = {\n                            'bold': [\n                                1,\n                                22\n                            ],\n                            'italic': [\n                                3,\n                                23\n                            ],\n                            'underline': [\n                                4,\n                                24\n                            ],\n                            'inverse': [\n                                7,\n                                27\n                            ],\n                            'white': [\n                                37,\n                                39\n                            ],\n                            'grey': [\n                                90,\n                                39\n                            ],\n                            'black': [\n                                30,\n                                39\n                            ],\n                            'blue': [\n                                34,\n                                39\n                            ],\n                            'cyan': [\n                                36,\n                                39\n                            ],\n                            'green': [\n                                32,\n                                39\n                            ],\n                            'magenta': [\n                                35,\n                                39\n                            ],\n                            'red': [\n                                31,\n                                39\n                            ],\n                            'yellow': [\n                                33,\n                                39\n                            ]\n                        };\n                        inspect.styles = {\n                            'special': 'cyan',\n                            'number': 'yellow',\n                            'boolean': 'yellow',\n                            'undefined': 'grey',\n                            'null': 'bold',\n                            'string': 'green',\n                            'date': 'magenta',\n                            'regexp': 'red'\n                        };\n                        function stylizeWithColor(str, styleType) {\n                            var style = inspect.styles[styleType];\n                            if (style) {\n                                return '\\x1B[' + inspect.colors[style][0] + 'm' + str + '\\x1B[' + inspect.colors[style][1] + 'm';\n                            } else {\n                                return str;\n                            }\n                        }\n                        function stylizeNoColor(str, styleType) {\n                            return str;\n                        }\n                        function arrayToHash(array) {\n                            var hash = {};\n                            array.forEach(function (val, idx) {\n                                hash[val] = true;\n                            });\n                            return hash;\n                        }\n                        function formatValue(ctx, value, recurseTimes) {\n                            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {\n                                var ret = value.inspect(recurseTimes, ctx);\n                                if (!isString(ret)) {\n                                    ret = formatValue(ctx, ret, recurseTimes);\n                                }\n                                return ret;\n                            }\n                            var primitive = formatPrimitive(ctx, value);\n                            if (primitive) {\n                                return primitive;\n                            }\n                            var keys = Object.keys(value);\n                            var visibleKeys = arrayToHash(keys);\n                            if (ctx.showHidden) {\n                                keys = Object.getOwnPropertyNames(value);\n                            }\n                            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n                                return formatError(value);\n                            }\n                            if (keys.length === 0) {\n                                if (isFunction(value)) {\n                                    var name = value.name ? ': ' + value.name : '';\n                                    return ctx.stylize('[Function' + name + ']', 'special');\n                                }\n                                if (isRegExp(value)) {\n                                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n                                }\n                                if (isDate(value)) {\n                                    return ctx.stylize(Date.prototype.toString.call(value), 'date');\n                                }\n                                if (isError(value)) {\n                                    return formatError(value);\n                                }\n                            }\n                            var base = '', array = false, braces = [\n                                    '{',\n                                    '}'\n                                ];\n                            if (isArray(value)) {\n                                array = true;\n                                braces = [\n                                    '[',\n                                    ']'\n                                ];\n                            }\n                            if (isFunction(value)) {\n                                var n = value.name ? ': ' + value.name : '';\n                                base = ' [Function' + n + ']';\n                            }\n                            if (isRegExp(value)) {\n                                base = ' ' + RegExp.prototype.toString.call(value);\n                            }\n                            if (isDate(value)) {\n                                base = ' ' + Date.prototype.toUTCString.call(value);\n                            }\n                            if (isError(value)) {\n                                base = ' ' + formatError(value);\n                            }\n                            if (keys.length === 0 && (!array || value.length == 0)) {\n                                return braces[0] + base + braces[1];\n                            }\n                            if (recurseTimes < 0) {\n                                if (isRegExp(value)) {\n                                    return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n                                } else {\n                                    return ctx.stylize('[Object]', 'special');\n                                }\n                            }\n                            ctx.seen.push(value);\n                            var output;\n                            if (array) {\n                                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n                            } else {\n                                output = keys.map(function (key) {\n                                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n                                });\n                            }\n                            ctx.seen.pop();\n                            return reduceToSingleString(output, base, braces);\n                        }\n                        function formatPrimitive(ctx, value) {\n                            if (isUndefined(value))\n                                return ctx.stylize('undefined', 'undefined');\n                            if (isString(value)) {\n                                var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n                                return ctx.stylize(simple, 'string');\n                            }\n                            if (isNumber(value))\n                                return ctx.stylize('' + value, 'number');\n                            if (isBoolean(value))\n                                return ctx.stylize('' + value, 'boolean');\n                            if (isNull(value))\n                                return ctx.stylize('null', 'null');\n                        }\n                        function formatError(value) {\n                            return '[' + Error.prototype.toString.call(value) + ']';\n                        }\n                        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n                            var output = [];\n                            for (var i = 0, l = value.length; i < l; ++i) {\n                                if (hasOwnProperty(value, String(i))) {\n                                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n                                } else {\n                                    output.push('');\n                                }\n                            }\n                            keys.forEach(function (key) {\n                                if (!key.match(/^\\d+$/)) {\n                                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n                                }\n                            });\n                            return output;\n                        }\n                        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n                            var name, str, desc;\n                            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n                            if (desc.get) {\n                                if (desc.set) {\n                                    str = ctx.stylize('[Getter/Setter]', 'special');\n                                } else {\n                                    str = ctx.stylize('[Getter]', 'special');\n                                }\n                            } else {\n                                if (desc.set) {\n                                    str = ctx.stylize('[Setter]', 'special');\n                                }\n                            }\n                            if (!hasOwnProperty(visibleKeys, key)) {\n                                name = '[' + key + ']';\n                            }\n                            if (!str) {\n                                if (ctx.seen.indexOf(desc.value) < 0) {\n                                    if (isNull(recurseTimes)) {\n                                        str = formatValue(ctx, desc.value, null);\n                                    } else {\n                                        str = formatValue(ctx, desc.value, recurseTimes - 1);\n                                    }\n                                    if (str.indexOf('\\n') > -1) {\n                                        if (array) {\n                                            str = str.split('\\n').map(function (line) {\n                                                return '  ' + line;\n                                            }).join('\\n').substr(2);\n                                        } else {\n                                            str = '\\n' + str.split('\\n').map(function (line) {\n                                                return '   ' + line;\n                                            }).join('\\n');\n                                        }\n                                    }\n                                } else {\n                                    str = ctx.stylize('[Circular]', 'special');\n                                }\n                            }\n                            if (isUndefined(name)) {\n                                if (array && key.match(/^\\d+$/)) {\n                                    return str;\n                                }\n                                name = JSON.stringify('' + key);\n                                if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n                                    name = name.substr(1, name.length - 2);\n                                    name = ctx.stylize(name, 'name');\n                                } else {\n                                    name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n                                    name = ctx.stylize(name, 'string');\n                                }\n                            }\n                            return name + ': ' + str;\n                        }\n                        function reduceToSingleString(output, base, braces) {\n                            var numLinesEst = 0;\n                            var length = output.reduce(function (prev, cur) {\n                                numLinesEst++;\n                                if (cur.indexOf('\\n') >= 0)\n                                    numLinesEst++;\n                                return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n                            }, 0);\n                            if (length > 60) {\n                                return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n                            }\n                            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n                        }\n                        function isArray(ar) {\n                            return Array.isArray(ar);\n                        }\n                        exports.isArray = isArray;\n                        function isBoolean(arg) {\n                            return typeof arg === 'boolean';\n                        }\n                        exports.isBoolean = isBoolean;\n                        function isNull(arg) {\n                            return arg === null;\n                        }\n                        exports.isNull = isNull;\n                        function isNullOrUndefined(arg) {\n                            return arg == null;\n                        }\n                        exports.isNullOrUndefined = isNullOrUndefined;\n                        function isNumber(arg) {\n                            return typeof arg === 'number';\n                        }\n                        exports.isNumber = isNumber;\n                        function isString(arg) {\n                            return typeof arg === 'string';\n                        }\n                        exports.isString = isString;\n                        function isSymbol(arg) {\n                            return typeof arg === 'symbol';\n                        }\n                        exports.isSymbol = isSymbol;\n                        function isUndefined(arg) {\n                            return arg === void 0;\n                        }\n                        exports.isUndefined = isUndefined;\n                        function isRegExp(re) {\n                            return isObject(re) && objectToString(re) === '[object RegExp]';\n                        }\n                        exports.isRegExp = isRegExp;\n                        function isObject(arg) {\n                            return typeof arg === 'object' && arg !== null;\n                        }\n                        exports.isObject = isObject;\n                        function isDate(d) {\n                            return isObject(d) && objectToString(d) === '[object Date]';\n                        }\n                        exports.isDate = isDate;\n                        function isError(e) {\n                            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n                        }\n                        exports.isError = isError;\n                        function isFunction(arg) {\n                            return typeof arg === 'function';\n                        }\n                        exports.isFunction = isFunction;\n                        function isPrimitive(arg) {\n                            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';\n                        }\n                        exports.isPrimitive = isPrimitive;\n                        exports.isBuffer = _dereq_('./support/isBuffer');\n                        function objectToString(o) {\n                            return Object.prototype.toString.call(o);\n                        }\n                        function pad(n) {\n                            return n < 10 ? '0' + n.toString(10) : n.toString(10);\n                        }\n                        var months = [\n                            'Jan',\n                            'Feb',\n                            'Mar',\n                            'Apr',\n                            'May',\n                            'Jun',\n                            'Jul',\n                            'Aug',\n                            'Sep',\n                            'Oct',\n                            'Nov',\n                            'Dec'\n                        ];\n                        function timestamp() {\n                            var d = new Date();\n                            var time = [\n                                pad(d.getHours()),\n                                pad(d.getMinutes()),\n                                pad(d.getSeconds())\n                            ].join(':');\n                            return [\n                                d.getDate(),\n                                months[d.getMonth()],\n                                time\n                            ].join(' ');\n                        }\n                        exports.log = function () {\n                            console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n                        };\n                        exports.inherits = _dereq_('inherits');\n                        exports._extend = function (origin, add) {\n                            if (!add || !isObject(add))\n                                return origin;\n                            var keys = Object.keys(add);\n                            var i = keys.length;\n                            while (i--) {\n                                origin[keys[i]] = add[keys[i]];\n                            }\n                            return origin;\n                        };\n                        function hasOwnProperty(obj, prop) {\n                            return Object.prototype.hasOwnProperty.call(obj, prop);\n                        }\n                    }.call(this, _dereq_('/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js'), typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));\n                },\n                {\n                    './support/isBuffer': 31,\n                    '/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js': 29,\n                    'inherits': 28\n                }\n            ],\n            33: [\n                function (_dereq_, module, exports) {\n                    exports = module.exports = parse;\n                    exports.parse = parse;\n                    function parse(src, state, options) {\n                        options = options || {};\n                        state = state || exports.defaultState();\n                        var start = options.start || 0;\n                        var end = options.end || src.length;\n                        var index = start;\n                        while (index < end) {\n                            if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0) {\n                                throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]);\n                            }\n                            exports.parseChar(src[index++], state);\n                        }\n                        return state;\n                    }\n                    exports.parseMax = parseMax;\n                    function parseMax(src, options) {\n                        options = options || {};\n                        var start = options.start || 0;\n                        var index = start;\n                        var state = exports.defaultState();\n                        while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0) {\n                            if (index >= src.length) {\n                                throw new Error('The end of the string was reached with no closing bracket found.');\n                            }\n                            exports.parseChar(src[index++], state);\n                        }\n                        var end = index - 1;\n                        return {\n                            start: start,\n                            end: end,\n                            src: src.substring(start, end)\n                        };\n                    }\n                    exports.parseUntil = parseUntil;\n                    function parseUntil(src, delimiter, options) {\n                        options = options || {};\n                        var includeLineComment = options.includeLineComment || false;\n                        var start = options.start || 0;\n                        var index = start;\n                        var state = exports.defaultState();\n                        while (state.isString() || state.regexp || state.blockComment || !includeLineComment && state.lineComment || !startsWith(src, delimiter, index)) {\n                            exports.parseChar(src[index++], state);\n                        }\n                        var end = index;\n                        return {\n                            start: start,\n                            end: end,\n                            src: src.substring(start, end)\n                        };\n                    }\n                    exports.parseChar = parseChar;\n                    function parseChar(character, state) {\n                        if (character.length !== 1)\n                            throw new Error('Character must be a string of length 1');\n                        state = state || exports.defaultState();\n                        var wasComment = state.blockComment || state.lineComment;\n                        var lastChar = state.history ? state.history[0] : '';\n                        if (state.lineComment) {\n                            if (character === '\\n') {\n                                state.lineComment = false;\n                            }\n                        } else if (state.blockComment) {\n                            if (state.lastChar === '*' && character === '/') {\n                                state.blockComment = false;\n                            }\n                        } else if (state.singleQuote) {\n                            if (character === \"'\" && !state.escaped) {\n                                state.singleQuote = false;\n                            } else if (character === '\\\\' && !state.escaped) {\n                                state.escaped = true;\n                            } else {\n                                state.escaped = false;\n                            }\n                        } else if (state.doubleQuote) {\n                            if (character === '\"' && !state.escaped) {\n                                state.doubleQuote = false;\n                            } else if (character === '\\\\' && !state.escaped) {\n                                state.escaped = true;\n                            } else {\n                                state.escaped = false;\n                            }\n                        } else if (state.regexp) {\n                            if (character === '/' && !state.escaped) {\n                                state.regexp = false;\n                            } else if (character === '\\\\' && !state.escaped) {\n                                state.escaped = true;\n                            } else {\n                                state.escaped = false;\n                            }\n                        } else if (lastChar === '/' && character === '/') {\n                            state.history = state.history.substr(1);\n                            state.lineComment = true;\n                        } else if (lastChar === '/' && character === '*') {\n                            state.history = state.history.substr(1);\n                            state.blockComment = true;\n                        } else if (character === '/' && isRegexp(state.history)) {\n                            state.regexp = true;\n                        } else if (character === \"'\") {\n                            state.singleQuote = true;\n                        } else if (character === '\"') {\n                            state.doubleQuote = true;\n                        } else if (character === '(') {\n                            state.roundDepth++;\n                        } else if (character === ')') {\n                            state.roundDepth--;\n                        } else if (character === '{') {\n                            state.curlyDepth++;\n                        } else if (character === '}') {\n                            state.curlyDepth--;\n                        } else if (character === '[') {\n                            state.squareDepth++;\n                        } else if (character === ']') {\n                            state.squareDepth--;\n                        }\n                        if (!state.blockComment && !state.lineComment && !wasComment)\n                            state.history = character + state.history;\n                        return state;\n                    }\n                    exports.defaultState = function () {\n                        return new State();\n                    };\n                    function State() {\n                        this.lineComment = false;\n                        this.blockComment = false;\n                        this.singleQuote = false;\n                        this.doubleQuote = false;\n                        this.regexp = false;\n                        this.escaped = false;\n                        this.roundDepth = 0;\n                        this.curlyDepth = 0;\n                        this.squareDepth = 0;\n                        this.history = '';\n                    }\n                    State.prototype.isString = function () {\n                        return this.singleQuote || this.doubleQuote;\n                    };\n                    State.prototype.isComment = function () {\n                        return this.lineComment || this.blockComment;\n                    };\n                    State.prototype.isNesting = function () {\n                        return this.isString() || this.isComment() || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0;\n                    };\n                    function startsWith(str, start, i) {\n                        return str.substr(i || 0, start.length) === start;\n                    }\n                    exports.isPunctuator = isPunctuator;\n                    function isPunctuator(c) {\n                        var code = c.charCodeAt(0);\n                        switch (code) {\n                        case 46:\n                        case 40:\n                        case 41:\n                        case 59:\n                        case 44:\n                        case 123:\n                        case 125:\n                        case 91:\n                        case 93:\n                        case 58:\n                        case 63:\n                        case 126:\n                        case 37:\n                        case 38:\n                        case 42:\n                        case 43:\n                        case 45:\n                        case 47:\n                        case 60:\n                        case 62:\n                        case 94:\n                        case 124:\n                        case 33:\n                        case 61:\n                            return true;\n                        default:\n                            return false;\n                        }\n                    }\n                    exports.isKeyword = isKeyword;\n                    function isKeyword(id) {\n                        return id === 'if' || id === 'in' || id === 'do' || id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let' || id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum' || id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super' || id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import' || id === 'default' || id === 'finally' || id === 'extends' || id === 'function' || id === 'continue' || id === 'debugger' || id === 'package' || id === 'private' || id === 'interface' || id === 'instanceof' || id === 'implements' || id === 'protected' || id === 'public' || id === 'static' || id === 'yield' || id === 'let';\n                    }\n                    function isRegexp(history) {\n                        history = history.replace(/^\\s*/, '');\n                        if (history[0] === ')')\n                            return false;\n                        if (history[0] === '}')\n                            return true;\n                        if (isPunctuator(history[0]))\n                            return true;\n                        if (/^\\w+\\b/.test(history) && isKeyword(/^\\w+\\b/.exec(history)[0].split('').reverse().join('')))\n                            return true;\n                        return false;\n                    }\n                },\n                {}\n            ],\n            34: [\n                function (_dereq_, module, exports) {\n                    var uglify = _dereq_('uglify-js');\n                    var lastSRC = '(null)';\n                    var lastRes = true;\n                    var lastConstants = undefined;\n                    module.exports = isConstant;\n                    function isConstant(src, constants) {\n                        src = '(' + src + ')';\n                        if (lastSRC === src && lastConstants === constants)\n                            return lastRes;\n                        lastSRC = src;\n                        try {\n                            return lastRes = detect(src).filter(function (key) {\n                                return !constants || !(key in constants);\n                            }).length === 0;\n                        } catch (ex) {\n                            return lastRes = false;\n                        }\n                    }\n                    isConstant.isConstant = isConstant;\n                    isConstant.toConstant = toConstant;\n                    function toConstant(src, constants) {\n                        if (!isConstant(src, constants))\n                            throw new Error(JSON.stringify(src) + ' is not constant.');\n                        return Function(Object.keys(constants || {}).join(','), 'return (' + src + ')').apply(null, Object.keys(constants || {}).map(function (key) {\n                            return constants[key];\n                        }));\n                    }\n                    function detect(src) {\n                        var ast = uglify.parse(src.toString());\n                        ast.figure_out_scope();\n                        var globals = ast.globals.map(function (node, name) {\n                            return name;\n                        });\n                        return globals;\n                    }\n                },\n                { 'uglify-js': 45 }\n            ],\n            35: [\n                function (_dereq_, module, exports) {\n                    exports.SourceMapGenerator = _dereq_('./source-map/source-map-generator').SourceMapGenerator;\n                    exports.SourceMapConsumer = _dereq_('./source-map/source-map-consumer').SourceMapConsumer;\n                    exports.SourceNode = _dereq_('./source-map/source-node').SourceNode;\n                },\n                {\n                    './source-map/source-map-consumer': 40,\n                    './source-map/source-map-generator': 41,\n                    './source-map/source-node': 42\n                }\n            ],\n            36: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var util = _dereq_('./util');\n                        function ArraySet() {\n                            this._array = [];\n                            this._set = {};\n                        }\n                        ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n                            var set = new ArraySet();\n                            for (var i = 0, len = aArray.length; i < len; i++) {\n                                set.add(aArray[i], aAllowDuplicates);\n                            }\n                            return set;\n                        };\n                        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n                            var isDuplicate = this.has(aStr);\n                            var idx = this._array.length;\n                            if (!isDuplicate || aAllowDuplicates) {\n                                this._array.push(aStr);\n                            }\n                            if (!isDuplicate) {\n                                this._set[util.toSetString(aStr)] = idx;\n                            }\n                        };\n                        ArraySet.prototype.has = function ArraySet_has(aStr) {\n                            return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));\n                        };\n                        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n                            if (this.has(aStr)) {\n                                return this._set[util.toSetString(aStr)];\n                            }\n                            throw new Error('\"' + aStr + '\" is not in the set.');\n                        };\n                        ArraySet.prototype.at = function ArraySet_at(aIdx) {\n                            if (aIdx >= 0 && aIdx < this._array.length) {\n                                return this._array[aIdx];\n                            }\n                            throw new Error('No element indexed by ' + aIdx);\n                        };\n                        ArraySet.prototype.toArray = function ArraySet_toArray() {\n                            return this._array.slice();\n                        };\n                        exports.ArraySet = ArraySet;\n                    });\n                },\n                {\n                    './util': 43,\n                    'amdefine': 44\n                }\n            ],\n            37: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var base64 = _dereq_('./base64');\n                        var VLQ_BASE_SHIFT = 5;\n                        var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n                        var VLQ_BASE_MASK = VLQ_BASE - 1;\n                        var VLQ_CONTINUATION_BIT = VLQ_BASE;\n                        function toVLQSigned(aValue) {\n                            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n                        }\n                        function fromVLQSigned(aValue) {\n                            var isNegative = (aValue & 1) === 1;\n                            var shifted = aValue >> 1;\n                            return isNegative ? -shifted : shifted;\n                        }\n                        exports.encode = function base64VLQ_encode(aValue) {\n                            var encoded = '';\n                            var digit;\n                            var vlq = toVLQSigned(aValue);\n                            do {\n                                digit = vlq & VLQ_BASE_MASK;\n                                vlq >>>= VLQ_BASE_SHIFT;\n                                if (vlq > 0) {\n                                    digit |= VLQ_CONTINUATION_BIT;\n                                }\n                                encoded += base64.encode(digit);\n                            } while (vlq > 0);\n                            return encoded;\n                        };\n                        exports.decode = function base64VLQ_decode(aStr) {\n                            var i = 0;\n                            var strLen = aStr.length;\n                            var result = 0;\n                            var shift = 0;\n                            var continuation, digit;\n                            do {\n                                if (i >= strLen) {\n                                    throw new Error('Expected more digits in base 64 VLQ value.');\n                                }\n                                digit = base64.decode(aStr.charAt(i++));\n                                continuation = !!(digit & VLQ_CONTINUATION_BIT);\n                                digit &= VLQ_BASE_MASK;\n                                result = result + (digit << shift);\n                                shift += VLQ_BASE_SHIFT;\n                            } while (continuation);\n                            return {\n                                value: fromVLQSigned(result),\n                                rest: aStr.slice(i)\n                            };\n                        };\n                    });\n                },\n                {\n                    './base64': 38,\n                    'amdefine': 44\n                }\n            ],\n            38: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var charToIntMap = {};\n                        var intToCharMap = {};\n                        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function (ch, index) {\n                            charToIntMap[ch] = index;\n                            intToCharMap[index] = ch;\n                        });\n                        exports.encode = function base64_encode(aNumber) {\n                            if (aNumber in intToCharMap) {\n                                return intToCharMap[aNumber];\n                            }\n                            throw new TypeError('Must be between 0 and 63: ' + aNumber);\n                        };\n                        exports.decode = function base64_decode(aChar) {\n                            if (aChar in charToIntMap) {\n                                return charToIntMap[aChar];\n                            }\n                            throw new TypeError('Not a valid base 64 digit: ' + aChar);\n                        };\n                    });\n                },\n                { 'amdefine': 44 }\n            ],\n            39: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n                            var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n                            var cmp = aCompare(aNeedle, aHaystack[mid], true);\n                            if (cmp === 0) {\n                                return aHaystack[mid];\n                            } else if (cmp > 0) {\n                                if (aHigh - mid > 1) {\n                                    return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n                                }\n                                return aHaystack[mid];\n                            } else {\n                                if (mid - aLow > 1) {\n                                    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n                                }\n                                return aLow < 0 ? null : aHaystack[aLow];\n                            }\n                        }\n                        exports.search = function search(aNeedle, aHaystack, aCompare) {\n                            return aHaystack.length > 0 ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare) : null;\n                        };\n                    });\n                },\n                { 'amdefine': 44 }\n            ],\n            40: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var util = _dereq_('./util');\n                        var binarySearch = _dereq_('./binary-search');\n                        var ArraySet = _dereq_('./array-set').ArraySet;\n                        var base64VLQ = _dereq_('./base64-vlq');\n                        function SourceMapConsumer(aSourceMap) {\n                            var sourceMap = aSourceMap;\n                            if (typeof aSourceMap === 'string') {\n                                sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            var version = util.getArg(sourceMap, 'version');\n                            var sources = util.getArg(sourceMap, 'sources');\n                            var names = util.getArg(sourceMap, 'names', []);\n                            var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n                            var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n                            var mappings = util.getArg(sourceMap, 'mappings');\n                            var file = util.getArg(sourceMap, 'file', null);\n                            if (version != this._version) {\n                                throw new Error('Unsupported version: ' + version);\n                            }\n                            this._names = ArraySet.fromArray(names, true);\n                            this._sources = ArraySet.fromArray(sources, true);\n                            this.sourceRoot = sourceRoot;\n                            this.sourcesContent = sourcesContent;\n                            this._mappings = mappings;\n                            this.file = file;\n                        }\n                        SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n                            var smc = Object.create(SourceMapConsumer.prototype);\n                            smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n                            smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n                            smc.sourceRoot = aSourceMap._sourceRoot;\n                            smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n                            smc.file = aSourceMap._file;\n                            smc.__generatedMappings = aSourceMap._mappings.slice().sort(util.compareByGeneratedPositions);\n                            smc.__originalMappings = aSourceMap._mappings.slice().sort(util.compareByOriginalPositions);\n                            return smc;\n                        };\n                        SourceMapConsumer.prototype._version = 3;\n                        Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n                            get: function () {\n                                return this._sources.toArray().map(function (s) {\n                                    return this.sourceRoot ? util.join(this.sourceRoot, s) : s;\n                                }, this);\n                            }\n                        });\n                        SourceMapConsumer.prototype.__generatedMappings = null;\n                        Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n                            get: function () {\n                                if (!this.__generatedMappings) {\n                                    this.__generatedMappings = [];\n                                    this.__originalMappings = [];\n                                    this._parseMappings(this._mappings, this.sourceRoot);\n                                }\n                                return this.__generatedMappings;\n                            }\n                        });\n                        SourceMapConsumer.prototype.__originalMappings = null;\n                        Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n                            get: function () {\n                                if (!this.__originalMappings) {\n                                    this.__generatedMappings = [];\n                                    this.__originalMappings = [];\n                                    this._parseMappings(this._mappings, this.sourceRoot);\n                                }\n                                return this.__originalMappings;\n                            }\n                        });\n                        SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n                            var generatedLine = 1;\n                            var previousGeneratedColumn = 0;\n                            var previousOriginalLine = 0;\n                            var previousOriginalColumn = 0;\n                            var previousSource = 0;\n                            var previousName = 0;\n                            var mappingSeparator = /^[,;]/;\n                            var str = aStr;\n                            var mapping;\n                            var temp;\n                            while (str.length > 0) {\n                                if (str.charAt(0) === ';') {\n                                    generatedLine++;\n                                    str = str.slice(1);\n                                    previousGeneratedColumn = 0;\n                                } else if (str.charAt(0) === ',') {\n                                    str = str.slice(1);\n                                } else {\n                                    mapping = {};\n                                    mapping.generatedLine = generatedLine;\n                                    temp = base64VLQ.decode(str);\n                                    mapping.generatedColumn = previousGeneratedColumn + temp.value;\n                                    previousGeneratedColumn = mapping.generatedColumn;\n                                    str = temp.rest;\n                                    if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n                                        temp = base64VLQ.decode(str);\n                                        mapping.source = this._sources.at(previousSource + temp.value);\n                                        previousSource += temp.value;\n                                        str = temp.rest;\n                                        if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n                                            throw new Error('Found a source, but no line and column');\n                                        }\n                                        temp = base64VLQ.decode(str);\n                                        mapping.originalLine = previousOriginalLine + temp.value;\n                                        previousOriginalLine = mapping.originalLine;\n                                        mapping.originalLine += 1;\n                                        str = temp.rest;\n                                        if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {\n                                            throw new Error('Found a source and line, but no column');\n                                        }\n                                        temp = base64VLQ.decode(str);\n                                        mapping.originalColumn = previousOriginalColumn + temp.value;\n                                        previousOriginalColumn = mapping.originalColumn;\n                                        str = temp.rest;\n                                        if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {\n                                            temp = base64VLQ.decode(str);\n                                            mapping.name = this._names.at(previousName + temp.value);\n                                            previousName += temp.value;\n                                            str = temp.rest;\n                                        }\n                                    }\n                                    this.__generatedMappings.push(mapping);\n                                    if (typeof mapping.originalLine === 'number') {\n                                        this.__originalMappings.push(mapping);\n                                    }\n                                }\n                            }\n                            this.__generatedMappings.sort(util.compareByGeneratedPositions);\n                            this.__originalMappings.sort(util.compareByOriginalPositions);\n                        };\n                        SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {\n                            if (aNeedle[aLineName] <= 0) {\n                                throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n                            }\n                            if (aNeedle[aColumnName] < 0) {\n                                throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n                            }\n                            return binarySearch.search(aNeedle, aMappings, aComparator);\n                        };\n                        SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n                            var needle = {\n                                generatedLine: util.getArg(aArgs, 'line'),\n                                generatedColumn: util.getArg(aArgs, 'column')\n                            };\n                            var mapping = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositions);\n                            if (mapping && mapping.generatedLine === needle.generatedLine) {\n                                var source = util.getArg(mapping, 'source', null);\n                                if (source && this.sourceRoot) {\n                                    source = util.join(this.sourceRoot, source);\n                                }\n                                return {\n                                    source: source,\n                                    line: util.getArg(mapping, 'originalLine', null),\n                                    column: util.getArg(mapping, 'originalColumn', null),\n                                    name: util.getArg(mapping, 'name', null)\n                                };\n                            }\n                            return {\n                                source: null,\n                                line: null,\n                                column: null,\n                                name: null\n                            };\n                        };\n                        SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {\n                            if (!this.sourcesContent) {\n                                return null;\n                            }\n                            if (this.sourceRoot) {\n                                aSource = util.relative(this.sourceRoot, aSource);\n                            }\n                            if (this._sources.has(aSource)) {\n                                return this.sourcesContent[this._sources.indexOf(aSource)];\n                            }\n                            var url;\n                            if (this.sourceRoot && (url = util.urlParse(this.sourceRoot))) {\n                                var fileUriAbsPath = aSource.replace(/^file:\\/\\//, '');\n                                if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {\n                                    return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n                                }\n                                if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {\n                                    return this.sourcesContent[this._sources.indexOf('/' + aSource)];\n                                }\n                            }\n                            throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n                        };\n                        SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n                            var needle = {\n                                source: util.getArg(aArgs, 'source'),\n                                originalLine: util.getArg(aArgs, 'line'),\n                                originalColumn: util.getArg(aArgs, 'column')\n                            };\n                            if (this.sourceRoot) {\n                                needle.source = util.relative(this.sourceRoot, needle.source);\n                            }\n                            var mapping = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);\n                            if (mapping) {\n                                return {\n                                    line: util.getArg(mapping, 'generatedLine', null),\n                                    column: util.getArg(mapping, 'generatedColumn', null)\n                                };\n                            }\n                            return {\n                                line: null,\n                                column: null\n                            };\n                        };\n                        SourceMapConsumer.GENERATED_ORDER = 1;\n                        SourceMapConsumer.ORIGINAL_ORDER = 2;\n                        SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n                            var context = aContext || null;\n                            var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n                            var mappings;\n                            switch (order) {\n                            case SourceMapConsumer.GENERATED_ORDER:\n                                mappings = this._generatedMappings;\n                                break;\n                            case SourceMapConsumer.ORIGINAL_ORDER:\n                                mappings = this._originalMappings;\n                                break;\n                            default:\n                                throw new Error('Unknown order of iteration.');\n                            }\n                            var sourceRoot = this.sourceRoot;\n                            mappings.map(function (mapping) {\n                                var source = mapping.source;\n                                if (source && sourceRoot) {\n                                    source = util.join(sourceRoot, source);\n                                }\n                                return {\n                                    source: source,\n                                    generatedLine: mapping.generatedLine,\n                                    generatedColumn: mapping.generatedColumn,\n                                    originalLine: mapping.originalLine,\n                                    originalColumn: mapping.originalColumn,\n                                    name: mapping.name\n                                };\n                            }).forEach(aCallback, context);\n                        };\n                        exports.SourceMapConsumer = SourceMapConsumer;\n                    });\n                },\n                {\n                    './array-set': 36,\n                    './base64-vlq': 37,\n                    './binary-search': 39,\n                    './util': 43,\n                    'amdefine': 44\n                }\n            ],\n            41: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var base64VLQ = _dereq_('./base64-vlq');\n                        var util = _dereq_('./util');\n                        var ArraySet = _dereq_('./array-set').ArraySet;\n                        function SourceMapGenerator(aArgs) {\n                            if (!aArgs) {\n                                aArgs = {};\n                            }\n                            this._file = util.getArg(aArgs, 'file', null);\n                            this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n                            this._sources = new ArraySet();\n                            this._names = new ArraySet();\n                            this._mappings = [];\n                            this._sourcesContents = null;\n                        }\n                        SourceMapGenerator.prototype._version = 3;\n                        SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n                            var sourceRoot = aSourceMapConsumer.sourceRoot;\n                            var generator = new SourceMapGenerator({\n                                file: aSourceMapConsumer.file,\n                                sourceRoot: sourceRoot\n                            });\n                            aSourceMapConsumer.eachMapping(function (mapping) {\n                                var newMapping = {\n                                    generated: {\n                                        line: mapping.generatedLine,\n                                        column: mapping.generatedColumn\n                                    }\n                                };\n                                if (mapping.source) {\n                                    newMapping.source = mapping.source;\n                                    if (sourceRoot) {\n                                        newMapping.source = util.relative(sourceRoot, newMapping.source);\n                                    }\n                                    newMapping.original = {\n                                        line: mapping.originalLine,\n                                        column: mapping.originalColumn\n                                    };\n                                    if (mapping.name) {\n                                        newMapping.name = mapping.name;\n                                    }\n                                }\n                                generator.addMapping(newMapping);\n                            });\n                            aSourceMapConsumer.sources.forEach(function (sourceFile) {\n                                var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n                                if (content) {\n                                    generator.setSourceContent(sourceFile, content);\n                                }\n                            });\n                            return generator;\n                        };\n                        SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n                            var generated = util.getArg(aArgs, 'generated');\n                            var original = util.getArg(aArgs, 'original', null);\n                            var source = util.getArg(aArgs, 'source', null);\n                            var name = util.getArg(aArgs, 'name', null);\n                            this._validateMapping(generated, original, source, name);\n                            if (source && !this._sources.has(source)) {\n                                this._sources.add(source);\n                            }\n                            if (name && !this._names.has(name)) {\n                                this._names.add(name);\n                            }\n                            this._mappings.push({\n                                generatedLine: generated.line,\n                                generatedColumn: generated.column,\n                                originalLine: original != null && original.line,\n                                originalColumn: original != null && original.column,\n                                source: source,\n                                name: name\n                            });\n                        };\n                        SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n                            var source = aSourceFile;\n                            if (this._sourceRoot) {\n                                source = util.relative(this._sourceRoot, source);\n                            }\n                            if (aSourceContent !== null) {\n                                if (!this._sourcesContents) {\n                                    this._sourcesContents = {};\n                                }\n                                this._sourcesContents[util.toSetString(source)] = aSourceContent;\n                            } else {\n                                delete this._sourcesContents[util.toSetString(source)];\n                                if (Object.keys(this._sourcesContents).length === 0) {\n                                    this._sourcesContents = null;\n                                }\n                            }\n                        };\n                        SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n                            if (!aSourceFile) {\n                                if (!aSourceMapConsumer.file) {\n                                    throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n                                }\n                                aSourceFile = aSourceMapConsumer.file;\n                            }\n                            var sourceRoot = this._sourceRoot;\n                            if (sourceRoot) {\n                                aSourceFile = util.relative(sourceRoot, aSourceFile);\n                            }\n                            var newSources = new ArraySet();\n                            var newNames = new ArraySet();\n                            this._mappings.forEach(function (mapping) {\n                                if (mapping.source === aSourceFile && mapping.originalLine) {\n                                    var original = aSourceMapConsumer.originalPositionFor({\n                                        line: mapping.originalLine,\n                                        column: mapping.originalColumn\n                                    });\n                                    if (original.source !== null) {\n                                        mapping.source = original.source;\n                                        if (aSourceMapPath) {\n                                            mapping.source = util.join(aSourceMapPath, mapping.source);\n                                        }\n                                        if (sourceRoot) {\n                                            mapping.source = util.relative(sourceRoot, mapping.source);\n                                        }\n                                        mapping.originalLine = original.line;\n                                        mapping.originalColumn = original.column;\n                                        if (original.name !== null && mapping.name !== null) {\n                                            mapping.name = original.name;\n                                        }\n                                    }\n                                }\n                                var source = mapping.source;\n                                if (source && !newSources.has(source)) {\n                                    newSources.add(source);\n                                }\n                                var name = mapping.name;\n                                if (name && !newNames.has(name)) {\n                                    newNames.add(name);\n                                }\n                            }, this);\n                            this._sources = newSources;\n                            this._names = newNames;\n                            aSourceMapConsumer.sources.forEach(function (sourceFile) {\n                                var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n                                if (content) {\n                                    if (sourceRoot) {\n                                        sourceFile = util.relative(sourceRoot, sourceFile);\n                                    }\n                                    this.setSourceContent(sourceFile, content);\n                                }\n                            }, this);\n                        };\n                        SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n                            if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n                                return;\n                            } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n                                return;\n                            } else {\n                                throw new Error('Invalid mapping: ' + JSON.stringify({\n                                    generated: aGenerated,\n                                    source: aSource,\n                                    original: aOriginal,\n                                    name: aName\n                                }));\n                            }\n                        };\n                        SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n                            var previousGeneratedColumn = 0;\n                            var previousGeneratedLine = 1;\n                            var previousOriginalColumn = 0;\n                            var previousOriginalLine = 0;\n                            var previousName = 0;\n                            var previousSource = 0;\n                            var result = '';\n                            var mapping;\n                            this._mappings.sort(util.compareByGeneratedPositions);\n                            for (var i = 0, len = this._mappings.length; i < len; i++) {\n                                mapping = this._mappings[i];\n                                if (mapping.generatedLine !== previousGeneratedLine) {\n                                    previousGeneratedColumn = 0;\n                                    while (mapping.generatedLine !== previousGeneratedLine) {\n                                        result += ';';\n                                        previousGeneratedLine++;\n                                    }\n                                } else {\n                                    if (i > 0) {\n                                        if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {\n                                            continue;\n                                        }\n                                        result += ',';\n                                    }\n                                }\n                                result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n                                previousGeneratedColumn = mapping.generatedColumn;\n                                if (mapping.source) {\n                                    result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);\n                                    previousSource = this._sources.indexOf(mapping.source);\n                                    result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n                                    previousOriginalLine = mapping.originalLine - 1;\n                                    result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n                                    previousOriginalColumn = mapping.originalColumn;\n                                    if (mapping.name) {\n                                        result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);\n                                        previousName = this._names.indexOf(mapping.name);\n                                    }\n                                }\n                            }\n                            return result;\n                        };\n                        SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n                            return aSources.map(function (source) {\n                                if (!this._sourcesContents) {\n                                    return null;\n                                }\n                                if (aSourceRoot) {\n                                    source = util.relative(aSourceRoot, source);\n                                }\n                                var key = util.toSetString(source);\n                                return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n                            }, this);\n                        };\n                        SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n                            var map = {\n                                version: this._version,\n                                file: this._file,\n                                sources: this._sources.toArray(),\n                                names: this._names.toArray(),\n                                mappings: this._serializeMappings()\n                            };\n                            if (this._sourceRoot) {\n                                map.sourceRoot = this._sourceRoot;\n                            }\n                            if (this._sourcesContents) {\n                                map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n                            }\n                            return map;\n                        };\n                        SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n                            return JSON.stringify(this);\n                        };\n                        exports.SourceMapGenerator = SourceMapGenerator;\n                    });\n                },\n                {\n                    './array-set': 36,\n                    './base64-vlq': 37,\n                    './util': 43,\n                    'amdefine': 44\n                }\n            ],\n            42: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        var SourceMapGenerator = _dereq_('./source-map-generator').SourceMapGenerator;\n                        var util = _dereq_('./util');\n                        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n                            this.children = [];\n                            this.sourceContents = {};\n                            this.line = aLine === undefined ? null : aLine;\n                            this.column = aColumn === undefined ? null : aColumn;\n                            this.source = aSource === undefined ? null : aSource;\n                            this.name = aName === undefined ? null : aName;\n                            if (aChunks != null)\n                                this.add(aChunks);\n                        }\n                        SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {\n                            var node = new SourceNode();\n                            var remainingLines = aGeneratedCode.split('\\n');\n                            var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n                            var lastMapping = null;\n                            aSourceMapConsumer.eachMapping(function (mapping) {\n                                if (lastMapping !== null) {\n                                    if (lastGeneratedLine < mapping.generatedLine) {\n                                        var code = '';\n                                        addMappingWithCode(lastMapping, remainingLines.shift() + '\\n');\n                                        lastGeneratedLine++;\n                                        lastGeneratedColumn = 0;\n                                    } else {\n                                        var nextLine = remainingLines[0];\n                                        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n                                        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n                                        lastGeneratedColumn = mapping.generatedColumn;\n                                        addMappingWithCode(lastMapping, code);\n                                        lastMapping = mapping;\n                                        return;\n                                    }\n                                }\n                                while (lastGeneratedLine < mapping.generatedLine) {\n                                    node.add(remainingLines.shift() + '\\n');\n                                    lastGeneratedLine++;\n                                }\n                                if (lastGeneratedColumn < mapping.generatedColumn) {\n                                    var nextLine = remainingLines[0];\n                                    node.add(nextLine.substr(0, mapping.generatedColumn));\n                                    remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n                                    lastGeneratedColumn = mapping.generatedColumn;\n                                }\n                                lastMapping = mapping;\n                            }, this);\n                            if (remainingLines.length > 0) {\n                                if (lastMapping) {\n                                    var lastLine = remainingLines.shift();\n                                    if (remainingLines.length > 0)\n                                        lastLine += '\\n';\n                                    addMappingWithCode(lastMapping, lastLine);\n                                }\n                                node.add(remainingLines.join('\\n'));\n                            }\n                            aSourceMapConsumer.sources.forEach(function (sourceFile) {\n                                var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n                                if (content) {\n                                    node.setSourceContent(sourceFile, content);\n                                }\n                            });\n                            return node;\n                            function addMappingWithCode(mapping, code) {\n                                if (mapping === null || mapping.source === undefined) {\n                                    node.add(code);\n                                } else {\n                                    node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, mapping.source, code, mapping.name));\n                                }\n                            }\n                        };\n                        SourceNode.prototype.add = function SourceNode_add(aChunk) {\n                            if (Array.isArray(aChunk)) {\n                                aChunk.forEach(function (chunk) {\n                                    this.add(chunk);\n                                }, this);\n                            } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {\n                                if (aChunk) {\n                                    this.children.push(aChunk);\n                                }\n                            } else {\n                                throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n                            }\n                            return this;\n                        };\n                        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n                            if (Array.isArray(aChunk)) {\n                                for (var i = aChunk.length - 1; i >= 0; i--) {\n                                    this.prepend(aChunk[i]);\n                                }\n                            } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {\n                                this.children.unshift(aChunk);\n                            } else {\n                                throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);\n                            }\n                            return this;\n                        };\n                        SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n                            var chunk;\n                            for (var i = 0, len = this.children.length; i < len; i++) {\n                                chunk = this.children[i];\n                                if (chunk instanceof SourceNode) {\n                                    chunk.walk(aFn);\n                                } else {\n                                    if (chunk !== '') {\n                                        aFn(chunk, {\n                                            source: this.source,\n                                            line: this.line,\n                                            column: this.column,\n                                            name: this.name\n                                        });\n                                    }\n                                }\n                            }\n                        };\n                        SourceNode.prototype.join = function SourceNode_join(aSep) {\n                            var newChildren;\n                            var i;\n                            var len = this.children.length;\n                            if (len > 0) {\n                                newChildren = [];\n                                for (i = 0; i < len - 1; i++) {\n                                    newChildren.push(this.children[i]);\n                                    newChildren.push(aSep);\n                                }\n                                newChildren.push(this.children[i]);\n                                this.children = newChildren;\n                            }\n                            return this;\n                        };\n                        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n                            var lastChild = this.children[this.children.length - 1];\n                            if (lastChild instanceof SourceNode) {\n                                lastChild.replaceRight(aPattern, aReplacement);\n                            } else if (typeof lastChild === 'string') {\n                                this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n                            } else {\n                                this.children.push(''.replace(aPattern, aReplacement));\n                            }\n                            return this;\n                        };\n                        SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n                            this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n                        };\n                        SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n                            for (var i = 0, len = this.children.length; i < len; i++) {\n                                if (this.children[i] instanceof SourceNode) {\n                                    this.children[i].walkSourceContents(aFn);\n                                }\n                            }\n                            var sources = Object.keys(this.sourceContents);\n                            for (var i = 0, len = sources.length; i < len; i++) {\n                                aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n                            }\n                        };\n                        SourceNode.prototype.toString = function SourceNode_toString() {\n                            var str = '';\n                            this.walk(function (chunk) {\n                                str += chunk;\n                            });\n                            return str;\n                        };\n                        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n                            var generated = {\n                                code: '',\n                                line: 1,\n                                column: 0\n                            };\n                            var map = new SourceMapGenerator(aArgs);\n                            var sourceMappingActive = false;\n                            var lastOriginalSource = null;\n                            var lastOriginalLine = null;\n                            var lastOriginalColumn = null;\n                            var lastOriginalName = null;\n                            this.walk(function (chunk, original) {\n                                generated.code += chunk;\n                                if (original.source !== null && original.line !== null && original.column !== null) {\n                                    if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n                                        map.addMapping({\n                                            source: original.source,\n                                            original: {\n                                                line: original.line,\n                                                column: original.column\n                                            },\n                                            generated: {\n                                                line: generated.line,\n                                                column: generated.column\n                                            },\n                                            name: original.name\n                                        });\n                                    }\n                                    lastOriginalSource = original.source;\n                                    lastOriginalLine = original.line;\n                                    lastOriginalColumn = original.column;\n                                    lastOriginalName = original.name;\n                                    sourceMappingActive = true;\n                                } else if (sourceMappingActive) {\n                                    map.addMapping({\n                                        generated: {\n                                            line: generated.line,\n                                            column: generated.column\n                                        }\n                                    });\n                                    lastOriginalSource = null;\n                                    sourceMappingActive = false;\n                                }\n                                chunk.split('').forEach(function (ch, idx, array) {\n                                    if (ch === '\\n') {\n                                        generated.line++;\n                                        generated.column = 0;\n                                        if (idx + 1 === array.length) {\n                                            lastOriginalSource = null;\n                                            sourceMappingActive = false;\n                                        } else if (sourceMappingActive) {\n                                            map.addMapping({\n                                                source: original.source,\n                                                original: {\n                                                    line: original.line,\n                                                    column: original.column\n                                                },\n                                                generated: {\n                                                    line: generated.line,\n                                                    column: generated.column\n                                                },\n                                                name: original.name\n                                            });\n                                        }\n                                    } else {\n                                        generated.column++;\n                                    }\n                                });\n                            });\n                            this.walkSourceContents(function (sourceFile, sourceContent) {\n                                map.setSourceContent(sourceFile, sourceContent);\n                            });\n                            return {\n                                code: generated.code,\n                                map: map\n                            };\n                        };\n                        exports.SourceNode = SourceNode;\n                    });\n                },\n                {\n                    './source-map-generator': 41,\n                    './util': 43,\n                    'amdefine': 44\n                }\n            ],\n            43: [\n                function (_dereq_, module, exports) {\n                    \n                    define(function (_dereq_, exports, module) {\n                        function getArg(aArgs, aName, aDefaultValue) {\n                            if (aName in aArgs) {\n                                return aArgs[aName];\n                            } else if (arguments.length === 3) {\n                                return aDefaultValue;\n                            } else {\n                                throw new Error('\"' + aName + '\" is a required argument.');\n                            }\n                        }\n                        exports.getArg = getArg;\n                        var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n                        var dataUrlRegexp = /^data:.+\\,.+$/;\n                        function urlParse(aUrl) {\n                            var match = aUrl.match(urlRegexp);\n                            if (!match) {\n                                return null;\n                            }\n                            return {\n                                scheme: match[1],\n                                auth: match[2],\n                                host: match[3],\n                                port: match[4],\n                                path: match[5]\n                            };\n                        }\n                        exports.urlParse = urlParse;\n                        function urlGenerate(aParsedUrl) {\n                            var url = '';\n                            if (aParsedUrl.scheme) {\n                                url += aParsedUrl.scheme + ':';\n                            }\n                            url += '//';\n                            if (aParsedUrl.auth) {\n                                url += aParsedUrl.auth + '@';\n                            }\n                            if (aParsedUrl.host) {\n                                url += aParsedUrl.host;\n                            }\n                            if (aParsedUrl.port) {\n                                url += ':' + aParsedUrl.port;\n                            }\n                            if (aParsedUrl.path) {\n                                url += aParsedUrl.path;\n                            }\n                            return url;\n                        }\n                        exports.urlGenerate = urlGenerate;\n                        function normalize(aPath) {\n                            var path = aPath;\n                            var url = urlParse(aPath);\n                            if (url) {\n                                if (!url.path) {\n                                    return aPath;\n                                }\n                                path = url.path;\n                            }\n                            var isAbsolute = path.charAt(0) === '/';\n                            var parts = path.split(/\\/+/);\n                            for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n                                part = parts[i];\n                                if (part === '.') {\n                                    parts.splice(i, 1);\n                                } else if (part === '..') {\n                                    up++;\n                                } else if (up > 0) {\n                                    if (part === '') {\n                                        parts.splice(i + 1, up);\n                                        up = 0;\n                                    } else {\n                                        parts.splice(i, 2);\n                                        up--;\n                                    }\n                                }\n                            }\n                            path = parts.join('/');\n                            if (path === '') {\n                                path = isAbsolute ? '/' : '.';\n                            }\n                            if (url) {\n                                url.path = path;\n                                return urlGenerate(url);\n                            }\n                            return path;\n                        }\n                        exports.normalize = normalize;\n                        function join(aRoot, aPath) {\n                            var aPathUrl = urlParse(aPath);\n                            var aRootUrl = urlParse(aRoot);\n                            if (aRootUrl) {\n                                aRoot = aRootUrl.path || '/';\n                            }\n                            if (aPathUrl && !aPathUrl.scheme) {\n                                if (aRootUrl) {\n                                    aPathUrl.scheme = aRootUrl.scheme;\n                                }\n                                return urlGenerate(aPathUrl);\n                            }\n                            if (aPathUrl || aPath.match(dataUrlRegexp)) {\n                                return aPath;\n                            }\n                            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n                                aRootUrl.host = aPath;\n                                return urlGenerate(aRootUrl);\n                            }\n                            var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n                            if (aRootUrl) {\n                                aRootUrl.path = joined;\n                                return urlGenerate(aRootUrl);\n                            }\n                            return joined;\n                        }\n                        exports.join = join;\n                        function toSetString(aStr) {\n                            return '$' + aStr;\n                        }\n                        exports.toSetString = toSetString;\n                        function fromSetString(aStr) {\n                            return aStr.substr(1);\n                        }\n                        exports.fromSetString = fromSetString;\n                        function relative(aRoot, aPath) {\n                            aRoot = aRoot.replace(/\\/$/, '');\n                            var url = urlParse(aRoot);\n                            if (aPath.charAt(0) == '/' && url && url.path == '/') {\n                                return aPath.slice(1);\n                            }\n                            return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n                        }\n                        exports.relative = relative;\n                        function strcmp(aStr1, aStr2) {\n                            var s1 = aStr1 || '';\n                            var s2 = aStr2 || '';\n                            return (s1 > s2) - (s1 < s2);\n                        }\n                        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n                            var cmp;\n                            cmp = strcmp(mappingA.source, mappingB.source);\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.originalLine - mappingB.originalLine;\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.originalColumn - mappingB.originalColumn;\n                            if (cmp || onlyCompareOriginal) {\n                                return cmp;\n                            }\n                            cmp = strcmp(mappingA.name, mappingB.name);\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.generatedLine - mappingB.generatedLine;\n                            if (cmp) {\n                                return cmp;\n                            }\n                            return mappingA.generatedColumn - mappingB.generatedColumn;\n                        }\n                        ;\n                        exports.compareByOriginalPositions = compareByOriginalPositions;\n                        function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n                            var cmp;\n                            cmp = mappingA.generatedLine - mappingB.generatedLine;\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n                            if (cmp || onlyCompareGenerated) {\n                                return cmp;\n                            }\n                            cmp = strcmp(mappingA.source, mappingB.source);\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.originalLine - mappingB.originalLine;\n                            if (cmp) {\n                                return cmp;\n                            }\n                            cmp = mappingA.originalColumn - mappingB.originalColumn;\n                            if (cmp) {\n                                return cmp;\n                            }\n                            return strcmp(mappingA.name, mappingB.name);\n                        }\n                        ;\n                        exports.compareByGeneratedPositions = compareByGeneratedPositions;\n                    });\n                },\n                { 'amdefine': 44 }\n            ],\n            44: [\n                function (_dereq_, module, exports) {\n                    (function (process, __filename) {\n                        function amdefine(module, requireFn) {\n                            var defineCache = {}, loaderCache = {}, alreadyCalled = false, path = _dereq_('path'), makeRequire, stringRequire;\n                            function trimDots(ary) {\n                                var i, part;\n                                for (i = 0; ary[i]; i += 1) {\n                                    part = ary[i];\n                                    if (part === '.') {\n                                        ary.splice(i, 1);\n                                        i -= 1;\n                                    } else if (part === '..') {\n                                        if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                                            break;\n                                        } else if (i > 0) {\n                                            ary.splice(i - 1, 2);\n                                            i -= 2;\n                                        }\n                                    }\n                                }\n                            }\n                            function normalize(name, baseName) {\n                                var baseParts;\n                                if (name && name.charAt(0) === '.') {\n                                    if (baseName) {\n                                        baseParts = baseName.split('/');\n                                        baseParts = baseParts.slice(0, baseParts.length - 1);\n                                        baseParts = baseParts.concat(name.split('/'));\n                                        trimDots(baseParts);\n                                        name = baseParts.join('/');\n                                    }\n                                }\n                                return name;\n                            }\n                            function makeNormalize(relName) {\n                                return function (name) {\n                                    return normalize(name, relName);\n                                };\n                            }\n                            function makeLoad(id) {\n                                function load(value) {\n                                    loaderCache[id] = value;\n                                }\n                                load.fromText = function (id, text) {\n                                    throw new Error('amdefine does not implement load.fromText');\n                                };\n                                return load;\n                            }\n                            makeRequire = function (systemRequire, exports, module, relId) {\n                                function amdRequire(deps, callback) {\n                                    if (typeof deps === 'string') {\n                                        return stringRequire(systemRequire, exports, module, deps, relId);\n                                    } else {\n                                        deps = deps.map(function (depName) {\n                                            return stringRequire(systemRequire, exports, module, depName, relId);\n                                        });\n                                        process.nextTick(function () {\n                                            callback.apply(null, deps);\n                                        });\n                                    }\n                                }\n                                amdRequire.toUrl = function (filePath) {\n                                    if (filePath.indexOf('.') === 0) {\n                                        return normalize(filePath, path.dirname(module.filename));\n                                    } else {\n                                        return filePath;\n                                    }\n                                };\n                                return amdRequire;\n                            };\n                            requireFn = requireFn || function req() {\n                                return module.require.apply(module, arguments);\n                            };\n                            function runFactory(id, deps, factory) {\n                                var r, e, m, result;\n                                if (id) {\n                                    e = loaderCache[id] = {};\n                                    m = {\n                                        id: id,\n                                        uri: __filename,\n                                        exports: e\n                                    };\n                                    r = makeRequire(requireFn, e, m, id);\n                                } else {\n                                    if (alreadyCalled) {\n                                        throw new Error('amdefine with no module ID cannot be called more than once per file.');\n                                    }\n                                    alreadyCalled = true;\n                                    e = module.exports;\n                                    m = module;\n                                    r = makeRequire(requireFn, e, m, module.id);\n                                }\n                                if (deps) {\n                                    deps = deps.map(function (depName) {\n                                        return r(depName);\n                                    });\n                                }\n                                if (typeof factory === 'function') {\n                                    result = factory.apply(m.exports, deps);\n                                } else {\n                                    result = factory;\n                                }\n                                if (result !== undefined) {\n                                    m.exports = result;\n                                    if (id) {\n                                        loaderCache[id] = m.exports;\n                                    }\n                                }\n                            }\n                            stringRequire = function (systemRequire, exports, module, id, relId) {\n                                var index = id.indexOf('!'), originalId = id, prefix, plugin;\n                                if (index === -1) {\n                                    id = normalize(id, relId);\n                                    if (id === 'require') {\n                                        return makeRequire(systemRequire, exports, module, relId);\n                                    } else if (id === 'exports') {\n                                        return exports;\n                                    } else if (id === 'module') {\n                                        return module;\n                                    } else if (loaderCache.hasOwnProperty(id)) {\n                                        return loaderCache[id];\n                                    } else if (defineCache[id]) {\n                                        runFactory.apply(null, defineCache[id]);\n                                        return loaderCache[id];\n                                    } else {\n                                        if (systemRequire) {\n                                            return systemRequire(originalId);\n                                        } else {\n                                            throw new Error('No module with ID: ' + id);\n                                        }\n                                    }\n                                } else {\n                                    prefix = id.substring(0, index);\n                                    id = id.substring(index + 1, id.length);\n                                    plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n                                    if (plugin.normalize) {\n                                        id = plugin.normalize(id, makeNormalize(relId));\n                                    } else {\n                                        id = normalize(id, relId);\n                                    }\n                                    if (loaderCache[id]) {\n                                        return loaderCache[id];\n                                    } else {\n                                        plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n                                        return loaderCache[id];\n                                    }\n                                }\n                            };\n                            function define(id, deps, factory) {\n                                if (Array.isArray(id)) {\n                                    factory = deps;\n                                    deps = id;\n                                    id = undefined;\n                                } else if (typeof id !== 'string') {\n                                    factory = id;\n                                    id = deps = undefined;\n                                }\n                                if (deps && !Array.isArray(deps)) {\n                                    factory = deps;\n                                    deps = undefined;\n                                }\n                                if (!deps) {\n                                    deps = [\n                                        'require',\n                                        'exports',\n                                        'module'\n                                    ];\n                                }\n                                if (id) {\n                                    defineCache[id] = [\n                                        id,\n                                        deps,\n                                        factory\n                                    ];\n                                } else {\n                                    runFactory(id, deps, factory);\n                                }\n                            }\n                            define.require = function (id) {\n                                if (loaderCache[id]) {\n                                    return loaderCache[id];\n                                }\n                                if (defineCache[id]) {\n                                    runFactory.apply(null, defineCache[id]);\n                                    return loaderCache[id];\n                                }\n                            };\n                            define.amd = {};\n                            return define;\n                        }\n                        module.exports = amdefine;\n                    }.call(this, _dereq_('/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js'), '/../node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js'));\n                },\n                {\n                    '/Users/forbeslindesay/GitHub/jade/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js': 29,\n                    'path': 30\n                }\n            ],\n            45: [\n                function (_dereq_, module, exports) {\n                    var sys = _dereq_('util');\n                    var MOZ_SourceMap = _dereq_('source-map');\n                    var UglifyJS = exports;\n                    function array_to_hash(a) {\n                        var ret = Object.create(null);\n                        for (var i = 0; i < a.length; ++i)\n                            ret[a[i]] = true;\n                        return ret;\n                    }\n                    ;\n                    function slice(a, start) {\n                        return Array.prototype.slice.call(a, start || 0);\n                    }\n                    ;\n                    function characters(str) {\n                        return str.split('');\n                    }\n                    ;\n                    function member(name, array) {\n                        for (var i = array.length; --i >= 0;)\n                            if (array[i] == name)\n                                return true;\n                        return false;\n                    }\n                    ;\n                    function find_if(func, array) {\n                        for (var i = 0, n = array.length; i < n; ++i) {\n                            if (func(array[i]))\n                                return array[i];\n                        }\n                    }\n                    ;\n                    function repeat_string(str, i) {\n                        if (i <= 0)\n                            return '';\n                        if (i == 1)\n                            return str;\n                        var d = repeat_string(str, i >> 1);\n                        d += d;\n                        if (i & 1)\n                            d += str;\n                        return d;\n                    }\n                    ;\n                    function DefaultsError(msg, defs) {\n                        Error.call(this, msg);\n                        this.msg = msg;\n                        this.defs = defs;\n                    }\n                    ;\n                    DefaultsError.prototype = Object.create(Error.prototype);\n                    DefaultsError.prototype.constructor = DefaultsError;\n                    DefaultsError.croak = function (msg, defs) {\n                        throw new DefaultsError(msg, defs);\n                    };\n                    function defaults(args, defs, croak) {\n                        if (args === true)\n                            args = {};\n                        var ret = args || {};\n                        if (croak)\n                            for (var i in ret)\n                                if (ret.hasOwnProperty(i) && !defs.hasOwnProperty(i))\n                                    DefaultsError.croak('`' + i + '` is not a supported option', defs);\n                        for (var i in defs)\n                            if (defs.hasOwnProperty(i)) {\n                                ret[i] = args && args.hasOwnProperty(i) ? args[i] : defs[i];\n                            }\n                        return ret;\n                    }\n                    ;\n                    function merge(obj, ext) {\n                        for (var i in ext)\n                            if (ext.hasOwnProperty(i)) {\n                                obj[i] = ext[i];\n                            }\n                        return obj;\n                    }\n                    ;\n                    function noop() {\n                    }\n                    ;\n                    var MAP = function () {\n                        function MAP(a, f, backwards) {\n                            var ret = [], top = [], i;\n                            function doit() {\n                                var val = f(a[i], i);\n                                var is_last = val instanceof Last;\n                                if (is_last)\n                                    val = val.v;\n                                if (val instanceof AtTop) {\n                                    val = val.v;\n                                    if (val instanceof Splice) {\n                                        top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);\n                                    } else {\n                                        top.push(val);\n                                    }\n                                } else if (val !== skip) {\n                                    if (val instanceof Splice) {\n                                        ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);\n                                    } else {\n                                        ret.push(val);\n                                    }\n                                }\n                                return is_last;\n                            }\n                            ;\n                            if (a instanceof Array) {\n                                if (backwards) {\n                                    for (i = a.length; --i >= 0;)\n                                        if (doit())\n                                            break;\n                                    ret.reverse();\n                                    top.reverse();\n                                } else {\n                                    for (i = 0; i < a.length; ++i)\n                                        if (doit())\n                                            break;\n                                }\n                            } else {\n                                for (i in a)\n                                    if (a.hasOwnProperty(i))\n                                        if (doit())\n                                            break;\n                            }\n                            return top.concat(ret);\n                        }\n                        ;\n                        MAP.at_top = function (val) {\n                            return new AtTop(val);\n                        };\n                        MAP.splice = function (val) {\n                            return new Splice(val);\n                        };\n                        MAP.last = function (val) {\n                            return new Last(val);\n                        };\n                        var skip = MAP.skip = {};\n                        function AtTop(val) {\n                            this.v = val;\n                        }\n                        ;\n                        function Splice(val) {\n                            this.v = val;\n                        }\n                        ;\n                        function Last(val) {\n                            this.v = val;\n                        }\n                        ;\n                        return MAP;\n                    }();\n                    function push_uniq(array, el) {\n                        if (array.indexOf(el) < 0)\n                            array.push(el);\n                    }\n                    ;\n                    function string_template(text, props) {\n                        return text.replace(/\\{(.+?)\\}/g, function (str, p) {\n                            return props[p];\n                        });\n                    }\n                    ;\n                    function remove(array, el) {\n                        for (var i = array.length; --i >= 0;) {\n                            if (array[i] === el)\n                                array.splice(i, 1);\n                        }\n                    }\n                    ;\n                    function mergeSort(array, cmp) {\n                        if (array.length < 2)\n                            return array.slice();\n                        function merge(a, b) {\n                            var r = [], ai = 0, bi = 0, i = 0;\n                            while (ai < a.length && bi < b.length) {\n                                cmp(a[ai], b[bi]) <= 0 ? r[i++] = a[ai++] : r[i++] = b[bi++];\n                            }\n                            if (ai < a.length)\n                                r.push.apply(r, a.slice(ai));\n                            if (bi < b.length)\n                                r.push.apply(r, b.slice(bi));\n                            return r;\n                        }\n                        ;\n                        function _ms(a) {\n                            if (a.length <= 1)\n                                return a;\n                            var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);\n                            left = _ms(left);\n                            right = _ms(right);\n                            return merge(left, right);\n                        }\n                        ;\n                        return _ms(array);\n                    }\n                    ;\n                    function set_difference(a, b) {\n                        return a.filter(function (el) {\n                            return b.indexOf(el) < 0;\n                        });\n                    }\n                    ;\n                    function set_intersection(a, b) {\n                        return a.filter(function (el) {\n                            return b.indexOf(el) >= 0;\n                        });\n                    }\n                    ;\n                    function makePredicate(words) {\n                        if (!(words instanceof Array))\n                            words = words.split(' ');\n                        var f = '', cats = [];\n                        out:\n                            for (var i = 0; i < words.length; ++i) {\n                                for (var j = 0; j < cats.length; ++j)\n                                    if (cats[j][0].length == words[i].length) {\n                                        cats[j].push(words[i]);\n                                        continue out;\n                                    }\n                                cats.push([words[i]]);\n                            }\n                        function compareTo(arr) {\n                            if (arr.length == 1)\n                                return f += 'return str === ' + JSON.stringify(arr[0]) + ';';\n                            f += 'switch(str){';\n                            for (var i = 0; i < arr.length; ++i)\n                                f += 'case ' + JSON.stringify(arr[i]) + ':';\n                            f += 'return true}return false;';\n                        }\n                        if (cats.length > 3) {\n                            cats.sort(function (a, b) {\n                                return b.length - a.length;\n                            });\n                            f += 'switch(str.length){';\n                            for (var i = 0; i < cats.length; ++i) {\n                                var cat = cats[i];\n                                f += 'case ' + cat[0].length + ':';\n                                compareTo(cat);\n                            }\n                            f += '}';\n                        } else {\n                            compareTo(words);\n                        }\n                        return new Function('str', f);\n                    }\n                    ;\n                    function all(array, predicate) {\n                        for (var i = array.length; --i >= 0;)\n                            if (!predicate(array[i]))\n                                return false;\n                        return true;\n                    }\n                    ;\n                    function Dictionary() {\n                        this._values = Object.create(null);\n                        this._size = 0;\n                    }\n                    ;\n                    Dictionary.prototype = {\n                        set: function (key, val) {\n                            if (!this.has(key))\n                                ++this._size;\n                            this._values['$' + key] = val;\n                            return this;\n                        },\n                        add: function (key, val) {\n                            if (this.has(key)) {\n                                this.get(key).push(val);\n                            } else {\n                                this.set(key, [val]);\n                            }\n                            return this;\n                        },\n                        get: function (key) {\n                            return this._values['$' + key];\n                        },\n                        del: function (key) {\n                            if (this.has(key)) {\n                                --this._size;\n                                delete this._values['$' + key];\n                            }\n                            return this;\n                        },\n                        has: function (key) {\n                            return '$' + key in this._values;\n                        },\n                        each: function (f) {\n                            for (var i in this._values)\n                                f(this._values[i], i.substr(1));\n                        },\n                        size: function () {\n                            return this._size;\n                        },\n                        map: function (f) {\n                            var ret = [];\n                            for (var i in this._values)\n                                ret.push(f(this._values[i], i.substr(1)));\n                            return ret;\n                        }\n                    };\n                    function DEFNODE(type, props, methods, base) {\n                        if (arguments.length < 4)\n                            base = AST_Node;\n                        if (!props)\n                            props = [];\n                        else\n                            props = props.split(/\\s+/);\n                        var self_props = props;\n                        if (base && base.PROPS)\n                            props = props.concat(base.PROPS);\n                        var code = 'return function AST_' + type + '(props){ if (props) { ';\n                        for (var i = props.length; --i >= 0;) {\n                            code += 'this.' + props[i] + ' = props.' + props[i] + ';';\n                        }\n                        var proto = base && new base();\n                        if (proto && proto.initialize || methods && methods.initialize)\n                            code += 'this.initialize();';\n                        code += '}}';\n                        var ctor = new Function(code)();\n                        if (proto) {\n                            ctor.prototype = proto;\n                            ctor.BASE = base;\n                        }\n                        if (base)\n                            base.SUBCLASSES.push(ctor);\n                        ctor.prototype.CTOR = ctor;\n                        ctor.PROPS = props || null;\n                        ctor.SELF_PROPS = self_props;\n                        ctor.SUBCLASSES = [];\n                        if (type) {\n                            ctor.prototype.TYPE = ctor.TYPE = type;\n                        }\n                        if (methods)\n                            for (i in methods)\n                                if (methods.hasOwnProperty(i)) {\n                                    if (/^\\$/.test(i)) {\n                                        ctor[i.substr(1)] = methods[i];\n                                    } else {\n                                        ctor.prototype[i] = methods[i];\n                                    }\n                                }\n                        ctor.DEFMETHOD = function (name, method) {\n                            this.prototype[name] = method;\n                        };\n                        return ctor;\n                    }\n                    ;\n                    var AST_Token = DEFNODE('Token', 'type value line col pos endpos nlb comments_before file', {}, null);\n                    var AST_Node = DEFNODE('Node', 'start end', {\n                        clone: function () {\n                            return new this.CTOR(this);\n                        },\n                        $documentation: 'Base class of all AST nodes',\n                        $propdoc: {\n                            start: '[AST_Token] The first token of this node',\n                            end: '[AST_Token] The last token of this node'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this);\n                        },\n                        walk: function (visitor) {\n                            return this._walk(visitor);\n                        }\n                    }, null);\n                    AST_Node.warn_function = null;\n                    AST_Node.warn = function (txt, props) {\n                        if (AST_Node.warn_function)\n                            AST_Node.warn_function(string_template(txt, props));\n                    };\n                    var AST_Statement = DEFNODE('Statement', null, { $documentation: 'Base class of all statements' });\n                    var AST_Debugger = DEFNODE('Debugger', null, { $documentation: 'Represents a debugger statement' }, AST_Statement);\n                    var AST_Directive = DEFNODE('Directive', 'value scope', {\n                        $documentation: 'Represents a directive, like \"use strict\";',\n                        $propdoc: {\n                            value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n                            scope: '[AST_Scope/S] The scope that this directive affects'\n                        }\n                    }, AST_Statement);\n                    var AST_SimpleStatement = DEFNODE('SimpleStatement', 'body', {\n                        $documentation: 'A statement consisting of an expression, i.e. a = 1 + 2',\n                        $propdoc: { body: '[AST_Node] an expression node (should not be instanceof AST_Statement)' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_Statement);\n                    function walk_body(node, visitor) {\n                        if (node.body instanceof AST_Statement) {\n                            node.body._walk(visitor);\n                        } else\n                            node.body.forEach(function (stat) {\n                                stat._walk(visitor);\n                            });\n                    }\n                    ;\n                    var AST_Block = DEFNODE('Block', 'body', {\n                        $documentation: 'A body of statements (usually bracketed)',\n                        $propdoc: { body: '[AST_Statement*] an array of statements' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                walk_body(this, visitor);\n                            });\n                        }\n                    }, AST_Statement);\n                    var AST_BlockStatement = DEFNODE('BlockStatement', null, { $documentation: 'A block statement' }, AST_Block);\n                    var AST_EmptyStatement = DEFNODE('EmptyStatement', null, {\n                        $documentation: 'The empty statement (empty block or simply a semicolon)',\n                        _walk: function (visitor) {\n                            return visitor._visit(this);\n                        }\n                    }, AST_Statement);\n                    var AST_StatementWithBody = DEFNODE('StatementWithBody', 'body', {\n                        $documentation: 'Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`',\n                        $propdoc: { body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\" },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_Statement);\n                    var AST_LabeledStatement = DEFNODE('LabeledStatement', 'label', {\n                        $documentation: 'Statement with a label',\n                        $propdoc: { label: '[AST_Label] a label definition' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.label._walk(visitor);\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_StatementWithBody);\n                    var AST_IterationStatement = DEFNODE('IterationStatement', null, { $documentation: 'Internal class.  All loops inherit from it.' }, AST_StatementWithBody);\n                    var AST_DWLoop = DEFNODE('DWLoop', 'condition', {\n                        $documentation: 'Base class for do/while statements',\n                        $propdoc: { condition: '[AST_Node] the loop condition.  Should not be instanceof AST_Statement' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.condition._walk(visitor);\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_IterationStatement);\n                    var AST_Do = DEFNODE('Do', null, { $documentation: 'A `do` statement' }, AST_DWLoop);\n                    var AST_While = DEFNODE('While', null, { $documentation: 'A `while` statement' }, AST_DWLoop);\n                    var AST_For = DEFNODE('For', 'init condition step', {\n                        $documentation: 'A `for` statement',\n                        $propdoc: {\n                            init: '[AST_Node?] the `for` initialization code, or null if empty',\n                            condition: '[AST_Node?] the `for` termination clause, or null if empty',\n                            step: '[AST_Node?] the `for` update clause, or null if empty'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                if (this.init)\n                                    this.init._walk(visitor);\n                                if (this.condition)\n                                    this.condition._walk(visitor);\n                                if (this.step)\n                                    this.step._walk(visitor);\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_IterationStatement);\n                    var AST_ForIn = DEFNODE('ForIn', 'init name object', {\n                        $documentation: 'A `for ... in` statement',\n                        $propdoc: {\n                            init: '[AST_Node] the `for/in` initialization code',\n                            name: '[AST_SymbolRef?] the loop variable, only if `init` is AST_Var',\n                            object: \"[AST_Node] the object that we're looping through\"\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.init._walk(visitor);\n                                this.object._walk(visitor);\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_IterationStatement);\n                    var AST_With = DEFNODE('With', 'expression', {\n                        $documentation: 'A `with` statement',\n                        $propdoc: { expression: '[AST_Node] the `with` expression' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                                this.body._walk(visitor);\n                            });\n                        }\n                    }, AST_StatementWithBody);\n                    var AST_Scope = DEFNODE('Scope', 'directives variables functions uses_with uses_eval parent_scope enclosed cname', {\n                        $documentation: 'Base class for all statements introducing a lexical scope',\n                        $propdoc: {\n                            directives: '[string*/S] an array of directives declared in this scope',\n                            variables: '[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope',\n                            functions: '[Object/S] like `variables`, but only lists function declarations',\n                            uses_with: '[boolean/S] tells whether this scope uses the `with` statement',\n                            uses_eval: '[boolean/S] tells whether this scope contains a direct call to the global `eval`',\n                            parent_scope: '[AST_Scope?/S] link to the parent scope',\n                            enclosed: '[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes',\n                            cname: '[integer/S] current index for mangling variables (used internally by the mangler)'\n                        }\n                    }, AST_Block);\n                    var AST_Toplevel = DEFNODE('Toplevel', 'globals', {\n                        $documentation: 'The toplevel scope',\n                        $propdoc: { globals: '[Object/S] a map of name -> SymbolDef for all undeclared names' },\n                        wrap_enclose: function (arg_parameter_pairs) {\n                            var self = this;\n                            var args = [];\n                            var parameters = [];\n                            arg_parameter_pairs.forEach(function (pair) {\n                                var split = pair.split(':');\n                                args.push(split[0]);\n                                parameters.push(split[1]);\n                            });\n                            var wrapped_tl = '(function(' + parameters.join(',') + \"){ '$ORIG'; })(\" + args.join(',') + ')';\n                            wrapped_tl = parse(wrapped_tl);\n                            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {\n                                if (node instanceof AST_Directive && node.value == '$ORIG') {\n                                    return MAP.splice(self.body);\n                                }\n                            }));\n                            return wrapped_tl;\n                        },\n                        wrap_commonjs: function (name, export_all) {\n                            var self = this;\n                            var to_export = [];\n                            if (export_all) {\n                                self.figure_out_scope();\n                                self.walk(new TreeWalker(function (node) {\n                                    if (node instanceof AST_SymbolDeclaration && node.definition().global) {\n                                        if (!find_if(function (n) {\n                                                return n.name == node.name;\n                                            }, to_export))\n                                            to_export.push(node);\n                                    }\n                                }));\n                            }\n                            var wrapped_tl = \"(function(exports, global){ global['\" + name + \"'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))\";\n                            wrapped_tl = parse(wrapped_tl);\n                            wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node) {\n                                if (node instanceof AST_SimpleStatement) {\n                                    node = node.body;\n                                    if (node instanceof AST_String)\n                                        switch (node.getValue()) {\n                                        case '$ORIG':\n                                            return MAP.splice(self.body);\n                                        case '$EXPORTS':\n                                            var body = [];\n                                            to_export.forEach(function (sym) {\n                                                body.push(new AST_SimpleStatement({\n                                                    body: new AST_Assign({\n                                                        left: new AST_Sub({\n                                                            expression: new AST_SymbolRef({ name: 'exports' }),\n                                                            property: new AST_String({ value: sym.name })\n                                                        }),\n                                                        operator: '=',\n                                                        right: new AST_SymbolRef(sym)\n                                                    })\n                                                }));\n                                            });\n                                            return MAP.splice(body);\n                                        }\n                                }\n                            }));\n                            return wrapped_tl;\n                        }\n                    }, AST_Scope);\n                    var AST_Lambda = DEFNODE('Lambda', 'name argnames uses_arguments', {\n                        $documentation: 'Base class for functions',\n                        $propdoc: {\n                            name: '[AST_SymbolDeclaration?] the name of this function',\n                            argnames: '[AST_SymbolFunarg*] array of function arguments',\n                            uses_arguments: '[boolean/S] tells whether this function accesses the arguments array'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                if (this.name)\n                                    this.name._walk(visitor);\n                                this.argnames.forEach(function (arg) {\n                                    arg._walk(visitor);\n                                });\n                                walk_body(this, visitor);\n                            });\n                        }\n                    }, AST_Scope);\n                    var AST_Accessor = DEFNODE('Accessor', null, { $documentation: 'A setter/getter function.  The `name` property is always null.' }, AST_Lambda);\n                    var AST_Function = DEFNODE('Function', null, { $documentation: 'A function expression' }, AST_Lambda);\n                    var AST_Defun = DEFNODE('Defun', null, { $documentation: 'A function definition' }, AST_Lambda);\n                    var AST_Jump = DEFNODE('Jump', null, { $documentation: \"Base class for \\u201Cjumps\\u201D (for now that's `return`, `throw`, `break` and `continue`)\" }, AST_Statement);\n                    var AST_Exit = DEFNODE('Exit', 'value', {\n                        $documentation: 'Base class for \\u201Cexits\\u201D (`return` and `throw`)',\n                        $propdoc: { value: '[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, this.value && function () {\n                                this.value._walk(visitor);\n                            });\n                        }\n                    }, AST_Jump);\n                    var AST_Return = DEFNODE('Return', null, { $documentation: 'A `return` statement' }, AST_Exit);\n                    var AST_Throw = DEFNODE('Throw', null, { $documentation: 'A `throw` statement' }, AST_Exit);\n                    var AST_LoopControl = DEFNODE('LoopControl', 'label', {\n                        $documentation: 'Base class for loop control statements (`break` and `continue`)',\n                        $propdoc: { label: '[AST_LabelRef?] the label, or null if none' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, this.label && function () {\n                                this.label._walk(visitor);\n                            });\n                        }\n                    }, AST_Jump);\n                    var AST_Break = DEFNODE('Break', null, { $documentation: 'A `break` statement' }, AST_LoopControl);\n                    var AST_Continue = DEFNODE('Continue', null, { $documentation: 'A `continue` statement' }, AST_LoopControl);\n                    var AST_If = DEFNODE('If', 'condition alternative', {\n                        $documentation: 'A `if` statement',\n                        $propdoc: {\n                            condition: '[AST_Node] the `if` condition',\n                            alternative: '[AST_Statement?] the `else` part, or null if not present'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.condition._walk(visitor);\n                                this.body._walk(visitor);\n                                if (this.alternative)\n                                    this.alternative._walk(visitor);\n                            });\n                        }\n                    }, AST_StatementWithBody);\n                    var AST_Switch = DEFNODE('Switch', 'expression', {\n                        $documentation: 'A `switch` statement',\n                        $propdoc: { expression: '[AST_Node] the `switch` \\u201Cdiscriminant\\u201D' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                                walk_body(this, visitor);\n                            });\n                        }\n                    }, AST_Block);\n                    var AST_SwitchBranch = DEFNODE('SwitchBranch', null, { $documentation: 'Base class for `switch` branches' }, AST_Block);\n                    var AST_Default = DEFNODE('Default', null, { $documentation: 'A `default` switch branch' }, AST_SwitchBranch);\n                    var AST_Case = DEFNODE('Case', 'expression', {\n                        $documentation: 'A `case` switch branch',\n                        $propdoc: { expression: '[AST_Node] the `case` expression' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                                walk_body(this, visitor);\n                            });\n                        }\n                    }, AST_SwitchBranch);\n                    var AST_Try = DEFNODE('Try', 'bcatch bfinally', {\n                        $documentation: 'A `try` statement',\n                        $propdoc: {\n                            bcatch: '[AST_Catch?] the catch block, or null if not present',\n                            bfinally: '[AST_Finally?] the finally block, or null if not present'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                walk_body(this, visitor);\n                                if (this.bcatch)\n                                    this.bcatch._walk(visitor);\n                                if (this.bfinally)\n                                    this.bfinally._walk(visitor);\n                            });\n                        }\n                    }, AST_Block);\n                    var AST_Catch = DEFNODE('Catch', 'argname', {\n                        $documentation: 'A `catch` node; only makes sense as part of a `try` statement',\n                        $propdoc: { argname: '[AST_SymbolCatch] symbol for the exception' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.argname._walk(visitor);\n                                walk_body(this, visitor);\n                            });\n                        }\n                    }, AST_Block);\n                    var AST_Finally = DEFNODE('Finally', null, { $documentation: 'A `finally` node; only makes sense as part of a `try` statement' }, AST_Block);\n                    var AST_Definitions = DEFNODE('Definitions', 'definitions', {\n                        $documentation: 'Base class for `var` or `const` nodes (variable declarations/initializations)',\n                        $propdoc: { definitions: '[AST_VarDef*] array of variable definitions' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.definitions.forEach(function (def) {\n                                    def._walk(visitor);\n                                });\n                            });\n                        }\n                    }, AST_Statement);\n                    var AST_Var = DEFNODE('Var', null, { $documentation: 'A `var` statement' }, AST_Definitions);\n                    var AST_Const = DEFNODE('Const', null, { $documentation: 'A `const` statement' }, AST_Definitions);\n                    var AST_VarDef = DEFNODE('VarDef', 'name value', {\n                        $documentation: 'A variable declaration; only appears in a AST_Definitions node',\n                        $propdoc: {\n                            name: '[AST_SymbolVar|AST_SymbolConst] name of the variable',\n                            value: \"[AST_Node?] initializer, or null of there's no initializer\"\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.name._walk(visitor);\n                                if (this.value)\n                                    this.value._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_Call = DEFNODE('Call', 'expression args', {\n                        $documentation: 'A function call expression',\n                        $propdoc: {\n                            expression: '[AST_Node] expression to invoke as function',\n                            args: '[AST_Node*] array of arguments'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                                this.args.forEach(function (arg) {\n                                    arg._walk(visitor);\n                                });\n                            });\n                        }\n                    });\n                    var AST_New = DEFNODE('New', null, { $documentation: 'An object instantiation.  Derives from a function call since it has exactly the same properties' }, AST_Call);\n                    var AST_Seq = DEFNODE('Seq', 'car cdr', {\n                        $documentation: 'A sequence expression (two comma-separated expressions)',\n                        $propdoc: {\n                            car: '[AST_Node] first element in sequence',\n                            cdr: '[AST_Node] second element in sequence'\n                        },\n                        $cons: function (x, y) {\n                            var seq = new AST_Seq(x);\n                            seq.car = x;\n                            seq.cdr = y;\n                            return seq;\n                        },\n                        $from_array: function (array) {\n                            if (array.length == 0)\n                                return null;\n                            if (array.length == 1)\n                                return array[0].clone();\n                            var list = null;\n                            for (var i = array.length; --i >= 0;) {\n                                list = AST_Seq.cons(array[i], list);\n                            }\n                            var p = list;\n                            while (p) {\n                                if (p.cdr && !p.cdr.cdr) {\n                                    p.cdr = p.cdr.car;\n                                    break;\n                                }\n                                p = p.cdr;\n                            }\n                            return list;\n                        },\n                        to_array: function () {\n                            var p = this, a = [];\n                            while (p) {\n                                a.push(p.car);\n                                if (p.cdr && !(p.cdr instanceof AST_Seq)) {\n                                    a.push(p.cdr);\n                                    break;\n                                }\n                                p = p.cdr;\n                            }\n                            return a;\n                        },\n                        add: function (node) {\n                            var p = this;\n                            while (p) {\n                                if (!(p.cdr instanceof AST_Seq)) {\n                                    var cell = AST_Seq.cons(p.cdr, node);\n                                    return p.cdr = cell;\n                                }\n                                p = p.cdr;\n                            }\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.car._walk(visitor);\n                                if (this.cdr)\n                                    this.cdr._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_PropAccess = DEFNODE('PropAccess', 'expression property', {\n                        $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`',\n                        $propdoc: {\n                            expression: '[AST_Node] the \\u201Ccontainer\\u201D expression',\n                            property: \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\"\n                        }\n                    });\n                    var AST_Dot = DEFNODE('Dot', null, {\n                        $documentation: 'A dotted property access expression',\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                            });\n                        }\n                    }, AST_PropAccess);\n                    var AST_Sub = DEFNODE('Sub', null, {\n                        $documentation: 'Index-style property access, i.e. `a[\"foo\"]`',\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                                this.property._walk(visitor);\n                            });\n                        }\n                    }, AST_PropAccess);\n                    var AST_Unary = DEFNODE('Unary', 'operator expression', {\n                        $documentation: 'Base class for unary expressions',\n                        $propdoc: {\n                            operator: '[string] the operator',\n                            expression: '[AST_Node] expression that this unary operator applies to'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.expression._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_UnaryPrefix = DEFNODE('UnaryPrefix', null, { $documentation: 'Unary prefix expression, i.e. `typeof i` or `++i`' }, AST_Unary);\n                    var AST_UnaryPostfix = DEFNODE('UnaryPostfix', null, { $documentation: 'Unary postfix expression, i.e. `i++`' }, AST_Unary);\n                    var AST_Binary = DEFNODE('Binary', 'left operator right', {\n                        $documentation: 'Binary expression, i.e. `a + b`',\n                        $propdoc: {\n                            left: '[AST_Node] left-hand side expression',\n                            operator: '[string] the operator',\n                            right: '[AST_Node] right-hand side expression'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.left._walk(visitor);\n                                this.right._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_Conditional = DEFNODE('Conditional', 'condition consequent alternative', {\n                        $documentation: 'Conditional expression using the ternary operator, i.e. `a ? b : c`',\n                        $propdoc: {\n                            condition: '[AST_Node]',\n                            consequent: '[AST_Node]',\n                            alternative: '[AST_Node]'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.condition._walk(visitor);\n                                this.consequent._walk(visitor);\n                                this.alternative._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_Assign = DEFNODE('Assign', null, { $documentation: 'An assignment expression \\u2014 `a = b + 5`' }, AST_Binary);\n                    var AST_Array = DEFNODE('Array', 'elements', {\n                        $documentation: 'An array literal',\n                        $propdoc: { elements: '[AST_Node*] array of elements' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.elements.forEach(function (el) {\n                                    el._walk(visitor);\n                                });\n                            });\n                        }\n                    });\n                    var AST_Object = DEFNODE('Object', 'properties', {\n                        $documentation: 'An object literal',\n                        $propdoc: { properties: '[AST_ObjectProperty*] array of properties' },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.properties.forEach(function (prop) {\n                                    prop._walk(visitor);\n                                });\n                            });\n                        }\n                    });\n                    var AST_ObjectProperty = DEFNODE('ObjectProperty', 'key value', {\n                        $documentation: 'Base class for literal object properties',\n                        $propdoc: {\n                            key: '[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.',\n                            value: '[AST_Node] property value.  For setters and getters this is an AST_Function.'\n                        },\n                        _walk: function (visitor) {\n                            return visitor._visit(this, function () {\n                                this.value._walk(visitor);\n                            });\n                        }\n                    });\n                    var AST_ObjectKeyVal = DEFNODE('ObjectKeyVal', null, { $documentation: 'A key: value object property' }, AST_ObjectProperty);\n                    var AST_ObjectSetter = DEFNODE('ObjectSetter', null, { $documentation: 'An object setter property' }, AST_ObjectProperty);\n                    var AST_ObjectGetter = DEFNODE('ObjectGetter', null, { $documentation: 'An object getter property' }, AST_ObjectProperty);\n                    var AST_Symbol = DEFNODE('Symbol', 'scope name thedef', {\n                        $propdoc: {\n                            name: '[string] name of this symbol',\n                            scope: '[AST_Scope/S] the current scope (not necessarily the definition scope)',\n                            thedef: '[SymbolDef/S] the definition of this symbol'\n                        },\n                        $documentation: 'Base class for all symbols'\n                    });\n                    var AST_SymbolAccessor = DEFNODE('SymbolAccessor', null, { $documentation: 'The name of a property accessor (setter/getter function)' }, AST_Symbol);\n                    var AST_SymbolDeclaration = DEFNODE('SymbolDeclaration', 'init', {\n                        $documentation: 'A declaration symbol (symbol in var/const, function name or argument, symbol in catch)',\n                        $propdoc: { init: '[AST_Node*/S] array of initializers for this declaration.' }\n                    }, AST_Symbol);\n                    var AST_SymbolVar = DEFNODE('SymbolVar', null, { $documentation: 'Symbol defining a variable' }, AST_SymbolDeclaration);\n                    var AST_SymbolConst = DEFNODE('SymbolConst', null, { $documentation: 'A constant declaration' }, AST_SymbolDeclaration);\n                    var AST_SymbolFunarg = DEFNODE('SymbolFunarg', null, { $documentation: 'Symbol naming a function argument' }, AST_SymbolVar);\n                    var AST_SymbolDefun = DEFNODE('SymbolDefun', null, { $documentation: 'Symbol defining a function' }, AST_SymbolDeclaration);\n                    var AST_SymbolLambda = DEFNODE('SymbolLambda', null, { $documentation: 'Symbol naming a function expression' }, AST_SymbolDeclaration);\n                    var AST_SymbolCatch = DEFNODE('SymbolCatch', null, { $documentation: 'Symbol naming the exception in catch' }, AST_SymbolDeclaration);\n                    var AST_Label = DEFNODE('Label', 'references', {\n                        $documentation: 'Symbol naming a label (declaration)',\n                        $propdoc: { references: '[AST_LoopControl*] a list of nodes referring to this label' },\n                        initialize: function () {\n                            this.references = [];\n                            this.thedef = this;\n                        }\n                    }, AST_Symbol);\n                    var AST_SymbolRef = DEFNODE('SymbolRef', null, { $documentation: 'Reference to some symbol (not definition/declaration)' }, AST_Symbol);\n                    var AST_LabelRef = DEFNODE('LabelRef', null, { $documentation: 'Reference to a label symbol' }, AST_Symbol);\n                    var AST_This = DEFNODE('This', null, { $documentation: 'The `this` symbol' }, AST_Symbol);\n                    var AST_Constant = DEFNODE('Constant', null, {\n                        $documentation: 'Base class for all constants',\n                        getValue: function () {\n                            return this.value;\n                        }\n                    });\n                    var AST_String = DEFNODE('String', 'value', {\n                        $documentation: 'A string literal',\n                        $propdoc: { value: '[string] the contents of this string' }\n                    }, AST_Constant);\n                    var AST_Number = DEFNODE('Number', 'value', {\n                        $documentation: 'A number literal',\n                        $propdoc: { value: '[number] the numeric value' }\n                    }, AST_Constant);\n                    var AST_RegExp = DEFNODE('RegExp', 'value', {\n                        $documentation: 'A regexp literal',\n                        $propdoc: { value: '[RegExp] the actual regexp' }\n                    }, AST_Constant);\n                    var AST_Atom = DEFNODE('Atom', null, { $documentation: 'Base class for atoms' }, AST_Constant);\n                    var AST_Null = DEFNODE('Null', null, {\n                        $documentation: 'The `null` atom',\n                        value: null\n                    }, AST_Atom);\n                    var AST_NaN = DEFNODE('NaN', null, {\n                        $documentation: 'The impossible value',\n                        value: 0 / 0\n                    }, AST_Atom);\n                    var AST_Undefined = DEFNODE('Undefined', null, {\n                        $documentation: 'The `undefined` value',\n                        value: function () {\n                        }()\n                    }, AST_Atom);\n                    var AST_Hole = DEFNODE('Hole', null, {\n                        $documentation: 'A hole in an array',\n                        value: function () {\n                        }()\n                    }, AST_Atom);\n                    var AST_Infinity = DEFNODE('Infinity', null, {\n                        $documentation: 'The `Infinity` value',\n                        value: 1 / 0\n                    }, AST_Atom);\n                    var AST_Boolean = DEFNODE('Boolean', null, { $documentation: 'Base class for booleans' }, AST_Atom);\n                    var AST_False = DEFNODE('False', null, {\n                        $documentation: 'The `false` atom',\n                        value: false\n                    }, AST_Boolean);\n                    var AST_True = DEFNODE('True', null, {\n                        $documentation: 'The `true` atom',\n                        value: true\n                    }, AST_Boolean);\n                    function TreeWalker(callback) {\n                        this.visit = callback;\n                        this.stack = [];\n                    }\n                    ;\n                    TreeWalker.prototype = {\n                        _visit: function (node, descend) {\n                            this.stack.push(node);\n                            var ret = this.visit(node, descend ? function () {\n                                descend.call(node);\n                            } : noop);\n                            if (!ret && descend) {\n                                descend.call(node);\n                            }\n                            this.stack.pop();\n                            return ret;\n                        },\n                        parent: function (n) {\n                            return this.stack[this.stack.length - 2 - (n || 0)];\n                        },\n                        push: function (node) {\n                            this.stack.push(node);\n                        },\n                        pop: function () {\n                            return this.stack.pop();\n                        },\n                        self: function () {\n                            return this.stack[this.stack.length - 1];\n                        },\n                        find_parent: function (type) {\n                            var stack = this.stack;\n                            for (var i = stack.length; --i >= 0;) {\n                                var x = stack[i];\n                                if (x instanceof type)\n                                    return x;\n                            }\n                        },\n                        has_directive: function (type) {\n                            return this.find_parent(AST_Scope).has_directive(type);\n                        },\n                        in_boolean_context: function () {\n                            var stack = this.stack;\n                            var i = stack.length, self = stack[--i];\n                            while (i > 0) {\n                                var p = stack[--i];\n                                if (p instanceof AST_If && p.condition === self || p instanceof AST_Conditional && p.condition === self || p instanceof AST_DWLoop && p.condition === self || p instanceof AST_For && p.condition === self || p instanceof AST_UnaryPrefix && p.operator == '!' && p.expression === self) {\n                                    return true;\n                                }\n                                if (!(p instanceof AST_Binary && (p.operator == '&&' || p.operator == '||')))\n                                    return false;\n                                self = p;\n                            }\n                        },\n                        loopcontrol_target: function (label) {\n                            var stack = this.stack;\n                            if (label)\n                                for (var i = stack.length; --i >= 0;) {\n                                    var x = stack[i];\n                                    if (x instanceof AST_LabeledStatement && x.label.name == label.name) {\n                                        return x.body;\n                                    }\n                                }\n                            else\n                                for (var i = stack.length; --i >= 0;) {\n                                    var x = stack[i];\n                                    if (x instanceof AST_Switch || x instanceof AST_IterationStatement)\n                                        return x;\n                                }\n                        }\n                    };\n                    var KEYWORDS = 'break case catch const continue debugger default delete do else finally for function if in instanceof new return switch throw try typeof var void while with';\n                    var KEYWORDS_ATOM = 'false null true';\n                    var RESERVED_WORDS = 'abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized this throws transient volatile yield' + ' ' + KEYWORDS_ATOM + ' ' + KEYWORDS;\n                    var KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case';\n                    KEYWORDS = makePredicate(KEYWORDS);\n                    RESERVED_WORDS = makePredicate(RESERVED_WORDS);\n                    KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\n                    KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n                    var OPERATOR_CHARS = makePredicate(characters('+-*&%=<>!?|~^'));\n                    var RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n                    var RE_OCT_NUMBER = /^0[0-7]+$/;\n                    var RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n                    var OPERATORS = makePredicate([\n                        'in',\n                        'instanceof',\n                        'typeof',\n                        'new',\n                        'void',\n                        'delete',\n                        '++',\n                        '--',\n                        '+',\n                        '-',\n                        '!',\n                        '~',\n                        '&',\n                        '|',\n                        '^',\n                        '*',\n                        '/',\n                        '%',\n                        '>>',\n                        '<<',\n                        '>>>',\n                        '<',\n                        '>',\n                        '<=',\n                        '>=',\n                        '==',\n                        '===',\n                        '!=',\n                        '!==',\n                        '?',\n                        '=',\n                        '+=',\n                        '-=',\n                        '/=',\n                        '*=',\n                        '%=',\n                        '>>=',\n                        '<<=',\n                        '>>>=',\n                        '|=',\n                        '^=',\n                        '&=',\n                        '&&',\n                        '||'\n                    ]);\n                    var WHITESPACE_CHARS = makePredicate(characters(' \\xA0\\n\\r\\t\\f\\x0B\\u200B\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000'));\n                    var PUNC_BEFORE_EXPRESSION = makePredicate(characters('[{(,.;:'));\n                    var PUNC_CHARS = makePredicate(characters('[]{}(),;:'));\n                    var REGEXP_MODIFIERS = makePredicate(characters('gmsiy'));\n                    var UNICODE = {\n                        letter: new RegExp('[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]'),\n                        non_spacing_mark: new RegExp('[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]'),\n                        space_combining_mark: new RegExp('[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]'),\n                        connector_punctuation: new RegExp('[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]')\n                    };\n                    function is_letter(code) {\n                        return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));\n                    }\n                    ;\n                    function is_digit(code) {\n                        return code >= 48 && code <= 57;\n                    }\n                    ;\n                    function is_alphanumeric_char(code) {\n                        return is_digit(code) || is_letter(code);\n                    }\n                    ;\n                    function is_unicode_combining_mark(ch) {\n                        return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n                    }\n                    ;\n                    function is_unicode_connector_punctuation(ch) {\n                        return UNICODE.connector_punctuation.test(ch);\n                    }\n                    ;\n                    function is_identifier(name) {\n                        return !RESERVED_WORDS(name) && /^[a-z_$][a-z0-9_$]*$/i.test(name);\n                    }\n                    ;\n                    function is_identifier_start(code) {\n                        return code == 36 || code == 95 || is_letter(code);\n                    }\n                    ;\n                    function is_identifier_char(ch) {\n                        var code = ch.charCodeAt(0);\n                        return is_identifier_start(code) || is_digit(code) || code == 8204 || code == 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);\n                    }\n                    ;\n                    function is_identifier_string(str) {\n                        var i = str.length;\n                        if (i == 0)\n                            return false;\n                        if (!is_identifier_start(str.charCodeAt(0)))\n                            return false;\n                        while (--i >= 0) {\n                            if (!is_identifier_char(str.charAt(i)))\n                                return false;\n                        }\n                        return true;\n                    }\n                    ;\n                    function parse_js_number(num) {\n                        if (RE_HEX_NUMBER.test(num)) {\n                            return parseInt(num.substr(2), 16);\n                        } else if (RE_OCT_NUMBER.test(num)) {\n                            return parseInt(num.substr(1), 8);\n                        } else if (RE_DEC_NUMBER.test(num)) {\n                            return parseFloat(num);\n                        }\n                    }\n                    ;\n                    function JS_Parse_Error(message, line, col, pos) {\n                        this.message = message;\n                        this.line = line;\n                        this.col = col;\n                        this.pos = pos;\n                        this.stack = new Error().stack;\n                    }\n                    ;\n                    JS_Parse_Error.prototype.toString = function () {\n                        return this.message + ' (line: ' + this.line + ', col: ' + this.col + ', pos: ' + this.pos + ')' + '\\n\\n' + this.stack;\n                    };\n                    function js_error(message, filename, line, col, pos) {\n                        throw new JS_Parse_Error(message, line, col, pos);\n                    }\n                    ;\n                    function is_token(token, type, val) {\n                        return token.type == type && (val == null || token.value == val);\n                    }\n                    ;\n                    var EX_EOF = {};\n                    function tokenizer($TEXT, filename, html5_comments) {\n                        var S = {\n                            text: $TEXT.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/\\uFEFF/g, ''),\n                            filename: filename,\n                            pos: 0,\n                            tokpos: 0,\n                            line: 1,\n                            tokline: 0,\n                            col: 0,\n                            tokcol: 0,\n                            newline_before: false,\n                            regex_allowed: false,\n                            comments_before: []\n                        };\n                        function peek() {\n                            return S.text.charAt(S.pos);\n                        }\n                        ;\n                        function next(signal_eof, in_string) {\n                            var ch = S.text.charAt(S.pos++);\n                            if (signal_eof && !ch)\n                                throw EX_EOF;\n                            if (ch == '\\n') {\n                                S.newline_before = S.newline_before || !in_string;\n                                ++S.line;\n                                S.col = 0;\n                            } else {\n                                ++S.col;\n                            }\n                            return ch;\n                        }\n                        ;\n                        function forward(i) {\n                            while (i-- > 0)\n                                next();\n                        }\n                        ;\n                        function looking_at(str) {\n                            return S.text.substr(S.pos, str.length) == str;\n                        }\n                        ;\n                        function find(what, signal_eof) {\n                            var pos = S.text.indexOf(what, S.pos);\n                            if (signal_eof && pos == -1)\n                                throw EX_EOF;\n                            return pos;\n                        }\n                        ;\n                        function start_token() {\n                            S.tokline = S.line;\n                            S.tokcol = S.col;\n                            S.tokpos = S.pos;\n                        }\n                        ;\n                        var prev_was_dot = false;\n                        function token(type, value, is_comment) {\n                            S.regex_allowed = type == 'operator' && !UNARY_POSTFIX(value) || type == 'keyword' && KEYWORDS_BEFORE_EXPRESSION(value) || type == 'punc' && PUNC_BEFORE_EXPRESSION(value);\n                            prev_was_dot = type == 'punc' && value == '.';\n                            var ret = {\n                                type: type,\n                                value: value,\n                                line: S.tokline,\n                                col: S.tokcol,\n                                pos: S.tokpos,\n                                endpos: S.pos,\n                                nlb: S.newline_before,\n                                file: filename\n                            };\n                            if (!is_comment) {\n                                ret.comments_before = S.comments_before;\n                                S.comments_before = [];\n                                for (var i = 0, len = ret.comments_before.length; i < len; i++) {\n                                    ret.nlb = ret.nlb || ret.comments_before[i].nlb;\n                                }\n                            }\n                            S.newline_before = false;\n                            return new AST_Token(ret);\n                        }\n                        ;\n                        function skip_whitespace() {\n                            while (WHITESPACE_CHARS(peek()))\n                                next();\n                        }\n                        ;\n                        function read_while(pred) {\n                            var ret = '', ch, i = 0;\n                            while ((ch = peek()) && pred(ch, i++))\n                                ret += next();\n                            return ret;\n                        }\n                        ;\n                        function parse_error(err) {\n                            js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n                        }\n                        ;\n                        function read_num(prefix) {\n                            var has_e = false, after_e = false, has_x = false, has_dot = prefix == '.';\n                            var num = read_while(function (ch, i) {\n                                var code = ch.charCodeAt(0);\n                                switch (code) {\n                                case 120:\n                                case 88:\n                                    return has_x ? false : has_x = true;\n                                case 101:\n                                case 69:\n                                    return has_x ? true : has_e ? false : has_e = after_e = true;\n                                case 45:\n                                    return after_e || i == 0 && !prefix;\n                                case 43:\n                                    return after_e;\n                                case after_e = false, 46:\n                                    return !has_dot && !has_x && !has_e ? has_dot = true : false;\n                                }\n                                return is_alphanumeric_char(code);\n                            });\n                            if (prefix)\n                                num = prefix + num;\n                            var valid = parse_js_number(num);\n                            if (!isNaN(valid)) {\n                                return token('num', valid);\n                            } else {\n                                parse_error('Invalid syntax: ' + num);\n                            }\n                        }\n                        ;\n                        function read_escaped_char(in_string) {\n                            var ch = next(true, in_string);\n                            switch (ch.charCodeAt(0)) {\n                            case 110:\n                                return '\\n';\n                            case 114:\n                                return '\\r';\n                            case 116:\n                                return '\\t';\n                            case 98:\n                                return '\\b';\n                            case 118:\n                                return '\\x0B';\n                            case 102:\n                                return '\\f';\n                            case 48:\n                                return '\\0';\n                            case 120:\n                                return String.fromCharCode(hex_bytes(2));\n                            case 117:\n                                return String.fromCharCode(hex_bytes(4));\n                            case 10:\n                                return '';\n                            default:\n                                return ch;\n                            }\n                        }\n                        ;\n                        function hex_bytes(n) {\n                            var num = 0;\n                            for (; n > 0; --n) {\n                                var digit = parseInt(next(true), 16);\n                                if (isNaN(digit))\n                                    parse_error('Invalid hex-character pattern in string');\n                                num = num << 4 | digit;\n                            }\n                            return num;\n                        }\n                        ;\n                        var read_string = with_eof_error('Unterminated string constant', function () {\n                            var quote = next(), ret = '';\n                            for (;;) {\n                                var ch = next(true);\n                                if (ch == '\\\\') {\n                                    var octal_len = 0, first = null;\n                                    ch = read_while(function (ch) {\n                                        if (ch >= '0' && ch <= '7') {\n                                            if (!first) {\n                                                first = ch;\n                                                return ++octal_len;\n                                            } else if (first <= '3' && octal_len <= 2)\n                                                return ++octal_len;\n                                            else if (first >= '4' && octal_len <= 1)\n                                                return ++octal_len;\n                                        }\n                                        return false;\n                                    });\n                                    if (octal_len > 0)\n                                        ch = String.fromCharCode(parseInt(ch, 8));\n                                    else\n                                        ch = read_escaped_char(true);\n                                } else if (ch == quote)\n                                    break;\n                                ret += ch;\n                            }\n                            return token('string', ret);\n                        });\n                        function skip_line_comment(type) {\n                            var regex_allowed = S.regex_allowed;\n                            var i = find('\\n'), ret;\n                            if (i == -1) {\n                                ret = S.text.substr(S.pos);\n                                S.pos = S.text.length;\n                            } else {\n                                ret = S.text.substring(S.pos, i);\n                                S.pos = i;\n                            }\n                            S.comments_before.push(token(type, ret, true));\n                            S.regex_allowed = regex_allowed;\n                            return next_token();\n                        }\n                        ;\n                        var skip_multiline_comment = with_eof_error('Unterminated multiline comment', function () {\n                            var regex_allowed = S.regex_allowed;\n                            var i = find('*/', true);\n                            var text = S.text.substring(S.pos, i);\n                            var a = text.split('\\n'), n = a.length;\n                            S.pos = i + 2;\n                            S.line += n - 1;\n                            if (n > 1)\n                                S.col = a[n - 1].length;\n                            else\n                                S.col += a[n - 1].length;\n                            S.col += 2;\n                            var nlb = S.newline_before = S.newline_before || text.indexOf('\\n') >= 0;\n                            S.comments_before.push(token('comment2', text, true));\n                            S.regex_allowed = regex_allowed;\n                            S.newline_before = nlb;\n                            return next_token();\n                        });\n                        function read_name() {\n                            var backslash = false, name = '', ch, escaped = false, hex;\n                            while ((ch = peek()) != null) {\n                                if (!backslash) {\n                                    if (ch == '\\\\')\n                                        escaped = backslash = true, next();\n                                    else if (is_identifier_char(ch))\n                                        name += next();\n                                    else\n                                        break;\n                                } else {\n                                    if (ch != 'u')\n                                        parse_error('Expecting UnicodeEscapeSequence -- uXXXX');\n                                    ch = read_escaped_char();\n                                    if (!is_identifier_char(ch))\n                                        parse_error('Unicode char: ' + ch.charCodeAt(0) + ' is not valid in identifier');\n                                    name += ch;\n                                    backslash = false;\n                                }\n                            }\n                            if (KEYWORDS(name) && escaped) {\n                                hex = name.charCodeAt(0).toString(16).toUpperCase();\n                                name = '\\\\u' + '0000'.substr(hex.length) + hex + name.slice(1);\n                            }\n                            return name;\n                        }\n                        ;\n                        var read_regexp = with_eof_error('Unterminated regular expression', function (regexp) {\n                            var prev_backslash = false, ch, in_class = false;\n                            while (ch = next(true))\n                                if (prev_backslash) {\n                                    regexp += '\\\\' + ch;\n                                    prev_backslash = false;\n                                } else if (ch == '[') {\n                                    in_class = true;\n                                    regexp += ch;\n                                } else if (ch == ']' && in_class) {\n                                    in_class = false;\n                                    regexp += ch;\n                                } else if (ch == '/' && !in_class) {\n                                    break;\n                                } else if (ch == '\\\\') {\n                                    prev_backslash = true;\n                                } else {\n                                    regexp += ch;\n                                }\n                            var mods = read_name();\n                            return token('regexp', new RegExp(regexp, mods));\n                        });\n                        function read_operator(prefix) {\n                            function grow(op) {\n                                if (!peek())\n                                    return op;\n                                var bigger = op + peek();\n                                if (OPERATORS(bigger)) {\n                                    next();\n                                    return grow(bigger);\n                                } else {\n                                    return op;\n                                }\n                            }\n                            ;\n                            return token('operator', grow(prefix || next()));\n                        }\n                        ;\n                        function handle_slash() {\n                            next();\n                            switch (peek()) {\n                            case '/':\n                                next();\n                                return skip_line_comment('comment1');\n                            case '*':\n                                next();\n                                return skip_multiline_comment();\n                            }\n                            return S.regex_allowed ? read_regexp('') : read_operator('/');\n                        }\n                        ;\n                        function handle_dot() {\n                            next();\n                            return is_digit(peek().charCodeAt(0)) ? read_num('.') : token('punc', '.');\n                        }\n                        ;\n                        function read_word() {\n                            var word = read_name();\n                            if (prev_was_dot)\n                                return token('name', word);\n                            return KEYWORDS_ATOM(word) ? token('atom', word) : !KEYWORDS(word) ? token('name', word) : OPERATORS(word) ? token('operator', word) : token('keyword', word);\n                        }\n                        ;\n                        function with_eof_error(eof_error, cont) {\n                            return function (x) {\n                                try {\n                                    return cont(x);\n                                } catch (ex) {\n                                    if (ex === EX_EOF)\n                                        parse_error(eof_error);\n                                    else\n                                        throw ex;\n                                }\n                            };\n                        }\n                        ;\n                        function next_token(force_regexp) {\n                            if (force_regexp != null)\n                                return read_regexp(force_regexp);\n                            skip_whitespace();\n                            start_token();\n                            if (html5_comments) {\n                                if (looking_at('<!--')) {\n                                    forward(4);\n                                    return skip_line_comment('comment3');\n                                }\n                                if (looking_at('-->') && S.newline_before) {\n                                    forward(3);\n                                    return skip_line_comment('comment4');\n                                }\n                            }\n                            var ch = peek();\n                            if (!ch)\n                                return token('eof');\n                            var code = ch.charCodeAt(0);\n                            switch (code) {\n                            case 34:\n                            case 39:\n                                return read_string();\n                            case 46:\n                                return handle_dot();\n                            case 47:\n                                return handle_slash();\n                            }\n                            if (is_digit(code))\n                                return read_num();\n                            if (PUNC_CHARS(ch))\n                                return token('punc', next());\n                            if (OPERATOR_CHARS(ch))\n                                return read_operator();\n                            if (code == 92 || is_identifier_start(code))\n                                return read_word();\n                            parse_error(\"Unexpected character '\" + ch + \"'\");\n                        }\n                        ;\n                        next_token.context = function (nc) {\n                            if (nc)\n                                S = nc;\n                            return S;\n                        };\n                        return next_token;\n                    }\n                    ;\n                    var UNARY_PREFIX = makePredicate([\n                        'typeof',\n                        'void',\n                        'delete',\n                        '--',\n                        '++',\n                        '!',\n                        '~',\n                        '-',\n                        '+'\n                    ]);\n                    var UNARY_POSTFIX = makePredicate([\n                        '--',\n                        '++'\n                    ]);\n                    var ASSIGNMENT = makePredicate([\n                        '=',\n                        '+=',\n                        '-=',\n                        '/=',\n                        '*=',\n                        '%=',\n                        '>>=',\n                        '<<=',\n                        '>>>=',\n                        '|=',\n                        '^=',\n                        '&='\n                    ]);\n                    var PRECEDENCE = function (a, ret) {\n                        for (var i = 0; i < a.length; ++i) {\n                            var b = a[i];\n                            for (var j = 0; j < b.length; ++j) {\n                                ret[b[j]] = i + 1;\n                            }\n                        }\n                        return ret;\n                    }([\n                        ['||'],\n                        ['&&'],\n                        ['|'],\n                        ['^'],\n                        ['&'],\n                        [\n                            '==',\n                            '===',\n                            '!=',\n                            '!=='\n                        ],\n                        [\n                            '<',\n                            '>',\n                            '<=',\n                            '>=',\n                            'in',\n                            'instanceof'\n                        ],\n                        [\n                            '>>',\n                            '<<',\n                            '>>>'\n                        ],\n                        [\n                            '+',\n                            '-'\n                        ],\n                        [\n                            '*',\n                            '/',\n                            '%'\n                        ]\n                    ], {});\n                    var STATEMENTS_WITH_LABELS = array_to_hash([\n                        'fo' + 'r',\n                        'do',\n                        'while',\n                        'switch'\n                    ]);\n                    var ATOMIC_START_TOKEN = array_to_hash([\n                        'atom',\n                        'num',\n                        'string',\n                        'regexp',\n                        'name'\n                    ]);\n                    function parse($TEXT, options) {\n                        options = defaults(options, {\n                            strict: false,\n                            filename: null,\n                            toplevel: null,\n                            expression: false,\n                            html5_comments: true\n                        });\n                        var S = {\n                            input: typeof $TEXT == 'string' ? tokenizer($TEXT, options.filename, options.html5_comments) : $TEXT,\n                            token: null,\n                            prev: null,\n                            peeked: null,\n                            in_function: 0,\n                            in_directives: true,\n                            in_loop: 0,\n                            labels: []\n                        };\n                        S.token = next();\n                        function is(type, value) {\n                            return is_token(S.token, type, value);\n                        }\n                        ;\n                        function peek() {\n                            return S.peeked || (S.peeked = S.input());\n                        }\n                        ;\n                        function next() {\n                            S.prev = S.token;\n                            if (S.peeked) {\n                                S.token = S.peeked;\n                                S.peeked = null;\n                            } else {\n                                S.token = S.input();\n                            }\n                            S.in_directives = S.in_directives && (S.token.type == 'string' || is('punc', ';'));\n                            return S.token;\n                        }\n                        ;\n                        function prev() {\n                            return S.prev;\n                        }\n                        ;\n                        function croak(msg, line, col, pos) {\n                            var ctx = S.input.context();\n                            js_error(msg, ctx.filename, line != null ? line : ctx.tokline, col != null ? col : ctx.tokcol, pos != null ? pos : ctx.tokpos);\n                        }\n                        ;\n                        function token_error(token, msg) {\n                            croak(msg, token.line, token.col);\n                        }\n                        ;\n                        function unexpected(token) {\n                            if (token == null)\n                                token = S.token;\n                            token_error(token, 'Unexpected token: ' + token.type + ' (' + token.value + ')');\n                        }\n                        ;\n                        function expect_token(type, val) {\n                            if (is(type, val)) {\n                                return next();\n                            }\n                            token_error(S.token, 'Unexpected token ' + S.token.type + ' \\xAB' + S.token.value + '\\xBB' + ', expected ' + type + ' \\xAB' + val + '\\xBB');\n                        }\n                        ;\n                        function expect(punc) {\n                            return expect_token('punc', punc);\n                        }\n                        ;\n                        function can_insert_semicolon() {\n                            return !options.strict && (S.token.nlb || is('eof') || is('punc', '}'));\n                        }\n                        ;\n                        function semicolon() {\n                            if (is('punc', ';'))\n                                next();\n                            else if (!can_insert_semicolon())\n                                unexpected();\n                        }\n                        ;\n                        function parenthesised() {\n                            expect('(');\n                            var exp = expression(true);\n                            expect(')');\n                            return exp;\n                        }\n                        ;\n                        function embed_tokens(parser) {\n                            return function () {\n                                var start = S.token;\n                                var expr = parser();\n                                var end = prev();\n                                expr.start = start;\n                                expr.end = end;\n                                return expr;\n                            };\n                        }\n                        ;\n                        function handle_regexp() {\n                            if (is('operator', '/') || is('operator', '/=')) {\n                                S.peeked = null;\n                                S.token = S.input(S.token.value.substr(1));\n                            }\n                        }\n                        ;\n                        var statement = embed_tokens(function () {\n                            var tmp;\n                            handle_regexp();\n                            switch (S.token.type) {\n                            case 'string':\n                                var dir = S.in_directives, stat = simple_statement();\n                                if (dir && stat.body instanceof AST_String && !is('punc', ','))\n                                    return new AST_Directive({ value: stat.body.value });\n                                return stat;\n                            case 'num':\n                            case 'regexp':\n                            case 'operator':\n                            case 'atom':\n                                return simple_statement();\n                            case 'name':\n                                return is_token(peek(), 'punc', ':') ? labeled_statement() : simple_statement();\n                            case 'punc':\n                                switch (S.token.value) {\n                                case '{':\n                                    return new AST_BlockStatement({\n                                        start: S.token,\n                                        body: block_(),\n                                        end: prev()\n                                    });\n                                case '[':\n                                case '(':\n                                    return simple_statement();\n                                case ';':\n                                    next();\n                                    return new AST_EmptyStatement();\n                                default:\n                                    unexpected();\n                                }\n                            case 'keyword':\n                                switch (tmp = S.token.value, next(), tmp) {\n                                case 'break':\n                                    return break_cont(AST_Break);\n                                case 'continue':\n                                    return break_cont(AST_Continue);\n                                case 'debugger':\n                                    semicolon();\n                                    return new AST_Debugger();\n                                case 'do':\n                                    return new AST_Do({\n                                        body: in_loop(statement),\n                                        condition: (expect_token('keyword', 'while'), tmp = parenthesised(), semicolon(), tmp)\n                                    });\n                                case 'while':\n                                    return new AST_While({\n                                        condition: parenthesised(),\n                                        body: in_loop(statement)\n                                    });\n                                case 'fo' + 'r':\n                                    return for_();\n                                case 'function':\n                                    return function_(AST_Defun);\n                                case 'if':\n                                    return if_();\n                                case 'return':\n                                    if (S.in_function == 0)\n                                        croak(\"'return' outside of function\");\n                                    return new AST_Return({ value: is('punc', ';') ? (next(), null) : can_insert_semicolon() ? null : (tmp = expression(true), semicolon(), tmp) });\n                                case 'switch':\n                                    return new AST_Switch({\n                                        expression: parenthesised(),\n                                        body: in_loop(switch_body_)\n                                    });\n                                case 'throw':\n                                    if (S.token.nlb)\n                                        croak(\"Illegal newline after 'throw'\");\n                                    return new AST_Throw({ value: (tmp = expression(true), semicolon(), tmp) });\n                                case 'try':\n                                    return try_();\n                                case 'var':\n                                    return tmp = var_(), semicolon(), tmp;\n                                case 'const':\n                                    return tmp = const_(), semicolon(), tmp;\n                                case 'with':\n                                    return new AST_With({\n                                        expression: parenthesised(),\n                                        body: statement()\n                                    });\n                                default:\n                                    unexpected();\n                                }\n                            }\n                        });\n                        function labeled_statement() {\n                            var label = as_symbol(AST_Label);\n                            if (find_if(function (l) {\n                                    return l.name == label.name;\n                                }, S.labels)) {\n                                croak('Label ' + label.name + ' defined twice');\n                            }\n                            expect(':');\n                            S.labels.push(label);\n                            var stat = statement();\n                            S.labels.pop();\n                            if (!(stat instanceof AST_IterationStatement)) {\n                                label.references.forEach(function (ref) {\n                                    if (ref instanceof AST_Continue) {\n                                        ref = ref.label.start;\n                                        croak('Continue label `' + label.name + '` refers to non-IterationStatement.', ref.line, ref.col, ref.pos);\n                                    }\n                                });\n                            }\n                            return new AST_LabeledStatement({\n                                body: stat,\n                                label: label\n                            });\n                        }\n                        ;\n                        function simple_statement(tmp) {\n                            return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });\n                        }\n                        ;\n                        function break_cont(type) {\n                            var label = null, ldef;\n                            if (!can_insert_semicolon()) {\n                                label = as_symbol(AST_LabelRef, true);\n                            }\n                            if (label != null) {\n                                ldef = find_if(function (l) {\n                                    return l.name == label.name;\n                                }, S.labels);\n                                if (!ldef)\n                                    croak('Undefined label ' + label.name);\n                                label.thedef = ldef;\n                            } else if (S.in_loop == 0)\n                                croak(type.TYPE + ' not inside a loop or switch');\n                            semicolon();\n                            var stat = new type({ label: label });\n                            if (ldef)\n                                ldef.references.push(stat);\n                            return stat;\n                        }\n                        ;\n                        function for_() {\n                            expect('(');\n                            var init = null;\n                            if (!is('punc', ';')) {\n                                init = is('keyword', 'var') ? (next(), var_(true)) : expression(true, true);\n                                if (is('operator', 'in')) {\n                                    if (init instanceof AST_Var && init.definitions.length > 1)\n                                        croak('Only one variable declaration allowed in for..in loop');\n                                    next();\n                                    return for_in(init);\n                                }\n                            }\n                            return regular_for(init);\n                        }\n                        ;\n                        function regular_for(init) {\n                            expect(';');\n                            var test = is('punc', ';') ? null : expression(true);\n                            expect(';');\n                            var step = is('punc', ')') ? null : expression(true);\n                            expect(')');\n                            return new AST_For({\n                                init: init,\n                                condition: test,\n                                step: step,\n                                body: in_loop(statement)\n                            });\n                        }\n                        ;\n                        function for_in(init) {\n                            var lhs = init instanceof AST_Var ? init.definitions[0].name : null;\n                            var obj = expression(true);\n                            expect(')');\n                            return new AST_ForIn({\n                                init: init,\n                                name: lhs,\n                                object: obj,\n                                body: in_loop(statement)\n                            });\n                        }\n                        ;\n                        var function_ = function (ctor) {\n                            var in_statement = ctor === AST_Defun;\n                            var name = is('name') ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;\n                            if (in_statement && !name)\n                                unexpected();\n                            expect('(');\n                            return new ctor({\n                                name: name,\n                                argnames: function (first, a) {\n                                    while (!is('punc', ')')) {\n                                        if (first)\n                                            first = false;\n                                        else\n                                            expect(',');\n                                        a.push(as_symbol(AST_SymbolFunarg));\n                                    }\n                                    next();\n                                    return a;\n                                }(true, []),\n                                body: function (loop, labels) {\n                                    ++S.in_function;\n                                    S.in_directives = true;\n                                    S.in_loop = 0;\n                                    S.labels = [];\n                                    var a = block_();\n                                    --S.in_function;\n                                    S.in_loop = loop;\n                                    S.labels = labels;\n                                    return a;\n                                }(S.in_loop, S.labels)\n                            });\n                        };\n                        function if_() {\n                            var cond = parenthesised(), body = statement(), belse = null;\n                            if (is('keyword', 'else')) {\n                                next();\n                                belse = statement();\n                            }\n                            return new AST_If({\n                                condition: cond,\n                                body: body,\n                                alternative: belse\n                            });\n                        }\n                        ;\n                        function block_() {\n                            expect('{');\n                            var a = [];\n                            while (!is('punc', '}')) {\n                                if (is('eof'))\n                                    unexpected();\n                                a.push(statement());\n                            }\n                            next();\n                            return a;\n                        }\n                        ;\n                        function switch_body_() {\n                            expect('{');\n                            var a = [], cur = null, branch = null, tmp;\n                            while (!is('punc', '}')) {\n                                if (is('eof'))\n                                    unexpected();\n                                if (is('keyword', 'case')) {\n                                    if (branch)\n                                        branch.end = prev();\n                                    cur = [];\n                                    branch = new AST_Case({\n                                        start: (tmp = S.token, next(), tmp),\n                                        expression: expression(true),\n                                        body: cur\n                                    });\n                                    a.push(branch);\n                                    expect(':');\n                                } else if (is('keyword', 'default')) {\n                                    if (branch)\n                                        branch.end = prev();\n                                    cur = [];\n                                    branch = new AST_Default({\n                                        start: (tmp = S.token, next(), expect(':'), tmp),\n                                        body: cur\n                                    });\n                                    a.push(branch);\n                                } else {\n                                    if (!cur)\n                                        unexpected();\n                                    cur.push(statement());\n                                }\n                            }\n                            if (branch)\n                                branch.end = prev();\n                            next();\n                            return a;\n                        }\n                        ;\n                        function try_() {\n                            var body = block_(), bcatch = null, bfinally = null;\n                            if (is('keyword', 'catch')) {\n                                var start = S.token;\n                                next();\n                                expect('(');\n                                var name = as_symbol(AST_SymbolCatch);\n                                expect(')');\n                                bcatch = new AST_Catch({\n                                    start: start,\n                                    argname: name,\n                                    body: block_(),\n                                    end: prev()\n                                });\n                            }\n                            if (is('keyword', 'finally')) {\n                                var start = S.token;\n                                next();\n                                bfinally = new AST_Finally({\n                                    start: start,\n                                    body: block_(),\n                                    end: prev()\n                                });\n                            }\n                            if (!bcatch && !bfinally)\n                                croak('Missing catch/finally blocks');\n                            return new AST_Try({\n                                body: body,\n                                bcatch: bcatch,\n                                bfinally: bfinally\n                            });\n                        }\n                        ;\n                        function vardefs(no_in, in_const) {\n                            var a = [];\n                            for (;;) {\n                                a.push(new AST_VarDef({\n                                    start: S.token,\n                                    name: as_symbol(in_const ? AST_SymbolConst : AST_SymbolVar),\n                                    value: is('operator', '=') ? (next(), expression(false, no_in)) : null,\n                                    end: prev()\n                                }));\n                                if (!is('punc', ','))\n                                    break;\n                                next();\n                            }\n                            return a;\n                        }\n                        ;\n                        var var_ = function (no_in) {\n                            return new AST_Var({\n                                start: prev(),\n                                definitions: vardefs(no_in, false),\n                                end: prev()\n                            });\n                        };\n                        var const_ = function () {\n                            return new AST_Const({\n                                start: prev(),\n                                definitions: vardefs(false, true),\n                                end: prev()\n                            });\n                        };\n                        var new_ = function () {\n                            var start = S.token;\n                            expect_token('operator', 'new');\n                            var newexp = expr_atom(false), args;\n                            if (is('punc', '(')) {\n                                next();\n                                args = expr_list(')');\n                            } else {\n                                args = [];\n                            }\n                            return subscripts(new AST_New({\n                                start: start,\n                                expression: newexp,\n                                args: args,\n                                end: prev()\n                            }), true);\n                        };\n                        function as_atom_node() {\n                            var tok = S.token, ret;\n                            switch (tok.type) {\n                            case 'name':\n                            case 'keyword':\n                                ret = _make_symbol(AST_SymbolRef);\n                                break;\n                            case 'num':\n                                ret = new AST_Number({\n                                    start: tok,\n                                    end: tok,\n                                    value: tok.value\n                                });\n                                break;\n                            case 'string':\n                                ret = new AST_String({\n                                    start: tok,\n                                    end: tok,\n                                    value: tok.value\n                                });\n                                break;\n                            case 'regexp':\n                                ret = new AST_RegExp({\n                                    start: tok,\n                                    end: tok,\n                                    value: tok.value\n                                });\n                                break;\n                            case 'atom':\n                                switch (tok.value) {\n                                case 'false':\n                                    ret = new AST_False({\n                                        start: tok,\n                                        end: tok\n                                    });\n                                    break;\n                                case 'true':\n                                    ret = new AST_True({\n                                        start: tok,\n                                        end: tok\n                                    });\n                                    break;\n                                case 'null':\n                                    ret = new AST_Null({\n                                        start: tok,\n                                        end: tok\n                                    });\n                                    break;\n                                }\n                                break;\n                            }\n                            next();\n                            return ret;\n                        }\n                        ;\n                        var expr_atom = function (allow_calls) {\n                            if (is('operator', 'new')) {\n                                return new_();\n                            }\n                            var start = S.token;\n                            if (is('punc')) {\n                                switch (start.value) {\n                                case '(':\n                                    next();\n                                    var ex = expression(true);\n                                    ex.start = start;\n                                    ex.end = S.token;\n                                    expect(')');\n                                    return subscripts(ex, allow_calls);\n                                case '[':\n                                    return subscripts(array_(), allow_calls);\n                                case '{':\n                                    return subscripts(object_(), allow_calls);\n                                }\n                                unexpected();\n                            }\n                            if (is('keyword', 'function')) {\n                                next();\n                                var func = function_(AST_Function);\n                                func.start = start;\n                                func.end = prev();\n                                return subscripts(func, allow_calls);\n                            }\n                            if (ATOMIC_START_TOKEN[S.token.type]) {\n                                return subscripts(as_atom_node(), allow_calls);\n                            }\n                            unexpected();\n                        };\n                        function expr_list(closing, allow_trailing_comma, allow_empty) {\n                            var first = true, a = [];\n                            while (!is('punc', closing)) {\n                                if (first)\n                                    first = false;\n                                else\n                                    expect(',');\n                                if (allow_trailing_comma && is('punc', closing))\n                                    break;\n                                if (is('punc', ',') && allow_empty) {\n                                    a.push(new AST_Hole({\n                                        start: S.token,\n                                        end: S.token\n                                    }));\n                                } else {\n                                    a.push(expression(false));\n                                }\n                            }\n                            next();\n                            return a;\n                        }\n                        ;\n                        var array_ = embed_tokens(function () {\n                            expect('[');\n                            return new AST_Array({ elements: expr_list(']', !options.strict, true) });\n                        });\n                        var object_ = embed_tokens(function () {\n                            expect('{');\n                            var first = true, a = [];\n                            while (!is('punc', '}')) {\n                                if (first)\n                                    first = false;\n                                else\n                                    expect(',');\n                                if (!options.strict && is('punc', '}'))\n                                    break;\n                                var start = S.token;\n                                var type = start.type;\n                                var name = as_property_name();\n                                if (type == 'name' && !is('punc', ':')) {\n                                    if (name == 'get') {\n                                        a.push(new AST_ObjectGetter({\n                                            start: start,\n                                            key: as_atom_node(),\n                                            value: function_(AST_Accessor),\n                                            end: prev()\n                                        }));\n                                        continue;\n                                    }\n                                    if (name == 'set') {\n                                        a.push(new AST_ObjectSetter({\n                                            start: start,\n                                            key: as_atom_node(),\n                                            value: function_(AST_Accessor),\n                                            end: prev()\n                                        }));\n                                        continue;\n                                    }\n                                }\n                                expect(':');\n                                a.push(new AST_ObjectKeyVal({\n                                    start: start,\n                                    key: name,\n                                    value: expression(false),\n                                    end: prev()\n                                }));\n                            }\n                            next();\n                            return new AST_Object({ properties: a });\n                        });\n                        function as_property_name() {\n                            var tmp = S.token;\n                            next();\n                            switch (tmp.type) {\n                            case 'num':\n                            case 'string':\n                            case 'name':\n                            case 'operator':\n                            case 'keyword':\n                            case 'atom':\n                                return tmp.value;\n                            default:\n                                unexpected();\n                            }\n                        }\n                        ;\n                        function as_name() {\n                            var tmp = S.token;\n                            next();\n                            switch (tmp.type) {\n                            case 'name':\n                            case 'operator':\n                            case 'keyword':\n                            case 'atom':\n                                return tmp.value;\n                            default:\n                                unexpected();\n                            }\n                        }\n                        ;\n                        function _make_symbol(type) {\n                            var name = S.token.value;\n                            return new (name == 'this' ? AST_This : type)({\n                                name: String(name),\n                                start: S.token,\n                                end: S.token\n                            });\n                        }\n                        ;\n                        function as_symbol(type, noerror) {\n                            if (!is('name')) {\n                                if (!noerror)\n                                    croak('Name expected');\n                                return null;\n                            }\n                            var sym = _make_symbol(type);\n                            next();\n                            return sym;\n                        }\n                        ;\n                        var subscripts = function (expr, allow_calls) {\n                            var start = expr.start;\n                            if (is('punc', '.')) {\n                                next();\n                                return subscripts(new AST_Dot({\n                                    start: start,\n                                    expression: expr,\n                                    property: as_name(),\n                                    end: prev()\n                                }), allow_calls);\n                            }\n                            if (is('punc', '[')) {\n                                next();\n                                var prop = expression(true);\n                                expect(']');\n                                return subscripts(new AST_Sub({\n                                    start: start,\n                                    expression: expr,\n                                    property: prop,\n                                    end: prev()\n                                }), allow_calls);\n                            }\n                            if (allow_calls && is('punc', '(')) {\n                                next();\n                                return subscripts(new AST_Call({\n                                    start: start,\n                                    expression: expr,\n                                    args: expr_list(')'),\n                                    end: prev()\n                                }), true);\n                            }\n                            return expr;\n                        };\n                        var maybe_unary = function (allow_calls) {\n                            var start = S.token;\n                            if (is('operator') && UNARY_PREFIX(start.value)) {\n                                next();\n                                handle_regexp();\n                                var ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls));\n                                ex.start = start;\n                                ex.end = prev();\n                                return ex;\n                            }\n                            var val = expr_atom(allow_calls);\n                            while (is('operator') && UNARY_POSTFIX(S.token.value) && !S.token.nlb) {\n                                val = make_unary(AST_UnaryPostfix, S.token.value, val);\n                                val.start = start;\n                                val.end = S.token;\n                                next();\n                            }\n                            return val;\n                        };\n                        function make_unary(ctor, op, expr) {\n                            if ((op == '++' || op == '--') && !is_assignable(expr))\n                                croak('Invalid use of ' + op + ' operator');\n                            return new ctor({\n                                operator: op,\n                                expression: expr\n                            });\n                        }\n                        ;\n                        var expr_op = function (left, min_prec, no_in) {\n                            var op = is('operator') ? S.token.value : null;\n                            if (op == 'in' && no_in)\n                                op = null;\n                            var prec = op != null ? PRECEDENCE[op] : null;\n                            if (prec != null && prec > min_prec) {\n                                next();\n                                var right = expr_op(maybe_unary(true), prec, no_in);\n                                return expr_op(new AST_Binary({\n                                    start: left.start,\n                                    left: left,\n                                    operator: op,\n                                    right: right,\n                                    end: right.end\n                                }), min_prec, no_in);\n                            }\n                            return left;\n                        };\n                        function expr_ops(no_in) {\n                            return expr_op(maybe_unary(true), 0, no_in);\n                        }\n                        ;\n                        var maybe_conditional = function (no_in) {\n                            var start = S.token;\n                            var expr = expr_ops(no_in);\n                            if (is('operator', '?')) {\n                                next();\n                                var yes = expression(false);\n                                expect(':');\n                                return new AST_Conditional({\n                                    start: start,\n                                    condition: expr,\n                                    consequent: yes,\n                                    alternative: expression(false, no_in),\n                                    end: prev()\n                                });\n                            }\n                            return expr;\n                        };\n                        function is_assignable(expr) {\n                            if (!options.strict)\n                                return true;\n                            if (expr instanceof AST_This)\n                                return false;\n                            return expr instanceof AST_PropAccess || expr instanceof AST_Symbol;\n                        }\n                        ;\n                        var maybe_assign = function (no_in) {\n                            var start = S.token;\n                            var left = maybe_conditional(no_in), val = S.token.value;\n                            if (is('operator') && ASSIGNMENT(val)) {\n                                if (is_assignable(left)) {\n                                    next();\n                                    return new AST_Assign({\n                                        start: start,\n                                        left: left,\n                                        operator: val,\n                                        right: maybe_assign(no_in),\n                                        end: prev()\n                                    });\n                                }\n                                croak('Invalid assignment');\n                            }\n                            return left;\n                        };\n                        var expression = function (commas, no_in) {\n                            var start = S.token;\n                            var expr = maybe_assign(no_in);\n                            if (commas && is('punc', ',')) {\n                                next();\n                                return new AST_Seq({\n                                    start: start,\n                                    car: expr,\n                                    cdr: expression(true, no_in),\n                                    end: peek()\n                                });\n                            }\n                            return expr;\n                        };\n                        function in_loop(cont) {\n                            ++S.in_loop;\n                            var ret = cont();\n                            --S.in_loop;\n                            return ret;\n                        }\n                        ;\n                        if (options.expression) {\n                            return expression(true);\n                        }\n                        return function () {\n                            var start = S.token;\n                            var body = [];\n                            while (!is('eof'))\n                                body.push(statement());\n                            var end = prev();\n                            var toplevel = options.toplevel;\n                            if (toplevel) {\n                                toplevel.body = toplevel.body.concat(body);\n                                toplevel.end = end;\n                            } else {\n                                toplevel = new AST_Toplevel({\n                                    start: start,\n                                    body: body,\n                                    end: end\n                                });\n                            }\n                            return toplevel;\n                        }();\n                    }\n                    ;\n                    function TreeTransformer(before, after) {\n                        TreeWalker.call(this);\n                        this.before = before;\n                        this.after = after;\n                    }\n                    TreeTransformer.prototype = new TreeWalker();\n                    (function (undefined) {\n                        function _(node, descend) {\n                            node.DEFMETHOD('transform', function (tw, in_list) {\n                                var x, y;\n                                tw.push(this);\n                                if (tw.before)\n                                    x = tw.before(this, descend, in_list);\n                                if (x === undefined) {\n                                    if (!tw.after) {\n                                        x = this;\n                                        descend(x, tw);\n                                    } else {\n                                        tw.stack[tw.stack.length - 1] = x = this.clone();\n                                        descend(x, tw);\n                                        y = tw.after(x, in_list);\n                                        if (y !== undefined)\n                                            x = y;\n                                    }\n                                }\n                                tw.pop();\n                                return x;\n                            });\n                        }\n                        ;\n                        function do_list(list, tw) {\n                            return MAP(list, function (node) {\n                                return node.transform(tw, true);\n                            });\n                        }\n                        ;\n                        _(AST_Node, noop);\n                        _(AST_LabeledStatement, function (self, tw) {\n                            self.label = self.label.transform(tw);\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_SimpleStatement, function (self, tw) {\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_Block, function (self, tw) {\n                            self.body = do_list(self.body, tw);\n                        });\n                        _(AST_DWLoop, function (self, tw) {\n                            self.condition = self.condition.transform(tw);\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_For, function (self, tw) {\n                            if (self.init)\n                                self.init = self.init.transform(tw);\n                            if (self.condition)\n                                self.condition = self.condition.transform(tw);\n                            if (self.step)\n                                self.step = self.step.transform(tw);\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_ForIn, function (self, tw) {\n                            self.init = self.init.transform(tw);\n                            self.object = self.object.transform(tw);\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_With, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                            self.body = self.body.transform(tw);\n                        });\n                        _(AST_Exit, function (self, tw) {\n                            if (self.value)\n                                self.value = self.value.transform(tw);\n                        });\n                        _(AST_LoopControl, function (self, tw) {\n                            if (self.label)\n                                self.label = self.label.transform(tw);\n                        });\n                        _(AST_If, function (self, tw) {\n                            self.condition = self.condition.transform(tw);\n                            self.body = self.body.transform(tw);\n                            if (self.alternative)\n                                self.alternative = self.alternative.transform(tw);\n                        });\n                        _(AST_Switch, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                            self.body = do_list(self.body, tw);\n                        });\n                        _(AST_Case, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                            self.body = do_list(self.body, tw);\n                        });\n                        _(AST_Try, function (self, tw) {\n                            self.body = do_list(self.body, tw);\n                            if (self.bcatch)\n                                self.bcatch = self.bcatch.transform(tw);\n                            if (self.bfinally)\n                                self.bfinally = self.bfinally.transform(tw);\n                        });\n                        _(AST_Catch, function (self, tw) {\n                            self.argname = self.argname.transform(tw);\n                            self.body = do_list(self.body, tw);\n                        });\n                        _(AST_Definitions, function (self, tw) {\n                            self.definitions = do_list(self.definitions, tw);\n                        });\n                        _(AST_VarDef, function (self, tw) {\n                            self.name = self.name.transform(tw);\n                            if (self.value)\n                                self.value = self.value.transform(tw);\n                        });\n                        _(AST_Lambda, function (self, tw) {\n                            if (self.name)\n                                self.name = self.name.transform(tw);\n                            self.argnames = do_list(self.argnames, tw);\n                            self.body = do_list(self.body, tw);\n                        });\n                        _(AST_Call, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                            self.args = do_list(self.args, tw);\n                        });\n                        _(AST_Seq, function (self, tw) {\n                            self.car = self.car.transform(tw);\n                            self.cdr = self.cdr.transform(tw);\n                        });\n                        _(AST_Dot, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                        });\n                        _(AST_Sub, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                            self.property = self.property.transform(tw);\n                        });\n                        _(AST_Unary, function (self, tw) {\n                            self.expression = self.expression.transform(tw);\n                        });\n                        _(AST_Binary, function (self, tw) {\n                            self.left = self.left.transform(tw);\n                            self.right = self.right.transform(tw);\n                        });\n                        _(AST_Conditional, function (self, tw) {\n                            self.condition = self.condition.transform(tw);\n                            self.consequent = self.consequent.transform(tw);\n                            self.alternative = self.alternative.transform(tw);\n                        });\n                        _(AST_Array, function (self, tw) {\n                            self.elements = do_list(self.elements, tw);\n                        });\n                        _(AST_Object, function (self, tw) {\n                            self.properties = do_list(self.properties, tw);\n                        });\n                        _(AST_ObjectProperty, function (self, tw) {\n                            self.value = self.value.transform(tw);\n                        });\n                    }());\n                    function SymbolDef(scope, index, orig) {\n                        this.name = orig.name;\n                        this.orig = [orig];\n                        this.scope = scope;\n                        this.references = [];\n                        this.global = false;\n                        this.mangled_name = null;\n                        this.undeclared = false;\n                        this.constant = false;\n                        this.index = index;\n                    }\n                    ;\n                    SymbolDef.prototype = {\n                        unmangleable: function (options) {\n                            return this.global && !(options && options.toplevel) || this.undeclared || !(options && options.eval) && (this.scope.uses_eval || this.scope.uses_with);\n                        },\n                        mangle: function (options) {\n                            if (!this.mangled_name && !this.unmangleable(options)) {\n                                var s = this.scope;\n                                if (!options.screw_ie8 && this.orig[0] instanceof AST_SymbolLambda)\n                                    s = s.parent_scope;\n                                this.mangled_name = s.next_mangled(options, this);\n                            }\n                        }\n                    };\n                    AST_Toplevel.DEFMETHOD('figure_out_scope', function (options) {\n                        options = defaults(options, { screw_ie8: false });\n                        var self = this;\n                        var scope = self.parent_scope = null;\n                        var defun = null;\n                        var nesting = 0;\n                        var tw = new TreeWalker(function (node, descend) {\n                            if (options.screw_ie8 && node instanceof AST_Catch) {\n                                var save_scope = scope;\n                                scope = new AST_Scope(node);\n                                scope.init_scope_vars(nesting);\n                                scope.parent_scope = save_scope;\n                                descend();\n                                scope = save_scope;\n                                return true;\n                            }\n                            if (node instanceof AST_Scope) {\n                                node.init_scope_vars(nesting);\n                                var save_scope = node.parent_scope = scope;\n                                var save_defun = defun;\n                                defun = scope = node;\n                                ++nesting;\n                                descend();\n                                --nesting;\n                                scope = save_scope;\n                                defun = save_defun;\n                                return true;\n                            }\n                            if (node instanceof AST_Directive) {\n                                node.scope = scope;\n                                push_uniq(scope.directives, node.value);\n                                return true;\n                            }\n                            if (node instanceof AST_With) {\n                                for (var s = scope; s; s = s.parent_scope)\n                                    s.uses_with = true;\n                                return;\n                            }\n                            if (node instanceof AST_Symbol) {\n                                node.scope = scope;\n                            }\n                            if (node instanceof AST_SymbolLambda) {\n                                defun.def_function(node);\n                            } else if (node instanceof AST_SymbolDefun) {\n                                (node.scope = defun.parent_scope).def_function(node);\n                            } else if (node instanceof AST_SymbolVar || node instanceof AST_SymbolConst) {\n                                var def = defun.def_variable(node);\n                                def.constant = node instanceof AST_SymbolConst;\n                                def.init = tw.parent().value;\n                            } else if (node instanceof AST_SymbolCatch) {\n                                (options.screw_ie8 ? scope : defun).def_variable(node);\n                            }\n                        });\n                        self.walk(tw);\n                        var func = null;\n                        var globals = self.globals = new Dictionary();\n                        var tw = new TreeWalker(function (node, descend) {\n                            if (node instanceof AST_Lambda) {\n                                var prev_func = func;\n                                func = node;\n                                descend();\n                                func = prev_func;\n                                return true;\n                            }\n                            if (node instanceof AST_SymbolRef) {\n                                var name = node.name;\n                                var sym = node.scope.find_variable(name);\n                                if (!sym) {\n                                    var g;\n                                    if (globals.has(name)) {\n                                        g = globals.get(name);\n                                    } else {\n                                        g = new SymbolDef(self, globals.size(), node);\n                                        g.undeclared = true;\n                                        g.global = true;\n                                        globals.set(name, g);\n                                    }\n                                    node.thedef = g;\n                                    if (name == 'eval' && tw.parent() instanceof AST_Call) {\n                                        for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope)\n                                            s.uses_eval = true;\n                                    }\n                                    if (func && name == 'arguments') {\n                                        func.uses_arguments = true;\n                                    }\n                                } else {\n                                    node.thedef = sym;\n                                }\n                                node.reference();\n                                return true;\n                            }\n                        });\n                        self.walk(tw);\n                    });\n                    AST_Scope.DEFMETHOD('init_scope_vars', function (nesting) {\n                        this.directives = [];\n                        this.variables = new Dictionary();\n                        this.functions = new Dictionary();\n                        this.uses_with = false;\n                        this.uses_eval = false;\n                        this.parent_scope = null;\n                        this.enclosed = [];\n                        this.cname = -1;\n                        this.nesting = nesting;\n                    });\n                    AST_Scope.DEFMETHOD('strict', function () {\n                        return this.has_directive('use strict');\n                    });\n                    AST_Lambda.DEFMETHOD('init_scope_vars', function () {\n                        AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n                        this.uses_arguments = false;\n                    });\n                    AST_SymbolRef.DEFMETHOD('reference', function () {\n                        var def = this.definition();\n                        def.references.push(this);\n                        var s = this.scope;\n                        while (s) {\n                            push_uniq(s.enclosed, def);\n                            if (s === def.scope)\n                                break;\n                            s = s.parent_scope;\n                        }\n                        this.frame = this.scope.nesting - def.scope.nesting;\n                    });\n                    AST_Scope.DEFMETHOD('find_variable', function (name) {\n                        if (name instanceof AST_Symbol)\n                            name = name.name;\n                        return this.variables.get(name) || this.parent_scope && this.parent_scope.find_variable(name);\n                    });\n                    AST_Scope.DEFMETHOD('has_directive', function (value) {\n                        return this.parent_scope && this.parent_scope.has_directive(value) || (this.directives.indexOf(value) >= 0 ? this : null);\n                    });\n                    AST_Scope.DEFMETHOD('def_function', function (symbol) {\n                        this.functions.set(symbol.name, this.def_variable(symbol));\n                    });\n                    AST_Scope.DEFMETHOD('def_variable', function (symbol) {\n                        var def;\n                        if (!this.variables.has(symbol.name)) {\n                            def = new SymbolDef(this, this.variables.size(), symbol);\n                            this.variables.set(symbol.name, def);\n                            def.global = !this.parent_scope;\n                        } else {\n                            def = this.variables.get(symbol.name);\n                            def.orig.push(symbol);\n                        }\n                        return symbol.thedef = def;\n                    });\n                    AST_Scope.DEFMETHOD('next_mangled', function (options) {\n                        var ext = this.enclosed;\n                        out:\n                            while (true) {\n                                var m = base54(++this.cname);\n                                if (!is_identifier(m))\n                                    continue;\n                                if (options.except.indexOf(m) >= 0)\n                                    continue;\n                                for (var i = ext.length; --i >= 0;) {\n                                    var sym = ext[i];\n                                    var name = sym.mangled_name || sym.unmangleable(options) && sym.name;\n                                    if (m == name)\n                                        continue out;\n                                }\n                                return m;\n                            }\n                    });\n                    AST_Function.DEFMETHOD('next_mangled', function (options, def) {\n                        var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();\n                        while (true) {\n                            var name = AST_Lambda.prototype.next_mangled.call(this, options, def);\n                            if (!(tricky_def && tricky_def.mangled_name == name))\n                                return name;\n                        }\n                    });\n                    AST_Scope.DEFMETHOD('references', function (sym) {\n                        if (sym instanceof AST_Symbol)\n                            sym = sym.definition();\n                        return this.enclosed.indexOf(sym) < 0 ? null : sym;\n                    });\n                    AST_Symbol.DEFMETHOD('unmangleable', function (options) {\n                        return this.definition().unmangleable(options);\n                    });\n                    AST_SymbolAccessor.DEFMETHOD('unmangleable', function () {\n                        return true;\n                    });\n                    AST_Label.DEFMETHOD('unmangleable', function () {\n                        return false;\n                    });\n                    AST_Symbol.DEFMETHOD('unreferenced', function () {\n                        return this.definition().references.length == 0 && !(this.scope.uses_eval || this.scope.uses_with);\n                    });\n                    AST_Symbol.DEFMETHOD('undeclared', function () {\n                        return this.definition().undeclared;\n                    });\n                    AST_LabelRef.DEFMETHOD('undeclared', function () {\n                        return false;\n                    });\n                    AST_Label.DEFMETHOD('undeclared', function () {\n                        return false;\n                    });\n                    AST_Symbol.DEFMETHOD('definition', function () {\n                        return this.thedef;\n                    });\n                    AST_Symbol.DEFMETHOD('global', function () {\n                        return this.definition().global;\n                    });\n                    AST_Toplevel.DEFMETHOD('_default_mangler_options', function (options) {\n                        return defaults(options, {\n                            except: [],\n                            eval: false,\n                            sort: false,\n                            toplevel: false,\n                            screw_ie8: false\n                        });\n                    });\n                    AST_Toplevel.DEFMETHOD('mangle_names', function (options) {\n                        options = this._default_mangler_options(options);\n                        var lname = -1;\n                        var to_mangle = [];\n                        var tw = new TreeWalker(function (node, descend) {\n                            if (node instanceof AST_LabeledStatement) {\n                                var save_nesting = lname;\n                                descend();\n                                lname = save_nesting;\n                                return true;\n                            }\n                            if (node instanceof AST_Scope) {\n                                var p = tw.parent(), a = [];\n                                node.variables.each(function (symbol) {\n                                    if (options.except.indexOf(symbol.name) < 0) {\n                                        a.push(symbol);\n                                    }\n                                });\n                                if (options.sort)\n                                    a.sort(function (a, b) {\n                                        return b.references.length - a.references.length;\n                                    });\n                                to_mangle.push.apply(to_mangle, a);\n                                return;\n                            }\n                            if (node instanceof AST_Label) {\n                                var name;\n                                do\n                                    name = base54(++lname);\n                                while (!is_identifier(name));\n                                node.mangled_name = name;\n                                return true;\n                            }\n                            if (options.screw_ie8 && node instanceof AST_SymbolCatch) {\n                                to_mangle.push(node.definition());\n                                return;\n                            }\n                        });\n                        this.walk(tw);\n                        to_mangle.forEach(function (def) {\n                            def.mangle(options);\n                        });\n                    });\n                    AST_Toplevel.DEFMETHOD('compute_char_frequency', function (options) {\n                        options = this._default_mangler_options(options);\n                        var tw = new TreeWalker(function (node) {\n                            if (node instanceof AST_Constant)\n                                base54.consider(node.print_to_string());\n                            else if (node instanceof AST_Return)\n                                base54.consider('return');\n                            else if (node instanceof AST_Throw)\n                                base54.consider('throw');\n                            else if (node instanceof AST_Continue)\n                                base54.consider('continue');\n                            else if (node instanceof AST_Break)\n                                base54.consider('break');\n                            else if (node instanceof AST_Debugger)\n                                base54.consider('debugger');\n                            else if (node instanceof AST_Directive)\n                                base54.consider(node.value);\n                            else if (node instanceof AST_While)\n                                base54.consider('while');\n                            else if (node instanceof AST_Do)\n                                base54.consider('do while');\n                            else if (node instanceof AST_If) {\n                                base54.consider('if');\n                                if (node.alternative)\n                                    base54.consider('else');\n                            } else if (node instanceof AST_Var)\n                                base54.consider('var');\n                            else if (node instanceof AST_Const)\n                                base54.consider('const');\n                            else if (node instanceof AST_Lambda)\n                                base54.consider('function');\n                            else if (node instanceof AST_For)\n                                base54.consider('fo' + 'r');\n                            else if (node instanceof AST_ForIn)\n                                base54.consider('for in');\n                            else if (node instanceof AST_Switch)\n                                base54.consider('switch');\n                            else if (node instanceof AST_Case)\n                                base54.consider('case');\n                            else if (node instanceof AST_Default)\n                                base54.consider('default');\n                            else if (node instanceof AST_With)\n                                base54.consider('with');\n                            else if (node instanceof AST_ObjectSetter)\n                                base54.consider('set' + node.key);\n                            else if (node instanceof AST_ObjectGetter)\n                                base54.consider('get' + node.key);\n                            else if (node instanceof AST_ObjectKeyVal)\n                                base54.consider(node.key);\n                            else if (node instanceof AST_New)\n                                base54.consider('new');\n                            else if (node instanceof AST_This)\n                                base54.consider('this');\n                            else if (node instanceof AST_Try)\n                                base54.consider('try');\n                            else if (node instanceof AST_Catch)\n                                base54.consider('catch');\n                            else if (node instanceof AST_Finally)\n                                base54.consider('finally');\n                            else if (node instanceof AST_Symbol && node.unmangleable(options))\n                                base54.consider(node.name);\n                            else if (node instanceof AST_Unary || node instanceof AST_Binary)\n                                base54.consider(node.operator);\n                            else if (node instanceof AST_Dot)\n                                base54.consider(node.property);\n                        });\n                        this.walk(tw);\n                        base54.sort();\n                    });\n                    var base54 = function () {\n                        var string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789';\n                        var chars, frequency;\n                        function reset() {\n                            frequency = Object.create(null);\n                            chars = string.split('').map(function (ch) {\n                                return ch.charCodeAt(0);\n                            });\n                            chars.forEach(function (ch) {\n                                frequency[ch] = 0;\n                            });\n                        }\n                        base54.consider = function (str) {\n                            for (var i = str.length; --i >= 0;) {\n                                var code = str.charCodeAt(i);\n                                if (code in frequency)\n                                    ++frequency[code];\n                            }\n                        };\n                        base54.sort = function () {\n                            chars = mergeSort(chars, function (a, b) {\n                                if (is_digit(a) && !is_digit(b))\n                                    return 1;\n                                if (is_digit(b) && !is_digit(a))\n                                    return -1;\n                                return frequency[b] - frequency[a];\n                            });\n                        };\n                        base54.reset = reset;\n                        reset();\n                        base54.get = function () {\n                            return chars;\n                        };\n                        base54.freq = function () {\n                            return frequency;\n                        };\n                        function base54(num) {\n                            var ret = '', base = 54;\n                            do {\n                                ret += String.fromCharCode(chars[num % base]);\n                                num = Math.floor(num / base);\n                                base = 64;\n                            } while (num > 0);\n                            return ret;\n                        }\n                        ;\n                        return base54;\n                    }();\n                    AST_Toplevel.DEFMETHOD('scope_warnings', function (options) {\n                        options = defaults(options, {\n                            undeclared: false,\n                            unreferenced: true,\n                            assign_to_global: true,\n                            func_arguments: true,\n                            nested_defuns: true,\n                            eval: true\n                        });\n                        var tw = new TreeWalker(function (node) {\n                            if (options.undeclared && node instanceof AST_SymbolRef && node.undeclared()) {\n                                AST_Node.warn('Undeclared symbol: {name} [{file}:{line},{col}]', {\n                                    name: node.name,\n                                    file: node.start.file,\n                                    line: node.start.line,\n                                    col: node.start.col\n                                });\n                            }\n                            if (options.assign_to_global) {\n                                var sym = null;\n                                if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef)\n                                    sym = node.left;\n                                else if (node instanceof AST_ForIn && node.init instanceof AST_SymbolRef)\n                                    sym = node.init;\n                                if (sym && (sym.undeclared() || sym.global() && sym.scope !== sym.definition().scope)) {\n                                    AST_Node.warn('{msg}: {name} [{file}:{line},{col}]', {\n                                        msg: sym.undeclared() ? 'Accidental global?' : 'Assignment to global',\n                                        name: sym.name,\n                                        file: sym.start.file,\n                                        line: sym.start.line,\n                                        col: sym.start.col\n                                    });\n                                }\n                            }\n                            if (options.eval && node instanceof AST_SymbolRef && node.undeclared() && node.name == 'eval') {\n                                AST_Node.warn('Eval is used [{file}:{line},{col}]', node.start);\n                            }\n                            if (options.unreferenced && (node instanceof AST_SymbolDeclaration || node instanceof AST_Label) && node.unreferenced()) {\n                                AST_Node.warn('{type} {name} is declared but not referenced [{file}:{line},{col}]', {\n                                    type: node instanceof AST_Label ? 'Label' : 'Symbol',\n                                    name: node.name,\n                                    file: node.start.file,\n                                    line: node.start.line,\n                                    col: node.start.col\n                                });\n                            }\n                            if (options.func_arguments && node instanceof AST_Lambda && node.uses_arguments) {\n                                AST_Node.warn('arguments used in function {name} [{file}:{line},{col}]', {\n                                    name: node.name ? node.name.name : 'anonymous',\n                                    file: node.start.file,\n                                    line: node.start.line,\n                                    col: node.start.col\n                                });\n                            }\n                            if (options.nested_defuns && node instanceof AST_Defun && !(tw.parent() instanceof AST_Scope)) {\n                                AST_Node.warn('Function {name} declared in nested statement \"{type}\" [{file}:{line},{col}]', {\n                                    name: node.name.name,\n                                    type: tw.parent().TYPE,\n                                    file: node.start.file,\n                                    line: node.start.line,\n                                    col: node.start.col\n                                });\n                            }\n                        });\n                        this.walk(tw);\n                    });\n                    function OutputStream(options) {\n                        options = defaults(options, {\n                            indent_start: 0,\n                            indent_level: 4,\n                            quote_keys: false,\n                            space_colon: true,\n                            ascii_only: false,\n                            unescape_regexps: false,\n                            inline_script: false,\n                            width: 80,\n                            max_line_len: 32000,\n                            beautify: false,\n                            source_map: null,\n                            bracketize: false,\n                            semicolons: true,\n                            comments: false,\n                            preserve_line: false,\n                            screw_ie8: false,\n                            preamble: null\n                        }, true);\n                        var indentation = 0;\n                        var current_col = 0;\n                        var current_line = 1;\n                        var current_pos = 0;\n                        var OUTPUT = '';\n                        function to_ascii(str, identifier) {\n                            return str.replace(/[\\u0080-\\uffff]/g, function (ch) {\n                                var code = ch.charCodeAt(0).toString(16);\n                                if (code.length <= 2 && !identifier) {\n                                    while (code.length < 2)\n                                        code = '0' + code;\n                                    return '\\\\x' + code;\n                                } else {\n                                    while (code.length < 4)\n                                        code = '0' + code;\n                                    return '\\\\u' + code;\n                                }\n                            });\n                        }\n                        ;\n                        function make_string(str) {\n                            var dq = 0, sq = 0;\n                            str = str.replace(/[\\\\\\b\\f\\n\\r\\t\\x22\\x27\\u2028\\u2029\\0]/g, function (s) {\n                                switch (s) {\n                                case '\\\\':\n                                    return '\\\\\\\\';\n                                case '\\b':\n                                    return '\\\\b';\n                                case '\\f':\n                                    return '\\\\f';\n                                case '\\n':\n                                    return '\\\\n';\n                                case '\\r':\n                                    return '\\\\r';\n                                case '\\u2028':\n                                    return '\\\\u2028';\n                                case '\\u2029':\n                                    return '\\\\u2029';\n                                case '\"':\n                                    ++dq;\n                                    return '\"';\n                                case \"'\":\n                                    ++sq;\n                                    return \"'\";\n                                case '\\0':\n                                    return '\\\\x00';\n                                }\n                                return s;\n                            });\n                            if (options.ascii_only)\n                                str = to_ascii(str);\n                            if (dq > sq)\n                                return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n                            else\n                                return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n                        }\n                        ;\n                        function encode_string(str) {\n                            var ret = make_string(str);\n                            if (options.inline_script)\n                                ret = ret.replace(/<\\x2fscript([>\\/\\t\\n\\f\\r ])/gi, '<\\\\/script$1');\n                            return ret;\n                        }\n                        ;\n                        function make_name(name) {\n                            name = name.toString();\n                            if (options.ascii_only)\n                                name = to_ascii(name, true);\n                            return name;\n                        }\n                        ;\n                        function make_indent(back) {\n                            return repeat_string(' ', options.indent_start + indentation - back * options.indent_level);\n                        }\n                        ;\n                        var might_need_space = false;\n                        var might_need_semicolon = false;\n                        var last = null;\n                        function last_char() {\n                            return last.charAt(last.length - 1);\n                        }\n                        ;\n                        function maybe_newline() {\n                            if (options.max_line_len && current_col > options.max_line_len)\n                                print('\\n');\n                        }\n                        ;\n                        var requireSemicolonChars = makePredicate('( [ + * / - , .');\n                        function print(str) {\n                            str = String(str);\n                            var ch = str.charAt(0);\n                            if (might_need_semicolon) {\n                                if ((!ch || ';}'.indexOf(ch) < 0) && !/[;]$/.test(last)) {\n                                    if (options.semicolons || requireSemicolonChars(ch)) {\n                                        OUTPUT += ';';\n                                        current_col++;\n                                        current_pos++;\n                                    } else {\n                                        OUTPUT += '\\n';\n                                        current_pos++;\n                                        current_line++;\n                                        current_col = 0;\n                                    }\n                                    if (!options.beautify)\n                                        might_need_space = false;\n                                }\n                                might_need_semicolon = false;\n                                maybe_newline();\n                            }\n                            if (!options.beautify && options.preserve_line && stack[stack.length - 1]) {\n                                var target_line = stack[stack.length - 1].start.line;\n                                while (current_line < target_line) {\n                                    OUTPUT += '\\n';\n                                    current_pos++;\n                                    current_line++;\n                                    current_col = 0;\n                                    might_need_space = false;\n                                }\n                            }\n                            if (might_need_space) {\n                                var prev = last_char();\n                                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == '\\\\') || /^[\\+\\-\\/]$/.test(ch) && ch == prev) {\n                                    OUTPUT += ' ';\n                                    current_col++;\n                                    current_pos++;\n                                }\n                                might_need_space = false;\n                            }\n                            var a = str.split(/\\r?\\n/), n = a.length - 1;\n                            current_line += n;\n                            if (n == 0) {\n                                current_col += a[n].length;\n                            } else {\n                                current_col = a[n].length;\n                            }\n                            current_pos += str.length;\n                            last = str;\n                            OUTPUT += str;\n                        }\n                        ;\n                        var space = options.beautify ? function () {\n                            print(' ');\n                        } : function () {\n                            might_need_space = true;\n                        };\n                        var indent = options.beautify ? function (half) {\n                            if (options.beautify) {\n                                print(make_indent(half ? 0.5 : 0));\n                            }\n                        } : noop;\n                        var with_indent = options.beautify ? function (col, cont) {\n                            if (col === true)\n                                col = next_indent();\n                            var save_indentation = indentation;\n                            indentation = col;\n                            var ret = cont();\n                            indentation = save_indentation;\n                            return ret;\n                        } : function (col, cont) {\n                            return cont();\n                        };\n                        var newline = options.beautify ? function () {\n                            print('\\n');\n                        } : noop;\n                        var semicolon = options.beautify ? function () {\n                            print(';');\n                        } : function () {\n                            might_need_semicolon = true;\n                        };\n                        function force_semicolon() {\n                            might_need_semicolon = false;\n                            print(';');\n                        }\n                        ;\n                        function next_indent() {\n                            return indentation + options.indent_level;\n                        }\n                        ;\n                        function with_block(cont) {\n                            var ret;\n                            print('{');\n                            newline();\n                            with_indent(next_indent(), function () {\n                                ret = cont();\n                            });\n                            indent();\n                            print('}');\n                            return ret;\n                        }\n                        ;\n                        function with_parens(cont) {\n                            print('(');\n                            var ret = cont();\n                            print(')');\n                            return ret;\n                        }\n                        ;\n                        function with_square(cont) {\n                            print('[');\n                            var ret = cont();\n                            print(']');\n                            return ret;\n                        }\n                        ;\n                        function comma() {\n                            print(',');\n                            space();\n                        }\n                        ;\n                        function colon() {\n                            print(':');\n                            if (options.space_colon)\n                                space();\n                        }\n                        ;\n                        var add_mapping = options.source_map ? function (token, name) {\n                            try {\n                                if (token)\n                                    options.source_map.add(token.file || '?', current_line, current_col, token.line, token.col, !name && token.type == 'name' ? token.value : name);\n                            } catch (ex) {\n                                AST_Node.warn(\"Couldn't figure out mapping for {file}:{line},{col} \\u2192 {cline},{ccol} [{name}]\", {\n                                    file: token.file,\n                                    line: token.line,\n                                    col: token.col,\n                                    cline: current_line,\n                                    ccol: current_col,\n                                    name: name || ''\n                                });\n                            }\n                        } : noop;\n                        function get() {\n                            return OUTPUT;\n                        }\n                        ;\n                        if (options.preamble) {\n                            print(options.preamble.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g, '\\n'));\n                        }\n                        var stack = [];\n                        return {\n                            get: get,\n                            toString: get,\n                            indent: indent,\n                            indentation: function () {\n                                return indentation;\n                            },\n                            current_width: function () {\n                                return current_col - indentation;\n                            },\n                            should_break: function () {\n                                return options.width && this.current_width() >= options.width;\n                            },\n                            newline: newline,\n                            print: print,\n                            space: space,\n                            comma: comma,\n                            colon: colon,\n                            last: function () {\n                                return last;\n                            },\n                            semicolon: semicolon,\n                            force_semicolon: force_semicolon,\n                            to_ascii: to_ascii,\n                            print_name: function (name) {\n                                print(make_name(name));\n                            },\n                            print_string: function (str) {\n                                print(encode_string(str));\n                            },\n                            next_indent: next_indent,\n                            with_indent: with_indent,\n                            with_block: with_block,\n                            with_parens: with_parens,\n                            with_square: with_square,\n                            add_mapping: add_mapping,\n                            option: function (opt) {\n                                return options[opt];\n                            },\n                            line: function () {\n                                return current_line;\n                            },\n                            col: function () {\n                                return current_col;\n                            },\n                            pos: function () {\n                                return current_pos;\n                            },\n                            push_node: function (node) {\n                                stack.push(node);\n                            },\n                            pop_node: function () {\n                                return stack.pop();\n                            },\n                            stack: function () {\n                                return stack;\n                            },\n                            parent: function (n) {\n                                return stack[stack.length - 2 - (n || 0)];\n                            }\n                        };\n                    }\n                    ;\n                    (function () {\n                        function DEFPRINT(nodetype, generator) {\n                            nodetype.DEFMETHOD('_codegen', generator);\n                        }\n                        ;\n                        AST_Node.DEFMETHOD('print', function (stream, force_parens) {\n                            var self = this, generator = self._codegen;\n                            function doit() {\n                                self.add_comments(stream);\n                                self.add_source_map(stream);\n                                generator(self, stream);\n                            }\n                            stream.push_node(self);\n                            if (force_parens || self.needs_parens(stream)) {\n                                stream.with_parens(doit);\n                            } else {\n                                doit();\n                            }\n                            stream.pop_node();\n                        });\n                        AST_Node.DEFMETHOD('print_to_string', function (options) {\n                            var s = OutputStream(options);\n                            this.print(s);\n                            return s.get();\n                        });\n                        AST_Node.DEFMETHOD('add_comments', function (output) {\n                            var c = output.option('comments'), self = this;\n                            if (c) {\n                                var start = self.start;\n                                if (start && !start._comments_dumped) {\n                                    start._comments_dumped = true;\n                                    var comments = start.comments_before || [];\n                                    if (self instanceof AST_Exit && self.value) {\n                                        self.value.walk(new TreeWalker(function (node) {\n                                            if (node.start && node.start.comments_before) {\n                                                comments = comments.concat(node.start.comments_before);\n                                                node.start.comments_before = [];\n                                            }\n                                            if (node instanceof AST_Function || node instanceof AST_Array || node instanceof AST_Object) {\n                                                return true;\n                                            }\n                                        }));\n                                    }\n                                    if (c.test) {\n                                        comments = comments.filter(function (comment) {\n                                            return c.test(comment.value);\n                                        });\n                                    } else if (typeof c == 'function') {\n                                        comments = comments.filter(function (comment) {\n                                            return c(self, comment);\n                                        });\n                                    }\n                                    comments.forEach(function (c) {\n                                        if (/comment[134]/.test(c.type)) {\n                                            output.print('//' + c.value + '\\n');\n                                            output.indent();\n                                        } else if (c.type == 'comment2') {\n                                            output.print('/*' + c.value + '*/');\n                                            if (start.nlb) {\n                                                output.print('\\n');\n                                                output.indent();\n                                            } else {\n                                                output.space();\n                                            }\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                        function PARENS(nodetype, func) {\n                            nodetype.DEFMETHOD('needs_parens', func);\n                        }\n                        ;\n                        PARENS(AST_Node, function () {\n                            return false;\n                        });\n                        PARENS(AST_Function, function (output) {\n                            return first_in_statement(output);\n                        });\n                        PARENS(AST_Object, function (output) {\n                            return first_in_statement(output);\n                        });\n                        PARENS(AST_Unary, function (output) {\n                            var p = output.parent();\n                            return p instanceof AST_PropAccess && p.expression === this;\n                        });\n                        PARENS(AST_Seq, function (output) {\n                            var p = output.parent();\n                            return p instanceof AST_Call || p instanceof AST_Unary || p instanceof AST_Binary || p instanceof AST_VarDef || p instanceof AST_PropAccess || p instanceof AST_Array || p instanceof AST_ObjectProperty || p instanceof AST_Conditional;\n                        });\n                        PARENS(AST_Binary, function (output) {\n                            var p = output.parent();\n                            if (p instanceof AST_Call && p.expression === this)\n                                return true;\n                            if (p instanceof AST_Unary)\n                                return true;\n                            if (p instanceof AST_PropAccess && p.expression === this)\n                                return true;\n                            if (p instanceof AST_Binary) {\n                                var po = p.operator, pp = PRECEDENCE[po];\n                                var so = this.operator, sp = PRECEDENCE[so];\n                                if (pp > sp || pp == sp && this === p.right) {\n                                    return true;\n                                }\n                            }\n                        });\n                        PARENS(AST_PropAccess, function (output) {\n                            var p = output.parent();\n                            if (p instanceof AST_New && p.expression === this) {\n                                try {\n                                    this.walk(new TreeWalker(function (node) {\n                                        if (node instanceof AST_Call)\n                                            throw p;\n                                    }));\n                                } catch (ex) {\n                                    if (ex !== p)\n                                        throw ex;\n                                    return true;\n                                }\n                            }\n                        });\n                        PARENS(AST_Call, function (output) {\n                            var p = output.parent(), p1;\n                            if (p instanceof AST_New && p.expression === this)\n                                return true;\n                            return this.expression instanceof AST_Function && p instanceof AST_PropAccess && p.expression === this && (p1 = output.parent(1)) instanceof AST_Assign && p1.left === p;\n                        });\n                        PARENS(AST_New, function (output) {\n                            var p = output.parent();\n                            if (no_constructor_parens(this, output) && (p instanceof AST_PropAccess || p instanceof AST_Call && p.expression === this))\n                                return true;\n                        });\n                        PARENS(AST_Number, function (output) {\n                            var p = output.parent();\n                            if (this.getValue() < 0 && p instanceof AST_PropAccess && p.expression === this)\n                                return true;\n                        });\n                        PARENS(AST_NaN, function (output) {\n                            var p = output.parent();\n                            if (p instanceof AST_PropAccess && p.expression === this)\n                                return true;\n                        });\n                        function assign_and_conditional_paren_rules(output) {\n                            var p = output.parent();\n                            if (p instanceof AST_Unary)\n                                return true;\n                            if (p instanceof AST_Binary && !(p instanceof AST_Assign))\n                                return true;\n                            if (p instanceof AST_Call && p.expression === this)\n                                return true;\n                            if (p instanceof AST_Conditional && p.condition === this)\n                                return true;\n                            if (p instanceof AST_PropAccess && p.expression === this)\n                                return true;\n                        }\n                        ;\n                        PARENS(AST_Assign, assign_and_conditional_paren_rules);\n                        PARENS(AST_Conditional, assign_and_conditional_paren_rules);\n                        DEFPRINT(AST_Directive, function (self, output) {\n                            output.print_string(self.value);\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_Debugger, function (self, output) {\n                            output.print('debugger');\n                            output.semicolon();\n                        });\n                        function display_body(body, is_toplevel, output) {\n                            var last = body.length - 1;\n                            body.forEach(function (stmt, i) {\n                                if (!(stmt instanceof AST_EmptyStatement)) {\n                                    output.indent();\n                                    stmt.print(output);\n                                    if (!(i == last && is_toplevel)) {\n                                        output.newline();\n                                        if (is_toplevel)\n                                            output.newline();\n                                    }\n                                }\n                            });\n                        }\n                        ;\n                        AST_StatementWithBody.DEFMETHOD('_do_print_body', function (output) {\n                            force_statement(this.body, output);\n                        });\n                        DEFPRINT(AST_Statement, function (self, output) {\n                            self.body.print(output);\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_Toplevel, function (self, output) {\n                            display_body(self.body, true, output);\n                            output.print('');\n                        });\n                        DEFPRINT(AST_LabeledStatement, function (self, output) {\n                            self.label.print(output);\n                            output.colon();\n                            self.body.print(output);\n                        });\n                        DEFPRINT(AST_SimpleStatement, function (self, output) {\n                            self.body.print(output);\n                            output.semicolon();\n                        });\n                        function print_bracketed(body, output) {\n                            if (body.length > 0)\n                                output.with_block(function () {\n                                    display_body(body, false, output);\n                                });\n                            else\n                                output.print('{}');\n                        }\n                        ;\n                        DEFPRINT(AST_BlockStatement, function (self, output) {\n                            print_bracketed(self.body, output);\n                        });\n                        DEFPRINT(AST_EmptyStatement, function (self, output) {\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_Do, function (self, output) {\n                            output.print('do');\n                            output.space();\n                            self._do_print_body(output);\n                            output.space();\n                            output.print('while');\n                            output.space();\n                            output.with_parens(function () {\n                                self.condition.print(output);\n                            });\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_While, function (self, output) {\n                            output.print('while');\n                            output.space();\n                            output.with_parens(function () {\n                                self.condition.print(output);\n                            });\n                            output.space();\n                            self._do_print_body(output);\n                        });\n                        DEFPRINT(AST_For, function (self, output) {\n                            output.print('fo' + 'r');\n                            output.space();\n                            output.with_parens(function () {\n                                if (self.init) {\n                                    if (self.init instanceof AST_Definitions) {\n                                        self.init.print(output);\n                                    } else {\n                                        parenthesize_for_noin(self.init, output, true);\n                                    }\n                                    output.print(';');\n                                    output.space();\n                                } else {\n                                    output.print(';');\n                                }\n                                if (self.condition) {\n                                    self.condition.print(output);\n                                    output.print(';');\n                                    output.space();\n                                } else {\n                                    output.print(';');\n                                }\n                                if (self.step) {\n                                    self.step.print(output);\n                                }\n                            });\n                            output.space();\n                            self._do_print_body(output);\n                        });\n                        DEFPRINT(AST_ForIn, function (self, output) {\n                            output.print('fo' + 'r');\n                            output.space();\n                            output.with_parens(function () {\n                                self.init.print(output);\n                                output.space();\n                                output.print('in');\n                                output.space();\n                                self.object.print(output);\n                            });\n                            output.space();\n                            self._do_print_body(output);\n                        });\n                        DEFPRINT(AST_With, function (self, output) {\n                            output.print('with');\n                            output.space();\n                            output.with_parens(function () {\n                                self.expression.print(output);\n                            });\n                            output.space();\n                            self._do_print_body(output);\n                        });\n                        AST_Lambda.DEFMETHOD('_do_print', function (output, nokeyword) {\n                            var self = this;\n                            if (!nokeyword) {\n                                output.print('function');\n                            }\n                            if (self.name) {\n                                output.space();\n                                self.name.print(output);\n                            }\n                            output.with_parens(function () {\n                                self.argnames.forEach(function (arg, i) {\n                                    if (i)\n                                        output.comma();\n                                    arg.print(output);\n                                });\n                            });\n                            output.space();\n                            print_bracketed(self.body, output);\n                        });\n                        DEFPRINT(AST_Lambda, function (self, output) {\n                            self._do_print(output);\n                        });\n                        AST_Exit.DEFMETHOD('_do_print', function (output, kind) {\n                            output.print(kind);\n                            if (this.value) {\n                                output.space();\n                                this.value.print(output);\n                            }\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_Return, function (self, output) {\n                            self._do_print(output, 'return');\n                        });\n                        DEFPRINT(AST_Throw, function (self, output) {\n                            self._do_print(output, 'throw');\n                        });\n                        AST_LoopControl.DEFMETHOD('_do_print', function (output, kind) {\n                            output.print(kind);\n                            if (this.label) {\n                                output.space();\n                                this.label.print(output);\n                            }\n                            output.semicolon();\n                        });\n                        DEFPRINT(AST_Break, function (self, output) {\n                            self._do_print(output, 'break');\n                        });\n                        DEFPRINT(AST_Continue, function (self, output) {\n                            self._do_print(output, 'continue');\n                        });\n                        function make_then(self, output) {\n                            if (output.option('bracketize')) {\n                                make_block(self.body, output);\n                                return;\n                            }\n                            if (!self.body)\n                                return output.force_semicolon();\n                            if (self.body instanceof AST_Do && !output.option('screw_ie8')) {\n                                make_block(self.body, output);\n                                return;\n                            }\n                            var b = self.body;\n                            while (true) {\n                                if (b instanceof AST_If) {\n                                    if (!b.alternative) {\n                                        make_block(self.body, output);\n                                        return;\n                                    }\n                                    b = b.alternative;\n                                } else if (b instanceof AST_StatementWithBody) {\n                                    b = b.body;\n                                } else\n                                    break;\n                            }\n                            force_statement(self.body, output);\n                        }\n                        ;\n                        DEFPRINT(AST_If, function (self, output) {\n                            output.print('if');\n                            output.space();\n                            output.with_parens(function () {\n                                self.condition.print(output);\n                            });\n                            output.space();\n                            if (self.alternative) {\n                                make_then(self, output);\n                                output.space();\n                                output.print('else');\n                                output.space();\n                                force_statement(self.alternative, output);\n                            } else {\n                                self._do_print_body(output);\n                            }\n                        });\n                        DEFPRINT(AST_Switch, function (self, output) {\n                            output.print('switch');\n                            output.space();\n                            output.with_parens(function () {\n                                self.expression.print(output);\n                            });\n                            output.space();\n                            if (self.body.length > 0)\n                                output.with_block(function () {\n                                    self.body.forEach(function (stmt, i) {\n                                        if (i)\n                                            output.newline();\n                                        output.indent(true);\n                                        stmt.print(output);\n                                    });\n                                });\n                            else\n                                output.print('{}');\n                        });\n                        AST_SwitchBranch.DEFMETHOD('_do_print_body', function (output) {\n                            if (this.body.length > 0) {\n                                output.newline();\n                                this.body.forEach(function (stmt) {\n                                    output.indent();\n                                    stmt.print(output);\n                                    output.newline();\n                                });\n                            }\n                        });\n                        DEFPRINT(AST_Default, function (self, output) {\n                            output.print('default:');\n                            self._do_print_body(output);\n                        });\n                        DEFPRINT(AST_Case, function (self, output) {\n                            output.print('case');\n                            output.space();\n                            self.expression.print(output);\n                            output.print(':');\n                            self._do_print_body(output);\n                        });\n                        DEFPRINT(AST_Try, function (self, output) {\n                            output.print('try');\n                            output.space();\n                            print_bracketed(self.body, output);\n                            if (self.bcatch) {\n                                output.space();\n                                self.bcatch.print(output);\n                            }\n                            if (self.bfinally) {\n                                output.space();\n                                self.bfinally.print(output);\n                            }\n                        });\n                        DEFPRINT(AST_Catch, function (self, output) {\n                            output.print('catch');\n                            output.space();\n                            output.with_parens(function () {\n                                self.argname.print(output);\n                            });\n                            output.space();\n                            print_bracketed(self.body, output);\n                        });\n                        DEFPRINT(AST_Finally, function (self, output) {\n                            output.print('finally');\n                            output.space();\n                            print_bracketed(self.body, output);\n                        });\n                        AST_Definitions.DEFMETHOD('_do_print', function (output, kind) {\n                            output.print(kind);\n                            output.space();\n                            this.definitions.forEach(function (def, i) {\n                                if (i)\n                                    output.comma();\n                                def.print(output);\n                            });\n                            var p = output.parent();\n                            var in_for = p instanceof AST_For || p instanceof AST_ForIn;\n                            var avoid_semicolon = in_for && p.init === this;\n                            if (!avoid_semicolon)\n                                output.semicolon();\n                        });\n                        DEFPRINT(AST_Var, function (self, output) {\n                            self._do_print(output, 'var');\n                        });\n                        DEFPRINT(AST_Const, function (self, output) {\n                            self._do_print(output, 'const');\n                        });\n                        function parenthesize_for_noin(node, output, noin) {\n                            if (!noin)\n                                node.print(output);\n                            else\n                                try {\n                                    node.walk(new TreeWalker(function (node) {\n                                        if (node instanceof AST_Binary && node.operator == 'in')\n                                            throw output;\n                                    }));\n                                    node.print(output);\n                                } catch (ex) {\n                                    if (ex !== output)\n                                        throw ex;\n                                    node.print(output, true);\n                                }\n                        }\n                        ;\n                        DEFPRINT(AST_VarDef, function (self, output) {\n                            self.name.print(output);\n                            if (self.value) {\n                                output.space();\n                                output.print('=');\n                                output.space();\n                                var p = output.parent(1);\n                                var noin = p instanceof AST_For || p instanceof AST_ForIn;\n                                parenthesize_for_noin(self.value, output, noin);\n                            }\n                        });\n                        DEFPRINT(AST_Call, function (self, output) {\n                            self.expression.print(output);\n                            if (self instanceof AST_New && no_constructor_parens(self, output))\n                                return;\n                            output.with_parens(function () {\n                                self.args.forEach(function (expr, i) {\n                                    if (i)\n                                        output.comma();\n                                    expr.print(output);\n                                });\n                            });\n                        });\n                        DEFPRINT(AST_New, function (self, output) {\n                            output.print('new');\n                            output.space();\n                            AST_Call.prototype._codegen(self, output);\n                        });\n                        AST_Seq.DEFMETHOD('_do_print', function (output) {\n                            this.car.print(output);\n                            if (this.cdr) {\n                                output.comma();\n                                if (output.should_break()) {\n                                    output.newline();\n                                    output.indent();\n                                }\n                                this.cdr.print(output);\n                            }\n                        });\n                        DEFPRINT(AST_Seq, function (self, output) {\n                            self._do_print(output);\n                        });\n                        DEFPRINT(AST_Dot, function (self, output) {\n                            var expr = self.expression;\n                            expr.print(output);\n                            if (expr instanceof AST_Number && expr.getValue() >= 0) {\n                                if (!/[xa-f.]/i.test(output.last())) {\n                                    output.print('.');\n                                }\n                            }\n                            output.print('.');\n                            output.add_mapping(self.end);\n                            output.print_name(self.property);\n                        });\n                        DEFPRINT(AST_Sub, function (self, output) {\n                            self.expression.print(output);\n                            output.print('[');\n                            self.property.print(output);\n                            output.print(']');\n                        });\n                        DEFPRINT(AST_UnaryPrefix, function (self, output) {\n                            var op = self.operator;\n                            output.print(op);\n                            if (/^[a-z]/i.test(op))\n                                output.space();\n                            self.expression.print(output);\n                        });\n                        DEFPRINT(AST_UnaryPostfix, function (self, output) {\n                            self.expression.print(output);\n                            output.print(self.operator);\n                        });\n                        DEFPRINT(AST_Binary, function (self, output) {\n                            self.left.print(output);\n                            output.space();\n                            output.print(self.operator);\n                            if (self.operator == '<' && self.right instanceof AST_UnaryPrefix && self.right.operator == '!' && self.right.expression instanceof AST_UnaryPrefix && self.right.expression.operator == '--') {\n                                output.print(' ');\n                            } else {\n                                output.space();\n                            }\n                            self.right.print(output);\n                        });\n                        DEFPRINT(AST_Conditional, function (self, output) {\n                            self.condition.print(output);\n                            output.space();\n                            output.print('?');\n                            output.space();\n                            self.consequent.print(output);\n                            output.space();\n                            output.colon();\n                            self.alternative.print(output);\n                        });\n                        DEFPRINT(AST_Array, function (self, output) {\n                            output.with_square(function () {\n                                var a = self.elements, len = a.length;\n                                if (len > 0)\n                                    output.space();\n                                a.forEach(function (exp, i) {\n                                    if (i)\n                                        output.comma();\n                                    exp.print(output);\n                                    if (i === len - 1 && exp instanceof AST_Hole)\n                                        output.comma();\n                                });\n                                if (len > 0)\n                                    output.space();\n                            });\n                        });\n                        DEFPRINT(AST_Object, function (self, output) {\n                            if (self.properties.length > 0)\n                                output.with_block(function () {\n                                    self.properties.forEach(function (prop, i) {\n                                        if (i) {\n                                            output.print(',');\n                                            output.newline();\n                                        }\n                                        output.indent();\n                                        prop.print(output);\n                                    });\n                                    output.newline();\n                                });\n                            else\n                                output.print('{}');\n                        });\n                        DEFPRINT(AST_ObjectKeyVal, function (self, output) {\n                            var key = self.key;\n                            if (output.option('quote_keys')) {\n                                output.print_string(key + '');\n                            } else if ((typeof key == 'number' || !output.option('beautify') && +key + '' == key) && parseFloat(key) >= 0) {\n                                output.print(make_num(key));\n                            } else if (RESERVED_WORDS(key) ? output.option('screw_ie8') : is_identifier_string(key)) {\n                                output.print_name(key);\n                            } else {\n                                output.print_string(key);\n                            }\n                            output.colon();\n                            self.value.print(output);\n                        });\n                        DEFPRINT(AST_ObjectSetter, function (self, output) {\n                            output.print('set');\n                            output.space();\n                            self.key.print(output);\n                            self.value._do_print(output, true);\n                        });\n                        DEFPRINT(AST_ObjectGetter, function (self, output) {\n                            output.print('get');\n                            output.space();\n                            self.key.print(output);\n                            self.value._do_print(output, true);\n                        });\n                        DEFPRINT(AST_Symbol, function (self, output) {\n                            var def = self.definition();\n                            output.print_name(def ? def.mangled_name || def.name : self.name);\n                        });\n                        DEFPRINT(AST_Undefined, function (self, output) {\n                            output.print('void 0');\n                        });\n                        DEFPRINT(AST_Hole, noop);\n                        DEFPRINT(AST_Infinity, function (self, output) {\n                            output.print('1/0');\n                        });\n                        DEFPRINT(AST_NaN, function (self, output) {\n                            output.print('0/0');\n                        });\n                        DEFPRINT(AST_This, function (self, output) {\n                            output.print('this');\n                        });\n                        DEFPRINT(AST_Constant, function (self, output) {\n                            output.print(self.getValue());\n                        });\n                        DEFPRINT(AST_String, function (self, output) {\n                            output.print_string(self.getValue());\n                        });\n                        DEFPRINT(AST_Number, function (self, output) {\n                            output.print(make_num(self.getValue()));\n                        });\n                        function regexp_safe_literal(code) {\n                            return [\n                                92,\n                                47,\n                                46,\n                                43,\n                                42,\n                                63,\n                                40,\n                                41,\n                                91,\n                                93,\n                                123,\n                                125,\n                                36,\n                                94,\n                                58,\n                                124,\n                                33,\n                                10,\n                                13,\n                                0,\n                                65279,\n                                8232,\n                                8233\n                            ].indexOf(code) < 0;\n                        }\n                        ;\n                        DEFPRINT(AST_RegExp, function (self, output) {\n                            var str = self.getValue().toString();\n                            if (output.option('ascii_only')) {\n                                str = output.to_ascii(str);\n                            } else if (output.option('unescape_regexps')) {\n                                str = str.split('\\\\\\\\').map(function (str) {\n                                    return str.replace(/\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}/g, function (s) {\n                                        var code = parseInt(s.substr(2), 16);\n                                        return regexp_safe_literal(code) ? String.fromCharCode(code) : s;\n                                    });\n                                }).join('\\\\\\\\');\n                            }\n                            output.print(str);\n                            var p = output.parent();\n                            if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === self)\n                                output.print(' ');\n                        });\n                        function force_statement(stat, output) {\n                            if (output.option('bracketize')) {\n                                if (!stat || stat instanceof AST_EmptyStatement)\n                                    output.print('{}');\n                                else if (stat instanceof AST_BlockStatement)\n                                    stat.print(output);\n                                else\n                                    output.with_block(function () {\n                                        output.indent();\n                                        stat.print(output);\n                                        output.newline();\n                                    });\n                            } else {\n                                if (!stat || stat instanceof AST_EmptyStatement)\n                                    output.force_semicolon();\n                                else\n                                    stat.print(output);\n                            }\n                        }\n                        ;\n                        function first_in_statement(output) {\n                            var a = output.stack(), i = a.length, node = a[--i], p = a[--i];\n                            while (i > 0) {\n                                if (p instanceof AST_Statement && p.body === node)\n                                    return true;\n                                if (p instanceof AST_Seq && p.car === node || p instanceof AST_Call && p.expression === node && !(p instanceof AST_New) || p instanceof AST_Dot && p.expression === node || p instanceof AST_Sub && p.expression === node || p instanceof AST_Conditional && p.condition === node || p instanceof AST_Binary && p.left === node || p instanceof AST_UnaryPostfix && p.expression === node) {\n                                    node = p;\n                                    p = a[--i];\n                                } else {\n                                    return false;\n                                }\n                            }\n                        }\n                        ;\n                        function no_constructor_parens(self, output) {\n                            return self.args.length == 0 && !output.option('beautify');\n                        }\n                        ;\n                        function best_of(a) {\n                            var best = a[0], len = best.length;\n                            for (var i = 1; i < a.length; ++i) {\n                                if (a[i].length < len) {\n                                    best = a[i];\n                                    len = best.length;\n                                }\n                            }\n                            return best;\n                        }\n                        ;\n                        function make_num(num) {\n                            var str = num.toString(10), a = [str.replace(/^0\\./, '.').replace('e+', 'e')], m;\n                            if (Math.floor(num) === num) {\n                                if (num >= 0) {\n                                    a.push('0x' + num.toString(16).toLowerCase(), '0' + num.toString(8));\n                                } else {\n                                    a.push('-0x' + (-num).toString(16).toLowerCase(), '-0' + (-num).toString(8));\n                                }\n                                if (m = /^(.*?)(0+)$/.exec(num)) {\n                                    a.push(m[1] + 'e' + m[2].length);\n                                }\n                            } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n                                a.push(m[2] + 'e-' + (m[1].length + m[2].length), str.substr(str.indexOf('.')));\n                            }\n                            return best_of(a);\n                        }\n                        ;\n                        function make_block(stmt, output) {\n                            if (stmt instanceof AST_BlockStatement) {\n                                stmt.print(output);\n                                return;\n                            }\n                            output.with_block(function () {\n                                output.indent();\n                                stmt.print(output);\n                                output.newline();\n                            });\n                        }\n                        ;\n                        function DEFMAP(nodetype, generator) {\n                            nodetype.DEFMETHOD('add_source_map', function (stream) {\n                                generator(this, stream);\n                            });\n                        }\n                        ;\n                        DEFMAP(AST_Node, noop);\n                        function basic_sourcemap_gen(self, output) {\n                            output.add_mapping(self.start);\n                        }\n                        ;\n                        DEFMAP(AST_Directive, basic_sourcemap_gen);\n                        DEFMAP(AST_Debugger, basic_sourcemap_gen);\n                        DEFMAP(AST_Symbol, basic_sourcemap_gen);\n                        DEFMAP(AST_Jump, basic_sourcemap_gen);\n                        DEFMAP(AST_StatementWithBody, basic_sourcemap_gen);\n                        DEFMAP(AST_LabeledStatement, noop);\n                        DEFMAP(AST_Lambda, basic_sourcemap_gen);\n                        DEFMAP(AST_Switch, basic_sourcemap_gen);\n                        DEFMAP(AST_SwitchBranch, basic_sourcemap_gen);\n                        DEFMAP(AST_BlockStatement, basic_sourcemap_gen);\n                        DEFMAP(AST_Toplevel, noop);\n                        DEFMAP(AST_New, basic_sourcemap_gen);\n                        DEFMAP(AST_Try, basic_sourcemap_gen);\n                        DEFMAP(AST_Catch, basic_sourcemap_gen);\n                        DEFMAP(AST_Finally, basic_sourcemap_gen);\n                        DEFMAP(AST_Definitions, basic_sourcemap_gen);\n                        DEFMAP(AST_Constant, basic_sourcemap_gen);\n                        DEFMAP(AST_ObjectProperty, function (self, output) {\n                            output.add_mapping(self.start, self.key);\n                        });\n                    }());\n                    function Compressor(options, false_by_default) {\n                        if (!(this instanceof Compressor))\n                            return new Compressor(options, false_by_default);\n                        TreeTransformer.call(this, this.before, this.after);\n                        this.options = defaults(options, {\n                            sequences: !false_by_default,\n                            properties: !false_by_default,\n                            dead_code: !false_by_default,\n                            drop_debugger: !false_by_default,\n                            unsafe: false,\n                            unsafe_comps: false,\n                            conditionals: !false_by_default,\n                            comparisons: !false_by_default,\n                            evaluate: !false_by_default,\n                            booleans: !false_by_default,\n                            loops: !false_by_default,\n                            unused: !false_by_default,\n                            hoist_funs: !false_by_default,\n                            keep_fargs: false,\n                            hoist_vars: false,\n                            if_return: !false_by_default,\n                            join_vars: !false_by_default,\n                            cascade: !false_by_default,\n                            side_effects: !false_by_default,\n                            pure_getters: false,\n                            pure_funcs: null,\n                            negate_iife: !false_by_default,\n                            screw_ie8: false,\n                            drop_console: false,\n                            angular: false,\n                            warnings: true,\n                            global_defs: {}\n                        }, true);\n                    }\n                    ;\n                    Compressor.prototype = new TreeTransformer();\n                    merge(Compressor.prototype, {\n                        option: function (key) {\n                            return this.options[key];\n                        },\n                        warn: function () {\n                            if (this.options.warnings)\n                                AST_Node.warn.apply(AST_Node, arguments);\n                        },\n                        before: function (node, descend, in_list) {\n                            if (node._squeezed)\n                                return node;\n                            var was_scope = false;\n                            if (node instanceof AST_Scope) {\n                                node = node.hoist_declarations(this);\n                                was_scope = true;\n                            }\n                            descend(node, this);\n                            node = node.optimize(this);\n                            if (was_scope && node instanceof AST_Scope) {\n                                node.drop_unused(this);\n                                descend(node, this);\n                            }\n                            node._squeezed = true;\n                            return node;\n                        }\n                    });\n                    (function () {\n                        function OPT(node, optimizer) {\n                            node.DEFMETHOD('optimize', function (compressor) {\n                                var self = this;\n                                if (self._optimized)\n                                    return self;\n                                var opt = optimizer(self, compressor);\n                                opt._optimized = true;\n                                if (opt === self)\n                                    return opt;\n                                return opt.transform(compressor);\n                            });\n                        }\n                        ;\n                        OPT(AST_Node, function (self, compressor) {\n                            return self;\n                        });\n                        AST_Node.DEFMETHOD('equivalent_to', function (node) {\n                            return this.print_to_string() == node.print_to_string();\n                        });\n                        function make_node(ctor, orig, props) {\n                            if (!props)\n                                props = {};\n                            if (orig) {\n                                if (!props.start)\n                                    props.start = orig.start;\n                                if (!props.end)\n                                    props.end = orig.end;\n                            }\n                            return new ctor(props);\n                        }\n                        ;\n                        function make_node_from_constant(compressor, val, orig) {\n                            if (val instanceof AST_Node)\n                                return val.transform(compressor);\n                            switch (typeof val) {\n                            case 'string':\n                                return make_node(AST_String, orig, { value: val }).optimize(compressor);\n                            case 'number':\n                                return make_node(isNaN(val) ? AST_NaN : AST_Number, orig, { value: val }).optimize(compressor);\n                            case 'boolean':\n                                return make_node(val ? AST_True : AST_False, orig).optimize(compressor);\n                            case 'undefined':\n                                return make_node(AST_Undefined, orig).optimize(compressor);\n                            default:\n                                if (val === null) {\n                                    return make_node(AST_Null, orig).optimize(compressor);\n                                }\n                                if (val instanceof RegExp) {\n                                    return make_node(AST_RegExp, orig).optimize(compressor);\n                                }\n                                throw new Error(string_template(\"Can't handle constant of type: {type}\", { type: typeof val }));\n                            }\n                        }\n                        ;\n                        function as_statement_array(thing) {\n                            if (thing === null)\n                                return [];\n                            if (thing instanceof AST_BlockStatement)\n                                return thing.body;\n                            if (thing instanceof AST_EmptyStatement)\n                                return [];\n                            if (thing instanceof AST_Statement)\n                                return [thing];\n                            throw new Error(\"Can't convert thing to statement array\");\n                        }\n                        ;\n                        function is_empty(thing) {\n                            if (thing === null)\n                                return true;\n                            if (thing instanceof AST_EmptyStatement)\n                                return true;\n                            if (thing instanceof AST_BlockStatement)\n                                return thing.body.length == 0;\n                            return false;\n                        }\n                        ;\n                        function loop_body(x) {\n                            if (x instanceof AST_Switch)\n                                return x;\n                            if (x instanceof AST_For || x instanceof AST_ForIn || x instanceof AST_DWLoop) {\n                                return x.body instanceof AST_BlockStatement ? x.body : x;\n                            }\n                            return x;\n                        }\n                        ;\n                        function tighten_body(statements, compressor) {\n                            var CHANGED;\n                            do {\n                                CHANGED = false;\n                                if (compressor.option('angular')) {\n                                    statements = process_for_angular(statements);\n                                }\n                                statements = eliminate_spurious_blocks(statements);\n                                if (compressor.option('dead_code')) {\n                                    statements = eliminate_dead_code(statements, compressor);\n                                }\n                                if (compressor.option('if_return')) {\n                                    statements = handle_if_return(statements, compressor);\n                                }\n                                if (compressor.option('sequences')) {\n                                    statements = sequencesize(statements, compressor);\n                                }\n                                if (compressor.option('join_vars')) {\n                                    statements = join_consecutive_vars(statements, compressor);\n                                }\n                            } while (CHANGED);\n                            if (compressor.option('negate_iife')) {\n                                negate_iifes(statements, compressor);\n                            }\n                            return statements;\n                            function process_for_angular(statements) {\n                                function make_injector(func, name) {\n                                    return make_node(AST_SimpleStatement, func, {\n                                        body: make_node(AST_Assign, func, {\n                                            operator: '=',\n                                            left: make_node(AST_Dot, name, {\n                                                expression: make_node(AST_SymbolRef, name, name),\n                                                property: '$inject'\n                                            }),\n                                            right: make_node(AST_Array, func, {\n                                                elements: func.argnames.map(function (sym) {\n                                                    return make_node(AST_String, sym, { value: sym.name });\n                                                })\n                                            })\n                                        })\n                                    });\n                                }\n                                return statements.reduce(function (a, stat) {\n                                    a.push(stat);\n                                    var token = stat.start;\n                                    var comments = token.comments_before;\n                                    if (comments && comments.length > 0) {\n                                        var last = comments.pop();\n                                        if (/@ngInject/.test(last.value)) {\n                                            if (stat instanceof AST_Defun) {\n                                                a.push(make_injector(stat, stat.name));\n                                            } else if (stat instanceof AST_Definitions) {\n                                                stat.definitions.forEach(function (def) {\n                                                    if (def.value && def.value instanceof AST_Lambda) {\n                                                        a.push(make_injector(def.value, def.name));\n                                                    }\n                                                });\n                                            } else {\n                                                compressor.warn('Unknown statement marked with @ngInject [{file}:{line},{col}]', token);\n                                            }\n                                        }\n                                    }\n                                    return a;\n                                }, []);\n                            }\n                            function eliminate_spurious_blocks(statements) {\n                                var seen_dirs = [];\n                                return statements.reduce(function (a, stat) {\n                                    if (stat instanceof AST_BlockStatement) {\n                                        CHANGED = true;\n                                        a.push.apply(a, eliminate_spurious_blocks(stat.body));\n                                    } else if (stat instanceof AST_EmptyStatement) {\n                                        CHANGED = true;\n                                    } else if (stat instanceof AST_Directive) {\n                                        if (seen_dirs.indexOf(stat.value) < 0) {\n                                            a.push(stat);\n                                            seen_dirs.push(stat.value);\n                                        } else {\n                                            CHANGED = true;\n                                        }\n                                    } else {\n                                        a.push(stat);\n                                    }\n                                    return a;\n                                }, []);\n                            }\n                            ;\n                            function handle_if_return(statements, compressor) {\n                                var self = compressor.self();\n                                var in_lambda = self instanceof AST_Lambda;\n                                var ret = [];\n                                loop:\n                                    for (var i = statements.length; --i >= 0;) {\n                                        var stat = statements[i];\n                                        switch (true) {\n                                        case in_lambda && stat instanceof AST_Return && !stat.value && ret.length == 0:\n                                            CHANGED = true;\n                                            continue loop;\n                                        case stat instanceof AST_If:\n                                            if (stat.body instanceof AST_Return) {\n                                                if ((in_lambda && ret.length == 0 || ret[0] instanceof AST_Return && !ret[0].value) && !stat.body.value && !stat.alternative) {\n                                                    CHANGED = true;\n                                                    var cond = make_node(AST_SimpleStatement, stat.condition, { body: stat.condition });\n                                                    ret.unshift(cond);\n                                                    continue loop;\n                                                }\n                                                if (ret[0] instanceof AST_Return && stat.body.value && ret[0].value && !stat.alternative) {\n                                                    CHANGED = true;\n                                                    stat = stat.clone();\n                                                    stat.alternative = ret[0];\n                                                    ret[0] = stat.transform(compressor);\n                                                    continue loop;\n                                                }\n                                                if ((ret.length == 0 || ret[0] instanceof AST_Return) && stat.body.value && !stat.alternative && in_lambda) {\n                                                    CHANGED = true;\n                                                    stat = stat.clone();\n                                                    stat.alternative = ret[0] || make_node(AST_Return, stat, { value: make_node(AST_Undefined, stat) });\n                                                    ret[0] = stat.transform(compressor);\n                                                    continue loop;\n                                                }\n                                                if (!stat.body.value && in_lambda) {\n                                                    CHANGED = true;\n                                                    stat = stat.clone();\n                                                    stat.condition = stat.condition.negate(compressor);\n                                                    stat.body = make_node(AST_BlockStatement, stat, { body: as_statement_array(stat.alternative).concat(ret) });\n                                                    stat.alternative = null;\n                                                    ret = [stat.transform(compressor)];\n                                                    continue loop;\n                                                }\n                                                if (ret.length == 1 && in_lambda && ret[0] instanceof AST_SimpleStatement && (!stat.alternative || stat.alternative instanceof AST_SimpleStatement)) {\n                                                    CHANGED = true;\n                                                    ret.push(make_node(AST_Return, ret[0], { value: make_node(AST_Undefined, ret[0]) }).transform(compressor));\n                                                    ret = as_statement_array(stat.alternative).concat(ret);\n                                                    ret.unshift(stat);\n                                                    continue loop;\n                                                }\n                                            }\n                                            var ab = aborts(stat.body);\n                                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;\n                                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {\n                                                if (ab.label) {\n                                                    remove(ab.label.thedef.references, ab);\n                                                }\n                                                CHANGED = true;\n                                                var body = as_statement_array(stat.body).slice(0, -1);\n                                                stat = stat.clone();\n                                                stat.condition = stat.condition.negate(compressor);\n                                                stat.body = make_node(AST_BlockStatement, stat, { body: as_statement_array(stat.alternative).concat(ret) });\n                                                stat.alternative = make_node(AST_BlockStatement, stat, { body: body });\n                                                ret = [stat.transform(compressor)];\n                                                continue loop;\n                                            }\n                                            var ab = aborts(stat.alternative);\n                                            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab.label) : null;\n                                            if (ab && (ab instanceof AST_Return && !ab.value && in_lambda || ab instanceof AST_Continue && self === loop_body(lct) || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct)) {\n                                                if (ab.label) {\n                                                    remove(ab.label.thedef.references, ab);\n                                                }\n                                                CHANGED = true;\n                                                stat = stat.clone();\n                                                stat.body = make_node(AST_BlockStatement, stat.body, { body: as_statement_array(stat.body).concat(ret) });\n                                                stat.alternative = make_node(AST_BlockStatement, stat.alternative, { body: as_statement_array(stat.alternative).slice(0, -1) });\n                                                ret = [stat.transform(compressor)];\n                                                continue loop;\n                                            }\n                                            ret.unshift(stat);\n                                            break;\n                                        default:\n                                            ret.unshift(stat);\n                                            break;\n                                        }\n                                    }\n                                return ret;\n                            }\n                            ;\n                            function eliminate_dead_code(statements, compressor) {\n                                var has_quit = false;\n                                var orig = statements.length;\n                                var self = compressor.self();\n                                statements = statements.reduce(function (a, stat) {\n                                    if (has_quit) {\n                                        extract_declarations_from_unreachable_code(compressor, stat, a);\n                                    } else {\n                                        if (stat instanceof AST_LoopControl) {\n                                            var lct = compressor.loopcontrol_target(stat.label);\n                                            if (stat instanceof AST_Break && lct instanceof AST_BlockStatement && loop_body(lct) === self || stat instanceof AST_Continue && loop_body(lct) === self) {\n                                                if (stat.label) {\n                                                    remove(stat.label.thedef.references, stat);\n                                                }\n                                            } else {\n                                                a.push(stat);\n                                            }\n                                        } else {\n                                            a.push(stat);\n                                        }\n                                        if (aborts(stat))\n                                            has_quit = true;\n                                    }\n                                    return a;\n                                }, []);\n                                CHANGED = statements.length != orig;\n                                return statements;\n                            }\n                            ;\n                            function sequencesize(statements, compressor) {\n                                if (statements.length < 2)\n                                    return statements;\n                                var seq = [], ret = [];\n                                function push_seq() {\n                                    seq = AST_Seq.from_array(seq);\n                                    if (seq)\n                                        ret.push(make_node(AST_SimpleStatement, seq, { body: seq }));\n                                    seq = [];\n                                }\n                                ;\n                                statements.forEach(function (stat) {\n                                    if (stat instanceof AST_SimpleStatement)\n                                        seq.push(stat.body);\n                                    else\n                                        push_seq(), ret.push(stat);\n                                });\n                                push_seq();\n                                ret = sequencesize_2(ret, compressor);\n                                CHANGED = ret.length != statements.length;\n                                return ret;\n                            }\n                            ;\n                            function sequencesize_2(statements, compressor) {\n                                function cons_seq(right) {\n                                    ret.pop();\n                                    var left = prev.body;\n                                    if (left instanceof AST_Seq) {\n                                        left.add(right);\n                                    } else {\n                                        left = AST_Seq.cons(left, right);\n                                    }\n                                    return left.transform(compressor);\n                                }\n                                ;\n                                var ret = [], prev = null;\n                                statements.forEach(function (stat) {\n                                    if (prev) {\n                                        if (stat instanceof AST_For) {\n                                            var opera = {};\n                                            try {\n                                                prev.body.walk(new TreeWalker(function (node) {\n                                                    if (node instanceof AST_Binary && node.operator == 'in')\n                                                        throw opera;\n                                                }));\n                                                if (stat.init && !(stat.init instanceof AST_Definitions)) {\n                                                    stat.init = cons_seq(stat.init);\n                                                } else if (!stat.init) {\n                                                    stat.init = prev.body;\n                                                    ret.pop();\n                                                }\n                                            } catch (ex) {\n                                                if (ex !== opera)\n                                                    throw ex;\n                                            }\n                                        } else if (stat instanceof AST_If) {\n                                            stat.condition = cons_seq(stat.condition);\n                                        } else if (stat instanceof AST_With) {\n                                            stat.expression = cons_seq(stat.expression);\n                                        } else if (stat instanceof AST_Exit && stat.value) {\n                                            stat.value = cons_seq(stat.value);\n                                        } else if (stat instanceof AST_Exit) {\n                                            stat.value = cons_seq(make_node(AST_Undefined, stat));\n                                        } else if (stat instanceof AST_Switch) {\n                                            stat.expression = cons_seq(stat.expression);\n                                        }\n                                    }\n                                    ret.push(stat);\n                                    prev = stat instanceof AST_SimpleStatement ? stat : null;\n                                });\n                                return ret;\n                            }\n                            ;\n                            function join_consecutive_vars(statements, compressor) {\n                                var prev = null;\n                                return statements.reduce(function (a, stat) {\n                                    if (stat instanceof AST_Definitions && prev && prev.TYPE == stat.TYPE) {\n                                        prev.definitions = prev.definitions.concat(stat.definitions);\n                                        CHANGED = true;\n                                    } else if (stat instanceof AST_For && prev instanceof AST_Definitions && (!stat.init || stat.init.TYPE == prev.TYPE)) {\n                                        CHANGED = true;\n                                        a.pop();\n                                        if (stat.init) {\n                                            stat.init.definitions = prev.definitions.concat(stat.init.definitions);\n                                        } else {\n                                            stat.init = prev;\n                                        }\n                                        a.push(stat);\n                                        prev = stat;\n                                    } else {\n                                        prev = stat;\n                                        a.push(stat);\n                                    }\n                                    return a;\n                                }, []);\n                            }\n                            ;\n                            function negate_iifes(statements, compressor) {\n                                statements.forEach(function (stat) {\n                                    if (stat instanceof AST_SimpleStatement) {\n                                        stat.body = function transform(thing) {\n                                            return thing.transform(new TreeTransformer(function (node) {\n                                                if (node instanceof AST_Call && node.expression instanceof AST_Function) {\n                                                    return make_node(AST_UnaryPrefix, node, {\n                                                        operator: '!',\n                                                        expression: node\n                                                    });\n                                                } else if (node instanceof AST_Call) {\n                                                    node.expression = transform(node.expression);\n                                                } else if (node instanceof AST_Seq) {\n                                                    node.car = transform(node.car);\n                                                } else if (node instanceof AST_Conditional) {\n                                                    var expr = transform(node.condition);\n                                                    if (expr !== node.condition) {\n                                                        node.condition = expr;\n                                                        var tmp = node.consequent;\n                                                        node.consequent = node.alternative;\n                                                        node.alternative = tmp;\n                                                    }\n                                                }\n                                                return node;\n                                            }));\n                                        }(stat.body);\n                                    }\n                                });\n                            }\n                            ;\n                        }\n                        ;\n                        function extract_declarations_from_unreachable_code(compressor, stat, target) {\n                            compressor.warn('Dropping unreachable code [{file}:{line},{col}]', stat.start);\n                            stat.walk(new TreeWalker(function (node) {\n                                if (node instanceof AST_Definitions) {\n                                    compressor.warn('Declarations in unreachable code! [{file}:{line},{col}]', node.start);\n                                    node.remove_initializers();\n                                    target.push(node);\n                                    return true;\n                                }\n                                if (node instanceof AST_Defun) {\n                                    target.push(node);\n                                    return true;\n                                }\n                                if (node instanceof AST_Scope) {\n                                    return true;\n                                }\n                            }));\n                        }\n                        ;\n                        (function (def) {\n                            var unary_bool = [\n                                '!',\n                                'delete'\n                            ];\n                            var binary_bool = [\n                                'in',\n                                'instanceof',\n                                '==',\n                                '!=',\n                                '===',\n                                '!==',\n                                '<',\n                                '<=',\n                                '>=',\n                                '>'\n                            ];\n                            def(AST_Node, function () {\n                                return false;\n                            });\n                            def(AST_UnaryPrefix, function () {\n                                return member(this.operator, unary_bool);\n                            });\n                            def(AST_Binary, function () {\n                                return member(this.operator, binary_bool) || (this.operator == '&&' || this.operator == '||') && this.left.is_boolean() && this.right.is_boolean();\n                            });\n                            def(AST_Conditional, function () {\n                                return this.consequent.is_boolean() && this.alternative.is_boolean();\n                            });\n                            def(AST_Assign, function () {\n                                return this.operator == '=' && this.right.is_boolean();\n                            });\n                            def(AST_Seq, function () {\n                                return this.cdr.is_boolean();\n                            });\n                            def(AST_True, function () {\n                                return true;\n                            });\n                            def(AST_False, function () {\n                                return true;\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('is_boolean', func);\n                        }));\n                        (function (def) {\n                            def(AST_Node, function () {\n                                return false;\n                            });\n                            def(AST_String, function () {\n                                return true;\n                            });\n                            def(AST_UnaryPrefix, function () {\n                                return this.operator == 'typeof';\n                            });\n                            def(AST_Binary, function (compressor) {\n                                return this.operator == '+' && (this.left.is_string(compressor) || this.right.is_string(compressor));\n                            });\n                            def(AST_Assign, function (compressor) {\n                                return (this.operator == '=' || this.operator == '+=') && this.right.is_string(compressor);\n                            });\n                            def(AST_Seq, function (compressor) {\n                                return this.cdr.is_string(compressor);\n                            });\n                            def(AST_Conditional, function (compressor) {\n                                return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n                            });\n                            def(AST_Call, function (compressor) {\n                                return compressor.option('unsafe') && this.expression instanceof AST_SymbolRef && this.expression.name == 'String' && this.expression.undeclared();\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('is_string', func);\n                        }));\n                        function best_of(ast1, ast2) {\n                            return ast1.print_to_string().length > ast2.print_to_string().length ? ast2 : ast1;\n                        }\n                        ;\n                        (function (def) {\n                            AST_Node.DEFMETHOD('evaluate', function (compressor) {\n                                if (!compressor.option('evaluate'))\n                                    return [this];\n                                try {\n                                    var val = this._eval(compressor);\n                                    return [\n                                        best_of(make_node_from_constant(compressor, val, this), this),\n                                        val\n                                    ];\n                                } catch (ex) {\n                                    if (ex !== def)\n                                        throw ex;\n                                    return [this];\n                                }\n                            });\n                            def(AST_Statement, function () {\n                                throw new Error(string_template('Cannot evaluate a statement [{file}:{line},{col}]', this.start));\n                            });\n                            def(AST_Function, function () {\n                                throw def;\n                            });\n                            function ev(node, compressor) {\n                                if (!compressor)\n                                    throw new Error('Compressor must be passed');\n                                return node._eval(compressor);\n                            }\n                            ;\n                            def(AST_Node, function () {\n                                throw def;\n                            });\n                            def(AST_Constant, function () {\n                                return this.getValue();\n                            });\n                            def(AST_UnaryPrefix, function (compressor) {\n                                var e = this.expression;\n                                switch (this.operator) {\n                                case '!':\n                                    return !ev(e, compressor);\n                                case 'typeof':\n                                    if (e instanceof AST_Function)\n                                        return typeof function () {\n                                        };\n                                    e = ev(e, compressor);\n                                    if (e instanceof RegExp)\n                                        throw def;\n                                    return typeof e;\n                                case 'void':\n                                    return void ev(e, compressor);\n                                case '~':\n                                    return ~ev(e, compressor);\n                                case '-':\n                                    e = ev(e, compressor);\n                                    if (e === 0)\n                                        throw def;\n                                    return -e;\n                                case '+':\n                                    return +ev(e, compressor);\n                                }\n                                throw def;\n                            });\n                            def(AST_Binary, function (c) {\n                                var left = this.left, right = this.right;\n                                switch (this.operator) {\n                                case '&&':\n                                    return ev(left, c) && ev(right, c);\n                                case '||':\n                                    return ev(left, c) || ev(right, c);\n                                case '|':\n                                    return ev(left, c) | ev(right, c);\n                                case '&':\n                                    return ev(left, c) & ev(right, c);\n                                case '^':\n                                    return ev(left, c) ^ ev(right, c);\n                                case '+':\n                                    return ev(left, c) + ev(right, c);\n                                case '*':\n                                    return ev(left, c) * ev(right, c);\n                                case '/':\n                                    return ev(left, c) / ev(right, c);\n                                case '%':\n                                    return ev(left, c) % ev(right, c);\n                                case '-':\n                                    return ev(left, c) - ev(right, c);\n                                case '<<':\n                                    return ev(left, c) << ev(right, c);\n                                case '>>':\n                                    return ev(left, c) >> ev(right, c);\n                                case '>>>':\n                                    return ev(left, c) >>> ev(right, c);\n                                case '==':\n                                    return ev(left, c) == ev(right, c);\n                                case '===':\n                                    return ev(left, c) === ev(right, c);\n                                case '!=':\n                                    return ev(left, c) != ev(right, c);\n                                case '!==':\n                                    return ev(left, c) !== ev(right, c);\n                                case '<':\n                                    return ev(left, c) < ev(right, c);\n                                case '<=':\n                                    return ev(left, c) <= ev(right, c);\n                                case '>':\n                                    return ev(left, c) > ev(right, c);\n                                case '>=':\n                                    return ev(left, c) >= ev(right, c);\n                                case 'in':\n                                    return ev(left, c) in ev(right, c);\n                                case 'instanceof':\n                                    return ev(left, c) instanceof ev(right, c);\n                                }\n                                throw def;\n                            });\n                            def(AST_Conditional, function (compressor) {\n                                return ev(this.condition, compressor) ? ev(this.consequent, compressor) : ev(this.alternative, compressor);\n                            });\n                            def(AST_SymbolRef, function (compressor) {\n                                var d = this.definition();\n                                if (d && d.constant && d.init)\n                                    return ev(d.init, compressor);\n                                throw def;\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('_eval', func);\n                        }));\n                        (function (def) {\n                            function basic_negation(exp) {\n                                return make_node(AST_UnaryPrefix, exp, {\n                                    operator: '!',\n                                    expression: exp\n                                });\n                            }\n                            ;\n                            def(AST_Node, function () {\n                                return basic_negation(this);\n                            });\n                            def(AST_Statement, function () {\n                                throw new Error('Cannot negate a statement');\n                            });\n                            def(AST_Function, function () {\n                                return basic_negation(this);\n                            });\n                            def(AST_UnaryPrefix, function () {\n                                if (this.operator == '!')\n                                    return this.expression;\n                                return basic_negation(this);\n                            });\n                            def(AST_Seq, function (compressor) {\n                                var self = this.clone();\n                                self.cdr = self.cdr.negate(compressor);\n                                return self;\n                            });\n                            def(AST_Conditional, function (compressor) {\n                                var self = this.clone();\n                                self.consequent = self.consequent.negate(compressor);\n                                self.alternative = self.alternative.negate(compressor);\n                                return best_of(basic_negation(this), self);\n                            });\n                            def(AST_Binary, function (compressor) {\n                                var self = this.clone(), op = this.operator;\n                                if (compressor.option('unsafe_comps')) {\n                                    switch (op) {\n                                    case '<=':\n                                        self.operator = '>';\n                                        return self;\n                                    case '<':\n                                        self.operator = '>=';\n                                        return self;\n                                    case '>=':\n                                        self.operator = '<';\n                                        return self;\n                                    case '>':\n                                        self.operator = '<=';\n                                        return self;\n                                    }\n                                }\n                                switch (op) {\n                                case '==':\n                                    self.operator = '!=';\n                                    return self;\n                                case '!=':\n                                    self.operator = '==';\n                                    return self;\n                                case '===':\n                                    self.operator = '!==';\n                                    return self;\n                                case '!==':\n                                    self.operator = '===';\n                                    return self;\n                                case '&&':\n                                    self.operator = '||';\n                                    self.left = self.left.negate(compressor);\n                                    self.right = self.right.negate(compressor);\n                                    return best_of(basic_negation(this), self);\n                                case '||':\n                                    self.operator = '&&';\n                                    self.left = self.left.negate(compressor);\n                                    self.right = self.right.negate(compressor);\n                                    return best_of(basic_negation(this), self);\n                                }\n                                return basic_negation(this);\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('negate', function (compressor) {\n                                return func.call(this, compressor);\n                            });\n                        }));\n                        (function (def) {\n                            def(AST_Node, function (compressor) {\n                                return true;\n                            });\n                            def(AST_EmptyStatement, function (compressor) {\n                                return false;\n                            });\n                            def(AST_Constant, function (compressor) {\n                                return false;\n                            });\n                            def(AST_This, function (compressor) {\n                                return false;\n                            });\n                            def(AST_Call, function (compressor) {\n                                var pure = compressor.option('pure_funcs');\n                                if (!pure)\n                                    return true;\n                                return pure.indexOf(this.expression.print_to_string()) < 0;\n                            });\n                            def(AST_Block, function (compressor) {\n                                for (var i = this.body.length; --i >= 0;) {\n                                    if (this.body[i].has_side_effects(compressor))\n                                        return true;\n                                }\n                                return false;\n                            });\n                            def(AST_SimpleStatement, function (compressor) {\n                                return this.body.has_side_effects(compressor);\n                            });\n                            def(AST_Defun, function (compressor) {\n                                return true;\n                            });\n                            def(AST_Function, function (compressor) {\n                                return false;\n                            });\n                            def(AST_Binary, function (compressor) {\n                                return this.left.has_side_effects(compressor) || this.right.has_side_effects(compressor);\n                            });\n                            def(AST_Assign, function (compressor) {\n                                return true;\n                            });\n                            def(AST_Conditional, function (compressor) {\n                                return this.condition.has_side_effects(compressor) || this.consequent.has_side_effects(compressor) || this.alternative.has_side_effects(compressor);\n                            });\n                            def(AST_Unary, function (compressor) {\n                                return this.operator == 'delete' || this.operator == '++' || this.operator == '--' || this.expression.has_side_effects(compressor);\n                            });\n                            def(AST_SymbolRef, function (compressor) {\n                                return false;\n                            });\n                            def(AST_Object, function (compressor) {\n                                for (var i = this.properties.length; --i >= 0;)\n                                    if (this.properties[i].has_side_effects(compressor))\n                                        return true;\n                                return false;\n                            });\n                            def(AST_ObjectProperty, function (compressor) {\n                                return this.value.has_side_effects(compressor);\n                            });\n                            def(AST_Array, function (compressor) {\n                                for (var i = this.elements.length; --i >= 0;)\n                                    if (this.elements[i].has_side_effects(compressor))\n                                        return true;\n                                return false;\n                            });\n                            def(AST_Dot, function (compressor) {\n                                if (!compressor.option('pure_getters'))\n                                    return true;\n                                return this.expression.has_side_effects(compressor);\n                            });\n                            def(AST_Sub, function (compressor) {\n                                if (!compressor.option('pure_getters'))\n                                    return true;\n                                return this.expression.has_side_effects(compressor) || this.property.has_side_effects(compressor);\n                            });\n                            def(AST_PropAccess, function (compressor) {\n                                return !compressor.option('pure_getters');\n                            });\n                            def(AST_Seq, function (compressor) {\n                                return this.car.has_side_effects(compressor) || this.cdr.has_side_effects(compressor);\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('has_side_effects', func);\n                        }));\n                        function aborts(thing) {\n                            return thing && thing.aborts();\n                        }\n                        ;\n                        (function (def) {\n                            def(AST_Statement, function () {\n                                return null;\n                            });\n                            def(AST_Jump, function () {\n                                return this;\n                            });\n                            function block_aborts() {\n                                var n = this.body.length;\n                                return n > 0 && aborts(this.body[n - 1]);\n                            }\n                            ;\n                            def(AST_BlockStatement, block_aborts);\n                            def(AST_SwitchBranch, block_aborts);\n                            def(AST_If, function () {\n                                return this.alternative && aborts(this.body) && aborts(this.alternative);\n                            });\n                        }(function (node, func) {\n                            node.DEFMETHOD('aborts', func);\n                        }));\n                        OPT(AST_Directive, function (self, compressor) {\n                            if (self.scope.has_directive(self.value) !== self.scope) {\n                                return make_node(AST_EmptyStatement, self);\n                            }\n                            return self;\n                        });\n                        OPT(AST_Debugger, function (self, compressor) {\n                            if (compressor.option('drop_debugger'))\n                                return make_node(AST_EmptyStatement, self);\n                            return self;\n                        });\n                        OPT(AST_LabeledStatement, function (self, compressor) {\n                            if (self.body instanceof AST_Break && compressor.loopcontrol_target(self.body.label) === self.body) {\n                                return make_node(AST_EmptyStatement, self);\n                            }\n                            return self.label.references.length == 0 ? self.body : self;\n                        });\n                        OPT(AST_Block, function (self, compressor) {\n                            self.body = tighten_body(self.body, compressor);\n                            return self;\n                        });\n                        OPT(AST_BlockStatement, function (self, compressor) {\n                            self.body = tighten_body(self.body, compressor);\n                            switch (self.body.length) {\n                            case 1:\n                                return self.body[0];\n                            case 0:\n                                return make_node(AST_EmptyStatement, self);\n                            }\n                            return self;\n                        });\n                        AST_Scope.DEFMETHOD('drop_unused', function (compressor) {\n                            var self = this;\n                            if (compressor.option('unused') && !(self instanceof AST_Toplevel) && !self.uses_eval) {\n                                var in_use = [];\n                                var initializations = new Dictionary();\n                                var scope = this;\n                                var tw = new TreeWalker(function (node, descend) {\n                                    if (node !== self) {\n                                        if (node instanceof AST_Defun) {\n                                            initializations.add(node.name.name, node);\n                                            return true;\n                                        }\n                                        if (node instanceof AST_Definitions && scope === self) {\n                                            node.definitions.forEach(function (def) {\n                                                if (def.value) {\n                                                    initializations.add(def.name.name, def.value);\n                                                    if (def.value.has_side_effects(compressor)) {\n                                                        def.value.walk(tw);\n                                                    }\n                                                }\n                                            });\n                                            return true;\n                                        }\n                                        if (node instanceof AST_SymbolRef) {\n                                            push_uniq(in_use, node.definition());\n                                            return true;\n                                        }\n                                        if (node instanceof AST_Scope) {\n                                            var save_scope = scope;\n                                            scope = node;\n                                            descend();\n                                            scope = save_scope;\n                                            return true;\n                                        }\n                                    }\n                                });\n                                self.walk(tw);\n                                for (var i = 0; i < in_use.length; ++i) {\n                                    in_use[i].orig.forEach(function (decl) {\n                                        var init = initializations.get(decl.name);\n                                        if (init)\n                                            init.forEach(function (init) {\n                                                var tw = new TreeWalker(function (node) {\n                                                    if (node instanceof AST_SymbolRef) {\n                                                        push_uniq(in_use, node.definition());\n                                                    }\n                                                });\n                                                init.walk(tw);\n                                            });\n                                    });\n                                }\n                                var tt = new TreeTransformer(function before(node, descend, in_list) {\n                                    if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {\n                                        if (!compressor.option('keep_fargs')) {\n                                            for (var a = node.argnames, i = a.length; --i >= 0;) {\n                                                var sym = a[i];\n                                                if (sym.unreferenced()) {\n                                                    a.pop();\n                                                    compressor.warn('Dropping unused function argument {name} [{file}:{line},{col}]', {\n                                                        name: sym.name,\n                                                        file: sym.start.file,\n                                                        line: sym.start.line,\n                                                        col: sym.start.col\n                                                    });\n                                                } else\n                                                    break;\n                                            }\n                                        }\n                                    }\n                                    if (node instanceof AST_Defun && node !== self) {\n                                        if (!member(node.name.definition(), in_use)) {\n                                            compressor.warn('Dropping unused function {name} [{file}:{line},{col}]', {\n                                                name: node.name.name,\n                                                file: node.name.start.file,\n                                                line: node.name.start.line,\n                                                col: node.name.start.col\n                                            });\n                                            return make_node(AST_EmptyStatement, node);\n                                        }\n                                        return node;\n                                    }\n                                    if (node instanceof AST_Definitions && !(tt.parent() instanceof AST_ForIn)) {\n                                        var def = node.definitions.filter(function (def) {\n                                            if (member(def.name.definition(), in_use))\n                                                return true;\n                                            var w = {\n                                                name: def.name.name,\n                                                file: def.name.start.file,\n                                                line: def.name.start.line,\n                                                col: def.name.start.col\n                                            };\n                                            if (def.value && def.value.has_side_effects(compressor)) {\n                                                def._unused_side_effects = true;\n                                                compressor.warn('Side effects in initialization of unused variable {name} [{file}:{line},{col}]', w);\n                                                return true;\n                                            }\n                                            compressor.warn('Dropping unused variable {name} [{file}:{line},{col}]', w);\n                                            return false;\n                                        });\n                                        def = mergeSort(def, function (a, b) {\n                                            if (!a.value && b.value)\n                                                return -1;\n                                            if (!b.value && a.value)\n                                                return 1;\n                                            return 0;\n                                        });\n                                        var side_effects = [];\n                                        for (var i = 0; i < def.length;) {\n                                            var x = def[i];\n                                            if (x._unused_side_effects) {\n                                                side_effects.push(x.value);\n                                                def.splice(i, 1);\n                                            } else {\n                                                if (side_effects.length > 0) {\n                                                    side_effects.push(x.value);\n                                                    x.value = AST_Seq.from_array(side_effects);\n                                                    side_effects = [];\n                                                }\n                                                ++i;\n                                            }\n                                        }\n                                        if (side_effects.length > 0) {\n                                            side_effects = make_node(AST_BlockStatement, node, { body: [make_node(AST_SimpleStatement, node, { body: AST_Seq.from_array(side_effects) })] });\n                                        } else {\n                                            side_effects = null;\n                                        }\n                                        if (def.length == 0 && !side_effects) {\n                                            return make_node(AST_EmptyStatement, node);\n                                        }\n                                        if (def.length == 0) {\n                                            return side_effects;\n                                        }\n                                        node.definitions = def;\n                                        if (side_effects) {\n                                            side_effects.body.unshift(node);\n                                            node = side_effects;\n                                        }\n                                        return node;\n                                    }\n                                    if (node instanceof AST_For) {\n                                        descend(node, this);\n                                        if (node.init instanceof AST_BlockStatement) {\n                                            var body = node.init.body.slice(0, -1);\n                                            node.init = node.init.body.slice(-1)[0].body;\n                                            body.push(node);\n                                            return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body: body });\n                                        }\n                                    }\n                                    if (node instanceof AST_Scope && node !== self)\n                                        return node;\n                                });\n                                self.transform(tt);\n                            }\n                        });\n                        AST_Scope.DEFMETHOD('hoist_declarations', function (compressor) {\n                            var hoist_funs = compressor.option('hoist_funs');\n                            var hoist_vars = compressor.option('hoist_vars');\n                            var self = this;\n                            if (hoist_funs || hoist_vars) {\n                                var dirs = [];\n                                var hoisted = [];\n                                var vars = new Dictionary(), vars_found = 0, var_decl = 0;\n                                self.walk(new TreeWalker(function (node) {\n                                    if (node instanceof AST_Scope && node !== self)\n                                        return true;\n                                    if (node instanceof AST_Var) {\n                                        ++var_decl;\n                                        return true;\n                                    }\n                                }));\n                                hoist_vars = hoist_vars && var_decl > 1;\n                                var tt = new TreeTransformer(function before(node) {\n                                    if (node !== self) {\n                                        if (node instanceof AST_Directive) {\n                                            dirs.push(node);\n                                            return make_node(AST_EmptyStatement, node);\n                                        }\n                                        if (node instanceof AST_Defun && hoist_funs) {\n                                            hoisted.push(node);\n                                            return make_node(AST_EmptyStatement, node);\n                                        }\n                                        if (node instanceof AST_Var && hoist_vars) {\n                                            node.definitions.forEach(function (def) {\n                                                vars.set(def.name.name, def);\n                                                ++vars_found;\n                                            });\n                                            var seq = node.to_assignments();\n                                            var p = tt.parent();\n                                            if (p instanceof AST_ForIn && p.init === node) {\n                                                if (seq == null)\n                                                    return node.definitions[0].name;\n                                                return seq;\n                                            }\n                                            if (p instanceof AST_For && p.init === node) {\n                                                return seq;\n                                            }\n                                            if (!seq)\n                                                return make_node(AST_EmptyStatement, node);\n                                            return make_node(AST_SimpleStatement, node, { body: seq });\n                                        }\n                                        if (node instanceof AST_Scope)\n                                            return node;\n                                    }\n                                });\n                                self = self.transform(tt);\n                                if (vars_found > 0) {\n                                    var defs = [];\n                                    vars.each(function (def, name) {\n                                        if (self instanceof AST_Lambda && find_if(function (x) {\n                                                return x.name == def.name.name;\n                                            }, self.argnames)) {\n                                            vars.del(name);\n                                        } else {\n                                            def = def.clone();\n                                            def.value = null;\n                                            defs.push(def);\n                                            vars.set(name, def);\n                                        }\n                                    });\n                                    if (defs.length > 0) {\n                                        for (var i = 0; i < self.body.length;) {\n                                            if (self.body[i] instanceof AST_SimpleStatement) {\n                                                var expr = self.body[i].body, sym, assign;\n                                                if (expr instanceof AST_Assign && expr.operator == '=' && (sym = expr.left) instanceof AST_Symbol && vars.has(sym.name)) {\n                                                    var def = vars.get(sym.name);\n                                                    if (def.value)\n                                                        break;\n                                                    def.value = expr.right;\n                                                    remove(defs, def);\n                                                    defs.push(def);\n                                                    self.body.splice(i, 1);\n                                                    continue;\n                                                }\n                                                if (expr instanceof AST_Seq && (assign = expr.car) instanceof AST_Assign && assign.operator == '=' && (sym = assign.left) instanceof AST_Symbol && vars.has(sym.name)) {\n                                                    var def = vars.get(sym.name);\n                                                    if (def.value)\n                                                        break;\n                                                    def.value = assign.right;\n                                                    remove(defs, def);\n                                                    defs.push(def);\n                                                    self.body[i].body = expr.cdr;\n                                                    continue;\n                                                }\n                                            }\n                                            if (self.body[i] instanceof AST_EmptyStatement) {\n                                                self.body.splice(i, 1);\n                                                continue;\n                                            }\n                                            if (self.body[i] instanceof AST_BlockStatement) {\n                                                var tmp = [\n                                                    i,\n                                                    1\n                                                ].concat(self.body[i].body);\n                                                self.body.splice.apply(self.body, tmp);\n                                                continue;\n                                            }\n                                            break;\n                                        }\n                                        defs = make_node(AST_Var, self, { definitions: defs });\n                                        hoisted.push(defs);\n                                    }\n                                    ;\n                                }\n                                self.body = dirs.concat(hoisted, self.body);\n                            }\n                            return self;\n                        });\n                        OPT(AST_SimpleStatement, function (self, compressor) {\n                            if (compressor.option('side_effects')) {\n                                if (!self.body.has_side_effects(compressor)) {\n                                    compressor.warn('Dropping side-effect-free statement [{file}:{line},{col}]', self.start);\n                                    return make_node(AST_EmptyStatement, self);\n                                }\n                            }\n                            return self;\n                        });\n                        OPT(AST_DWLoop, function (self, compressor) {\n                            var cond = self.condition.evaluate(compressor);\n                            self.condition = cond[0];\n                            if (!compressor.option('loops'))\n                                return self;\n                            if (cond.length > 1) {\n                                if (cond[1]) {\n                                    return make_node(AST_For, self, { body: self.body });\n                                } else if (self instanceof AST_While) {\n                                    if (compressor.option('dead_code')) {\n                                        var a = [];\n                                        extract_declarations_from_unreachable_code(compressor, self.body, a);\n                                        return make_node(AST_BlockStatement, self, { body: a });\n                                    }\n                                }\n                            }\n                            return self;\n                        });\n                        function if_break_in_loop(self, compressor) {\n                            function drop_it(rest) {\n                                rest = as_statement_array(rest);\n                                if (self.body instanceof AST_BlockStatement) {\n                                    self.body = self.body.clone();\n                                    self.body.body = rest.concat(self.body.body.slice(1));\n                                    self.body = self.body.transform(compressor);\n                                } else {\n                                    self.body = make_node(AST_BlockStatement, self.body, { body: rest }).transform(compressor);\n                                }\n                                if_break_in_loop(self, compressor);\n                            }\n                            var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;\n                            if (first instanceof AST_If) {\n                                if (first.body instanceof AST_Break && compressor.loopcontrol_target(first.body.label) === self) {\n                                    if (self.condition) {\n                                        self.condition = make_node(AST_Binary, self.condition, {\n                                            left: self.condition,\n                                            operator: '&&',\n                                            right: first.condition.negate(compressor)\n                                        });\n                                    } else {\n                                        self.condition = first.condition.negate(compressor);\n                                    }\n                                    drop_it(first.alternative);\n                                } else if (first.alternative instanceof AST_Break && compressor.loopcontrol_target(first.alternative.label) === self) {\n                                    if (self.condition) {\n                                        self.condition = make_node(AST_Binary, self.condition, {\n                                            left: self.condition,\n                                            operator: '&&',\n                                            right: first.condition\n                                        });\n                                    } else {\n                                        self.condition = first.condition;\n                                    }\n                                    drop_it(first.body);\n                                }\n                            }\n                        }\n                        ;\n                        OPT(AST_While, function (self, compressor) {\n                            if (!compressor.option('loops'))\n                                return self;\n                            self = AST_DWLoop.prototype.optimize.call(self, compressor);\n                            if (self instanceof AST_While) {\n                                if_break_in_loop(self, compressor);\n                                self = make_node(AST_For, self, self).transform(compressor);\n                            }\n                            return self;\n                        });\n                        OPT(AST_For, function (self, compressor) {\n                            var cond = self.condition;\n                            if (cond) {\n                                cond = cond.evaluate(compressor);\n                                self.condition = cond[0];\n                            }\n                            if (!compressor.option('loops'))\n                                return self;\n                            if (cond) {\n                                if (cond.length > 1 && !cond[1]) {\n                                    if (compressor.option('dead_code')) {\n                                        var a = [];\n                                        if (self.init instanceof AST_Statement) {\n                                            a.push(self.init);\n                                        } else if (self.init) {\n                                            a.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));\n                                        }\n                                        extract_declarations_from_unreachable_code(compressor, self.body, a);\n                                        return make_node(AST_BlockStatement, self, { body: a });\n                                    }\n                                }\n                            }\n                            if_break_in_loop(self, compressor);\n                            return self;\n                        });\n                        OPT(AST_If, function (self, compressor) {\n                            if (!compressor.option('conditionals'))\n                                return self;\n                            var cond = self.condition.evaluate(compressor);\n                            self.condition = cond[0];\n                            if (cond.length > 1) {\n                                if (cond[1]) {\n                                    compressor.warn('Condition always true [{file}:{line},{col}]', self.condition.start);\n                                    if (compressor.option('dead_code')) {\n                                        var a = [];\n                                        if (self.alternative) {\n                                            extract_declarations_from_unreachable_code(compressor, self.alternative, a);\n                                        }\n                                        a.push(self.body);\n                                        return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);\n                                    }\n                                } else {\n                                    compressor.warn('Condition always false [{file}:{line},{col}]', self.condition.start);\n                                    if (compressor.option('dead_code')) {\n                                        var a = [];\n                                        extract_declarations_from_unreachable_code(compressor, self.body, a);\n                                        if (self.alternative)\n                                            a.push(self.alternative);\n                                        return make_node(AST_BlockStatement, self, { body: a }).transform(compressor);\n                                    }\n                                }\n                            }\n                            if (is_empty(self.alternative))\n                                self.alternative = null;\n                            var negated = self.condition.negate(compressor);\n                            var negated_is_best = best_of(self.condition, negated) === negated;\n                            if (self.alternative && negated_is_best) {\n                                negated_is_best = false;\n                                self.condition = negated;\n                                var tmp = self.body;\n                                self.body = self.alternative || make_node(AST_EmptyStatement);\n                                self.alternative = tmp;\n                            }\n                            if (is_empty(self.body) && is_empty(self.alternative)) {\n                                return make_node(AST_SimpleStatement, self.condition, { body: self.condition }).transform(compressor);\n                            }\n                            if (self.body instanceof AST_SimpleStatement && self.alternative instanceof AST_SimpleStatement) {\n                                return make_node(AST_SimpleStatement, self, {\n                                    body: make_node(AST_Conditional, self, {\n                                        condition: self.condition,\n                                        consequent: self.body.body,\n                                        alternative: self.alternative.body\n                                    })\n                                }).transform(compressor);\n                            }\n                            if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {\n                                if (negated_is_best)\n                                    return make_node(AST_SimpleStatement, self, {\n                                        body: make_node(AST_Binary, self, {\n                                            operator: '||',\n                                            left: negated,\n                                            right: self.body.body\n                                        })\n                                    }).transform(compressor);\n                                return make_node(AST_SimpleStatement, self, {\n                                    body: make_node(AST_Binary, self, {\n                                        operator: '&&',\n                                        left: self.condition,\n                                        right: self.body.body\n                                    })\n                                }).transform(compressor);\n                            }\n                            if (self.body instanceof AST_EmptyStatement && self.alternative && self.alternative instanceof AST_SimpleStatement) {\n                                return make_node(AST_SimpleStatement, self, {\n                                    body: make_node(AST_Binary, self, {\n                                        operator: '||',\n                                        left: self.condition,\n                                        right: self.alternative.body\n                                    })\n                                }).transform(compressor);\n                            }\n                            if (self.body instanceof AST_Exit && self.alternative instanceof AST_Exit && self.body.TYPE == self.alternative.TYPE) {\n                                return make_node(self.body.CTOR, self, {\n                                    value: make_node(AST_Conditional, self, {\n                                        condition: self.condition,\n                                        consequent: self.body.value || make_node(AST_Undefined, self.body).optimize(compressor),\n                                        alternative: self.alternative.value || make_node(AST_Undefined, self.alternative).optimize(compressor)\n                                    })\n                                }).transform(compressor);\n                            }\n                            if (self.body instanceof AST_If && !self.body.alternative && !self.alternative) {\n                                self.condition = make_node(AST_Binary, self.condition, {\n                                    operator: '&&',\n                                    left: self.condition,\n                                    right: self.body.condition\n                                }).transform(compressor);\n                                self.body = self.body.body;\n                            }\n                            if (aborts(self.body)) {\n                                if (self.alternative) {\n                                    var alt = self.alternative;\n                                    self.alternative = null;\n                                    return make_node(AST_BlockStatement, self, {\n                                        body: [\n                                            self,\n                                            alt\n                                        ]\n                                    }).transform(compressor);\n                                }\n                            }\n                            if (aborts(self.alternative)) {\n                                var body = self.body;\n                                self.body = self.alternative;\n                                self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n                                self.alternative = null;\n                                return make_node(AST_BlockStatement, self, {\n                                    body: [\n                                        self,\n                                        body\n                                    ]\n                                }).transform(compressor);\n                            }\n                            return self;\n                        });\n                        OPT(AST_Switch, function (self, compressor) {\n                            if (self.body.length == 0 && compressor.option('conditionals')) {\n                                return make_node(AST_SimpleStatement, self, { body: self.expression }).transform(compressor);\n                            }\n                            for (;;) {\n                                var last_branch = self.body[self.body.length - 1];\n                                if (last_branch) {\n                                    var stat = last_branch.body[last_branch.body.length - 1];\n                                    if (stat instanceof AST_Break && loop_body(compressor.loopcontrol_target(stat.label)) === self)\n                                        last_branch.body.pop();\n                                    if (last_branch instanceof AST_Default && last_branch.body.length == 0) {\n                                        self.body.pop();\n                                        continue;\n                                    }\n                                }\n                                break;\n                            }\n                            var exp = self.expression.evaluate(compressor);\n                            out:\n                                if (exp.length == 2)\n                                    try {\n                                        self.expression = exp[0];\n                                        if (!compressor.option('dead_code'))\n                                            break out;\n                                        var value = exp[1];\n                                        var in_if = false;\n                                        var in_block = false;\n                                        var started = false;\n                                        var stopped = false;\n                                        var ruined = false;\n                                        var tt = new TreeTransformer(function (node, descend, in_list) {\n                                            if (node instanceof AST_Lambda || node instanceof AST_SimpleStatement) {\n                                                return node;\n                                            } else if (node instanceof AST_Switch && node === self) {\n                                                node = node.clone();\n                                                descend(node, this);\n                                                return ruined ? node : make_node(AST_BlockStatement, node, {\n                                                    body: node.body.reduce(function (a, branch) {\n                                                        return a.concat(branch.body);\n                                                    }, [])\n                                                }).transform(compressor);\n                                            } else if (node instanceof AST_If || node instanceof AST_Try) {\n                                                var save = in_if;\n                                                in_if = !in_block;\n                                                descend(node, this);\n                                                in_if = save;\n                                                return node;\n                                            } else if (node instanceof AST_StatementWithBody || node instanceof AST_Switch) {\n                                                var save = in_block;\n                                                in_block = true;\n                                                descend(node, this);\n                                                in_block = save;\n                                                return node;\n                                            } else if (node instanceof AST_Break && this.loopcontrol_target(node.label) === self) {\n                                                if (in_if) {\n                                                    ruined = true;\n                                                    return node;\n                                                }\n                                                if (in_block)\n                                                    return node;\n                                                stopped = true;\n                                                return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                                            } else if (node instanceof AST_SwitchBranch && this.parent() === self) {\n                                                if (stopped)\n                                                    return MAP.skip;\n                                                if (node instanceof AST_Case) {\n                                                    var exp = node.expression.evaluate(compressor);\n                                                    if (exp.length < 2) {\n                                                        throw self;\n                                                    }\n                                                    if (exp[1] === value || started) {\n                                                        started = true;\n                                                        if (aborts(node))\n                                                            stopped = true;\n                                                        descend(node, this);\n                                                        return node;\n                                                    }\n                                                    return MAP.skip;\n                                                }\n                                                descend(node, this);\n                                                return node;\n                                            }\n                                        });\n                                        tt.stack = compressor.stack.slice();\n                                        self = self.transform(tt);\n                                    } catch (ex) {\n                                        if (ex !== self)\n                                            throw ex;\n                                    }\n                            return self;\n                        });\n                        OPT(AST_Case, function (self, compressor) {\n                            self.body = tighten_body(self.body, compressor);\n                            return self;\n                        });\n                        OPT(AST_Try, function (self, compressor) {\n                            self.body = tighten_body(self.body, compressor);\n                            return self;\n                        });\n                        AST_Definitions.DEFMETHOD('remove_initializers', function () {\n                            this.definitions.forEach(function (def) {\n                                def.value = null;\n                            });\n                        });\n                        AST_Definitions.DEFMETHOD('to_assignments', function () {\n                            var assignments = this.definitions.reduce(function (a, def) {\n                                if (def.value) {\n                                    var name = make_node(AST_SymbolRef, def.name, def.name);\n                                    a.push(make_node(AST_Assign, def, {\n                                        operator: '=',\n                                        left: name,\n                                        right: def.value\n                                    }));\n                                }\n                                return a;\n                            }, []);\n                            if (assignments.length == 0)\n                                return null;\n                            return AST_Seq.from_array(assignments);\n                        });\n                        OPT(AST_Definitions, function (self, compressor) {\n                            if (self.definitions.length == 0)\n                                return make_node(AST_EmptyStatement, self);\n                            return self;\n                        });\n                        OPT(AST_Function, function (self, compressor) {\n                            self = AST_Lambda.prototype.optimize.call(self, compressor);\n                            if (compressor.option('unused')) {\n                                if (self.name && self.name.unreferenced()) {\n                                    self.name = null;\n                                }\n                            }\n                            return self;\n                        });\n                        OPT(AST_Call, function (self, compressor) {\n                            if (compressor.option('unsafe')) {\n                                var exp = self.expression;\n                                if (exp instanceof AST_SymbolRef && exp.undeclared()) {\n                                    switch (exp.name) {\n                                    case 'Array':\n                                        if (self.args.length != 1) {\n                                            return make_node(AST_Array, self, { elements: self.args }).transform(compressor);\n                                        }\n                                        break;\n                                    case 'Object':\n                                        if (self.args.length == 0) {\n                                            return make_node(AST_Object, self, { properties: [] });\n                                        }\n                                        break;\n                                    case 'String':\n                                        if (self.args.length == 0)\n                                            return make_node(AST_String, self, { value: '' });\n                                        if (self.args.length <= 1)\n                                            return make_node(AST_Binary, self, {\n                                                left: self.args[0],\n                                                operator: '+',\n                                                right: make_node(AST_String, self, { value: '' })\n                                            }).transform(compressor);\n                                        break;\n                                    case 'Number':\n                                        if (self.args.length == 0)\n                                            return make_node(AST_Number, self, { value: 0 });\n                                        if (self.args.length == 1)\n                                            return make_node(AST_UnaryPrefix, self, {\n                                                expression: self.args[0],\n                                                operator: '+'\n                                            }).transform(compressor);\n                                    case 'Boolean':\n                                        if (self.args.length == 0)\n                                            return make_node(AST_False, self);\n                                        if (self.args.length == 1)\n                                            return make_node(AST_UnaryPrefix, self, {\n                                                expression: make_node(AST_UnaryPrefix, null, {\n                                                    expression: self.args[0],\n                                                    operator: '!'\n                                                }),\n                                                operator: '!'\n                                            }).transform(compressor);\n                                        break;\n                                    case 'Function':\n                                        if (all(self.args, function (x) {\n                                                return x instanceof AST_String;\n                                            })) {\n                                            try {\n                                                var code = '(function(' + self.args.slice(0, -1).map(function (arg) {\n                                                    return arg.value;\n                                                }).join(',') + '){' + self.args[self.args.length - 1].value + '})()';\n                                                var ast = parse(code);\n                                                ast.figure_out_scope({ screw_ie8: compressor.option('screw_ie8') });\n                                                var comp = new Compressor(compressor.options);\n                                                ast = ast.transform(comp);\n                                                ast.figure_out_scope({ screw_ie8: compressor.option('screw_ie8') });\n                                                ast.mangle_names();\n                                                var fun;\n                                                try {\n                                                    ast.walk(new TreeWalker(function (node) {\n                                                        if (node instanceof AST_Lambda) {\n                                                            fun = node;\n                                                            throw ast;\n                                                        }\n                                                    }));\n                                                } catch (ex) {\n                                                    if (ex !== ast)\n                                                        throw ex;\n                                                }\n                                                ;\n                                                var args = fun.argnames.map(function (arg, i) {\n                                                    return make_node(AST_String, self.args[i], { value: arg.print_to_string() });\n                                                });\n                                                var code = OutputStream();\n                                                AST_BlockStatement.prototype._codegen.call(fun, fun, code);\n                                                code = code.toString().replace(/^\\{|\\}$/g, '');\n                                                args.push(make_node(AST_String, self.args[self.args.length - 1], { value: code }));\n                                                self.args = args;\n                                                return self;\n                                            } catch (ex) {\n                                                if (ex instanceof JS_Parse_Error) {\n                                                    compressor.warn('Error parsing code passed to new Function [{file}:{line},{col}]', self.args[self.args.length - 1].start);\n                                                    compressor.warn(ex.toString());\n                                                } else {\n                                                    console.log(ex);\n                                                    throw ex;\n                                                }\n                                            }\n                                        }\n                                        break;\n                                    }\n                                } else if (exp instanceof AST_Dot && exp.property == 'toString' && self.args.length == 0) {\n                                    return make_node(AST_Binary, self, {\n                                        left: make_node(AST_String, self, { value: '' }),\n                                        operator: '+',\n                                        right: exp.expression\n                                    }).transform(compressor);\n                                } else if (exp instanceof AST_Dot && exp.expression instanceof AST_Array && exp.property == 'join')\n                                    EXIT: {\n                                        var separator = self.args.length == 0 ? ',' : self.args[0].evaluate(compressor)[1];\n                                        if (separator == null)\n                                            break EXIT;\n                                        var elements = exp.expression.elements.reduce(function (a, el) {\n                                            el = el.evaluate(compressor);\n                                            if (a.length == 0 || el.length == 1) {\n                                                a.push(el);\n                                            } else {\n                                                var last = a[a.length - 1];\n                                                if (last.length == 2) {\n                                                    var val = '' + last[1] + separator + el[1];\n                                                    a[a.length - 1] = [\n                                                        make_node_from_constant(compressor, val, last[0]),\n                                                        val\n                                                    ];\n                                                } else {\n                                                    a.push(el);\n                                                }\n                                            }\n                                            return a;\n                                        }, []);\n                                        if (elements.length == 0)\n                                            return make_node(AST_String, self, { value: '' });\n                                        if (elements.length == 1)\n                                            return elements[0][0];\n                                        if (separator == '') {\n                                            var first;\n                                            if (elements[0][0] instanceof AST_String || elements[1][0] instanceof AST_String) {\n                                                first = elements.shift()[0];\n                                            } else {\n                                                first = make_node(AST_String, self, { value: '' });\n                                            }\n                                            return elements.reduce(function (prev, el) {\n                                                return make_node(AST_Binary, el[0], {\n                                                    operator: '+',\n                                                    left: prev,\n                                                    right: el[0]\n                                                });\n                                            }, first).transform(compressor);\n                                        }\n                                        var node = self.clone();\n                                        node.expression = node.expression.clone();\n                                        node.expression.expression = node.expression.expression.clone();\n                                        node.expression.expression.elements = elements.map(function (el) {\n                                            return el[0];\n                                        });\n                                        return best_of(self, node);\n                                    }\n                            }\n                            if (compressor.option('side_effects')) {\n                                if (self.expression instanceof AST_Function && self.args.length == 0 && !AST_Block.prototype.has_side_effects.call(self.expression, compressor)) {\n                                    return make_node(AST_Undefined, self).transform(compressor);\n                                }\n                            }\n                            if (compressor.option('drop_console')) {\n                                if (self.expression instanceof AST_PropAccess && self.expression.expression instanceof AST_SymbolRef && self.expression.expression.name == 'console' && self.expression.expression.undeclared()) {\n                                    return make_node(AST_Undefined, self).transform(compressor);\n                                }\n                            }\n                            return self.evaluate(compressor)[0];\n                        });\n                        OPT(AST_New, function (self, compressor) {\n                            if (compressor.option('unsafe')) {\n                                var exp = self.expression;\n                                if (exp instanceof AST_SymbolRef && exp.undeclared()) {\n                                    switch (exp.name) {\n                                    case 'Object':\n                                    case 'RegExp':\n                                    case 'Function':\n                                    case 'Error':\n                                    case 'Array':\n                                        return make_node(AST_Call, self, self).transform(compressor);\n                                    }\n                                }\n                            }\n                            return self;\n                        });\n                        OPT(AST_Seq, function (self, compressor) {\n                            if (!compressor.option('side_effects'))\n                                return self;\n                            if (!self.car.has_side_effects(compressor)) {\n                                var p;\n                                if (!(self.cdr instanceof AST_SymbolRef && self.cdr.name == 'eval' && self.cdr.undeclared() && (p = compressor.parent()) instanceof AST_Call && p.expression === self)) {\n                                    return self.cdr;\n                                }\n                            }\n                            if (compressor.option('cascade')) {\n                                if (self.car instanceof AST_Assign && !self.car.left.has_side_effects(compressor)) {\n                                    if (self.car.left.equivalent_to(self.cdr)) {\n                                        return self.car;\n                                    }\n                                    if (self.cdr instanceof AST_Call && self.cdr.expression.equivalent_to(self.car.left)) {\n                                        self.cdr.expression = self.car;\n                                        return self.cdr;\n                                    }\n                                }\n                                if (!self.car.has_side_effects(compressor) && !self.cdr.has_side_effects(compressor) && self.car.equivalent_to(self.cdr)) {\n                                    return self.car;\n                                }\n                            }\n                            if (self.cdr instanceof AST_UnaryPrefix && self.cdr.operator == 'void' && !self.cdr.expression.has_side_effects(compressor)) {\n                                self.cdr.operator = self.car;\n                                return self.cdr;\n                            }\n                            if (self.cdr instanceof AST_Undefined) {\n                                return make_node(AST_UnaryPrefix, self, {\n                                    operator: 'void',\n                                    expression: self.car\n                                });\n                            }\n                            return self;\n                        });\n                        AST_Unary.DEFMETHOD('lift_sequences', function (compressor) {\n                            if (compressor.option('sequences')) {\n                                if (this.expression instanceof AST_Seq) {\n                                    var seq = this.expression;\n                                    var x = seq.to_array();\n                                    this.expression = x.pop();\n                                    x.push(this);\n                                    seq = AST_Seq.from_array(x).transform(compressor);\n                                    return seq;\n                                }\n                            }\n                            return this;\n                        });\n                        OPT(AST_UnaryPostfix, function (self, compressor) {\n                            return self.lift_sequences(compressor);\n                        });\n                        OPT(AST_UnaryPrefix, function (self, compressor) {\n                            self = self.lift_sequences(compressor);\n                            var e = self.expression;\n                            if (compressor.option('booleans') && compressor.in_boolean_context()) {\n                                switch (self.operator) {\n                                case '!':\n                                    if (e instanceof AST_UnaryPrefix && e.operator == '!') {\n                                        return e.expression;\n                                    }\n                                    break;\n                                case 'typeof':\n                                    compressor.warn('Boolean expression always true [{file}:{line},{col}]', self.start);\n                                    return make_node(AST_True, self);\n                                }\n                                if (e instanceof AST_Binary && self.operator == '!') {\n                                    self = best_of(self, e.negate(compressor));\n                                }\n                            }\n                            return self.evaluate(compressor)[0];\n                        });\n                        function has_side_effects_or_prop_access(node, compressor) {\n                            var save_pure_getters = compressor.option('pure_getters');\n                            compressor.options.pure_getters = false;\n                            var ret = node.has_side_effects(compressor);\n                            compressor.options.pure_getters = save_pure_getters;\n                            return ret;\n                        }\n                        AST_Binary.DEFMETHOD('lift_sequences', function (compressor) {\n                            if (compressor.option('sequences')) {\n                                if (this.left instanceof AST_Seq) {\n                                    var seq = this.left;\n                                    var x = seq.to_array();\n                                    this.left = x.pop();\n                                    x.push(this);\n                                    seq = AST_Seq.from_array(x).transform(compressor);\n                                    return seq;\n                                }\n                                if (this.right instanceof AST_Seq && this instanceof AST_Assign && !has_side_effects_or_prop_access(this.left, compressor)) {\n                                    var seq = this.right;\n                                    var x = seq.to_array();\n                                    this.right = x.pop();\n                                    x.push(this);\n                                    seq = AST_Seq.from_array(x).transform(compressor);\n                                    return seq;\n                                }\n                            }\n                            return this;\n                        });\n                        var commutativeOperators = makePredicate('== === != !== * & | ^');\n                        OPT(AST_Binary, function (self, compressor) {\n                            var reverse = compressor.has_directive('use asm') ? noop : function (op, force) {\n                                if (force || !(self.left.has_side_effects(compressor) || self.right.has_side_effects(compressor))) {\n                                    if (op)\n                                        self.operator = op;\n                                    var tmp = self.left;\n                                    self.left = self.right;\n                                    self.right = tmp;\n                                }\n                            };\n                            if (commutativeOperators(self.operator)) {\n                                if (self.right instanceof AST_Constant && !(self.left instanceof AST_Constant)) {\n                                    if (!(self.left instanceof AST_Binary && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                                        reverse(null, true);\n                                    }\n                                }\n                                if (/^[!=]==?$/.test(self.operator)) {\n                                    if (self.left instanceof AST_SymbolRef && self.right instanceof AST_Conditional) {\n                                        if (self.right.consequent instanceof AST_SymbolRef && self.right.consequent.definition() === self.left.definition()) {\n                                            if (/^==/.test(self.operator))\n                                                return self.right.condition;\n                                            if (/^!=/.test(self.operator))\n                                                return self.right.condition.negate(compressor);\n                                        }\n                                        if (self.right.alternative instanceof AST_SymbolRef && self.right.alternative.definition() === self.left.definition()) {\n                                            if (/^==/.test(self.operator))\n                                                return self.right.condition.negate(compressor);\n                                            if (/^!=/.test(self.operator))\n                                                return self.right.condition;\n                                        }\n                                    }\n                                    if (self.right instanceof AST_SymbolRef && self.left instanceof AST_Conditional) {\n                                        if (self.left.consequent instanceof AST_SymbolRef && self.left.consequent.definition() === self.right.definition()) {\n                                            if (/^==/.test(self.operator))\n                                                return self.left.condition;\n                                            if (/^!=/.test(self.operator))\n                                                return self.left.condition.negate(compressor);\n                                        }\n                                        if (self.left.alternative instanceof AST_SymbolRef && self.left.alternative.definition() === self.right.definition()) {\n                                            if (/^==/.test(self.operator))\n                                                return self.left.condition.negate(compressor);\n                                            if (/^!=/.test(self.operator))\n                                                return self.left.condition;\n                                        }\n                                    }\n                                }\n                            }\n                            self = self.lift_sequences(compressor);\n                            if (compressor.option('comparisons'))\n                                switch (self.operator) {\n                                case '===':\n                                case '!==':\n                                    if (self.left.is_string(compressor) && self.right.is_string(compressor) || self.left.is_boolean() && self.right.is_boolean()) {\n                                        self.operator = self.operator.substr(0, 2);\n                                    }\n                                case '==':\n                                case '!=':\n                                    if (self.left instanceof AST_String && self.left.value == 'undefined' && self.right instanceof AST_UnaryPrefix && self.right.operator == 'typeof' && compressor.option('unsafe')) {\n                                        if (!(self.right.expression instanceof AST_SymbolRef) || !self.right.expression.undeclared()) {\n                                            self.right = self.right.expression;\n                                            self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                                            if (self.operator.length == 2)\n                                                self.operator += '=';\n                                        }\n                                    }\n                                    break;\n                                }\n                            if (compressor.option('booleans') && compressor.in_boolean_context())\n                                switch (self.operator) {\n                                case '&&':\n                                    var ll = self.left.evaluate(compressor);\n                                    var rr = self.right.evaluate(compressor);\n                                    if (ll.length > 1 && !ll[1] || rr.length > 1 && !rr[1]) {\n                                        compressor.warn('Boolean && always false [{file}:{line},{col}]', self.start);\n                                        return make_node(AST_False, self);\n                                    }\n                                    if (ll.length > 1 && ll[1]) {\n                                        return rr[0];\n                                    }\n                                    if (rr.length > 1 && rr[1]) {\n                                        return ll[0];\n                                    }\n                                    break;\n                                case '||':\n                                    var ll = self.left.evaluate(compressor);\n                                    var rr = self.right.evaluate(compressor);\n                                    if (ll.length > 1 && ll[1] || rr.length > 1 && rr[1]) {\n                                        compressor.warn('Boolean || always true [{file}:{line},{col}]', self.start);\n                                        return make_node(AST_True, self);\n                                    }\n                                    if (ll.length > 1 && !ll[1]) {\n                                        return rr[0];\n                                    }\n                                    if (rr.length > 1 && !rr[1]) {\n                                        return ll[0];\n                                    }\n                                    break;\n                                case '+':\n                                    var ll = self.left.evaluate(compressor);\n                                    var rr = self.right.evaluate(compressor);\n                                    if (ll.length > 1 && ll[0] instanceof AST_String && ll[1] || rr.length > 1 && rr[0] instanceof AST_String && rr[1]) {\n                                        compressor.warn('+ in boolean context always true [{file}:{line},{col}]', self.start);\n                                        return make_node(AST_True, self);\n                                    }\n                                    break;\n                                }\n                            if (compressor.option('comparisons')) {\n                                if (!(compressor.parent() instanceof AST_Binary) || compressor.parent() instanceof AST_Assign) {\n                                    var negated = make_node(AST_UnaryPrefix, self, {\n                                        operator: '!',\n                                        expression: self.negate(compressor)\n                                    });\n                                    self = best_of(self, negated);\n                                }\n                                switch (self.operator) {\n                                case '<':\n                                    reverse('>');\n                                    break;\n                                case '<=':\n                                    reverse('>=');\n                                    break;\n                                }\n                            }\n                            if (self.operator == '+' && self.right instanceof AST_String && self.right.getValue() === '' && self.left instanceof AST_Binary && self.left.operator == '+' && self.left.is_string(compressor)) {\n                                return self.left;\n                            }\n                            if (compressor.option('evaluate')) {\n                                if (self.operator == '+') {\n                                    if (self.left instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == '+' && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {\n                                        self = make_node(AST_Binary, self, {\n                                            operator: '+',\n                                            left: make_node(AST_String, null, {\n                                                value: '' + self.left.getValue() + self.right.left.getValue(),\n                                                start: self.left.start,\n                                                end: self.right.left.end\n                                            }),\n                                            right: self.right.right\n                                        });\n                                    }\n                                    if (self.right instanceof AST_Constant && self.left instanceof AST_Binary && self.left.operator == '+' && self.left.right instanceof AST_Constant && self.left.is_string(compressor)) {\n                                        self = make_node(AST_Binary, self, {\n                                            operator: '+',\n                                            left: self.left.left,\n                                            right: make_node(AST_String, null, {\n                                                value: '' + self.left.right.getValue() + self.right.getValue(),\n                                                start: self.left.right.start,\n                                                end: self.right.end\n                                            })\n                                        });\n                                    }\n                                    if (self.left instanceof AST_Binary && self.left.operator == '+' && self.left.is_string(compressor) && self.left.right instanceof AST_Constant && self.right instanceof AST_Binary && self.right.operator == '+' && self.right.left instanceof AST_Constant && self.right.is_string(compressor)) {\n                                        self = make_node(AST_Binary, self, {\n                                            operator: '+',\n                                            left: make_node(AST_Binary, self.left, {\n                                                operator: '+',\n                                                left: self.left.left,\n                                                right: make_node(AST_String, null, {\n                                                    value: '' + self.left.right.getValue() + self.right.left.getValue(),\n                                                    start: self.left.right.start,\n                                                    end: self.right.left.end\n                                                })\n                                            }),\n                                            right: self.right.right\n                                        });\n                                    }\n                                }\n                            }\n                            if (self.right instanceof AST_Binary && self.right.operator == self.operator && (self.operator == '*' || self.operator == '&&' || self.operator == '||')) {\n                                self.left = make_node(AST_Binary, self.left, {\n                                    operator: self.operator,\n                                    left: self.left,\n                                    right: self.right.left\n                                });\n                                self.right = self.right.right;\n                                return self.transform(compressor);\n                            }\n                            return self.evaluate(compressor)[0];\n                        });\n                        OPT(AST_SymbolRef, function (self, compressor) {\n                            if (self.undeclared()) {\n                                var defines = compressor.option('global_defs');\n                                if (defines && defines.hasOwnProperty(self.name)) {\n                                    return make_node_from_constant(compressor, defines[self.name], self);\n                                }\n                                switch (self.name) {\n                                case 'undefined':\n                                    return make_node(AST_Undefined, self);\n                                case 'NaN':\n                                    return make_node(AST_NaN, self);\n                                case 'Infinity':\n                                    return make_node(AST_Infinity, self);\n                                }\n                            }\n                            return self;\n                        });\n                        OPT(AST_Undefined, function (self, compressor) {\n                            if (compressor.option('unsafe')) {\n                                var scope = compressor.find_parent(AST_Scope);\n                                var undef = scope.find_variable('undefined');\n                                if (undef) {\n                                    var ref = make_node(AST_SymbolRef, self, {\n                                        name: 'undefined',\n                                        scope: scope,\n                                        thedef: undef\n                                    });\n                                    ref.reference();\n                                    return ref;\n                                }\n                            }\n                            return self;\n                        });\n                        var ASSIGN_OPS = [\n                            '+',\n                            '-',\n                            '/',\n                            '*',\n                            '%',\n                            '>>',\n                            '<<',\n                            '>>>',\n                            '|',\n                            '^',\n                            '&'\n                        ];\n                        OPT(AST_Assign, function (self, compressor) {\n                            self = self.lift_sequences(compressor);\n                            if (self.operator == '=' && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary && self.right.left instanceof AST_SymbolRef && self.right.left.name == self.left.name && member(self.right.operator, ASSIGN_OPS)) {\n                                self.operator = self.right.operator + '=';\n                                self.right = self.right.right;\n                            }\n                            return self;\n                        });\n                        OPT(AST_Conditional, function (self, compressor) {\n                            if (!compressor.option('conditionals'))\n                                return self;\n                            if (self.condition instanceof AST_Seq) {\n                                var car = self.condition.car;\n                                self.condition = self.condition.cdr;\n                                return AST_Seq.cons(car, self);\n                            }\n                            var cond = self.condition.evaluate(compressor);\n                            if (cond.length > 1) {\n                                if (cond[1]) {\n                                    compressor.warn('Condition always true [{file}:{line},{col}]', self.start);\n                                    return self.consequent;\n                                } else {\n                                    compressor.warn('Condition always false [{file}:{line},{col}]', self.start);\n                                    return self.alternative;\n                                }\n                            }\n                            var negated = cond[0].negate(compressor);\n                            if (best_of(cond[0], negated) === negated) {\n                                self = make_node(AST_Conditional, self, {\n                                    condition: negated,\n                                    consequent: self.alternative,\n                                    alternative: self.consequent\n                                });\n                            }\n                            var consequent = self.consequent;\n                            var alternative = self.alternative;\n                            if (consequent instanceof AST_Assign && alternative instanceof AST_Assign && consequent.operator == alternative.operator && consequent.left.equivalent_to(alternative.left)) {\n                                return make_node(AST_Assign, self, {\n                                    operator: consequent.operator,\n                                    left: consequent.left,\n                                    right: make_node(AST_Conditional, self, {\n                                        condition: self.condition,\n                                        consequent: consequent.right,\n                                        alternative: alternative.right\n                                    })\n                                });\n                            }\n                            if (consequent instanceof AST_Call && alternative.TYPE === consequent.TYPE && consequent.args.length == alternative.args.length && consequent.expression.equivalent_to(alternative.expression)) {\n                                if (consequent.args.length == 0) {\n                                    return make_node(AST_Seq, self, {\n                                        car: self.condition,\n                                        cdr: consequent\n                                    });\n                                }\n                                if (consequent.args.length == 1) {\n                                    consequent.args[0] = make_node(AST_Conditional, self, {\n                                        condition: self.condition,\n                                        consequent: consequent.args[0],\n                                        alternative: alternative.args[0]\n                                    });\n                                    return consequent;\n                                }\n                            }\n                            if (consequent instanceof AST_Conditional && consequent.alternative.equivalent_to(alternative)) {\n                                return make_node(AST_Conditional, self, {\n                                    condition: make_node(AST_Binary, self, {\n                                        left: self.condition,\n                                        operator: '&&',\n                                        right: consequent.condition\n                                    }),\n                                    consequent: consequent.consequent,\n                                    alternative: alternative\n                                });\n                            }\n                            return self;\n                        });\n                        OPT(AST_Boolean, function (self, compressor) {\n                            if (compressor.option('booleans')) {\n                                var p = compressor.parent();\n                                if (p instanceof AST_Binary && (p.operator == '==' || p.operator == '!=')) {\n                                    compressor.warn('Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]', {\n                                        operator: p.operator,\n                                        value: self.value,\n                                        file: p.start.file,\n                                        line: p.start.line,\n                                        col: p.start.col\n                                    });\n                                    return make_node(AST_Number, self, { value: +self.value });\n                                }\n                                return make_node(AST_UnaryPrefix, self, {\n                                    operator: '!',\n                                    expression: make_node(AST_Number, self, { value: 1 - self.value })\n                                });\n                            }\n                            return self;\n                        });\n                        OPT(AST_Sub, function (self, compressor) {\n                            var prop = self.property;\n                            if (prop instanceof AST_String && compressor.option('properties')) {\n                                prop = prop.getValue();\n                                if (RESERVED_WORDS(prop) ? compressor.option('screw_ie8') : is_identifier_string(prop)) {\n                                    return make_node(AST_Dot, self, {\n                                        expression: self.expression,\n                                        property: prop\n                                    });\n                                }\n                                var v = parseFloat(prop);\n                                if (!isNaN(v) && v.toString() == prop) {\n                                    self.property = make_node(AST_Number, self.property, { value: v });\n                                }\n                            }\n                            return self;\n                        });\n                        function literals_in_boolean_context(self, compressor) {\n                            if (compressor.option('booleans') && compressor.in_boolean_context()) {\n                                return make_node(AST_True, self);\n                            }\n                            return self;\n                        }\n                        ;\n                        OPT(AST_Array, literals_in_boolean_context);\n                        OPT(AST_Object, literals_in_boolean_context);\n                        OPT(AST_RegExp, literals_in_boolean_context);\n                    }());\n                    function SourceMap(options) {\n                        options = defaults(options, {\n                            file: null,\n                            root: null,\n                            orig: null,\n                            orig_line_diff: 0,\n                            dest_line_diff: 0\n                        });\n                        var generator = new MOZ_SourceMap.SourceMapGenerator({\n                            file: options.file,\n                            sourceRoot: options.root\n                        });\n                        var orig_map = options.orig && new MOZ_SourceMap.SourceMapConsumer(options.orig);\n                        function add(source, gen_line, gen_col, orig_line, orig_col, name) {\n                            if (orig_map) {\n                                var info = orig_map.originalPositionFor({\n                                    line: orig_line,\n                                    column: orig_col\n                                });\n                                if (info.source === null) {\n                                    return;\n                                }\n                                source = info.source;\n                                orig_line = info.line;\n                                orig_col = info.column;\n                                name = info.name;\n                            }\n                            generator.addMapping({\n                                generated: {\n                                    line: gen_line + options.dest_line_diff,\n                                    column: gen_col\n                                },\n                                original: {\n                                    line: orig_line + options.orig_line_diff,\n                                    column: orig_col\n                                },\n                                source: source,\n                                name: name\n                            });\n                        }\n                        ;\n                        return {\n                            add: add,\n                            get: function () {\n                                return generator;\n                            },\n                            toString: function () {\n                                return generator.toString();\n                            }\n                        };\n                    }\n                    ;\n                    (function () {\n                        var MOZ_TO_ME = {\n                            TryStatement: function (M) {\n                                return new AST_Try({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    body: from_moz(M.block).body,\n                                    bcatch: from_moz(M.handlers[0]),\n                                    bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n                                });\n                            },\n                            CatchClause: function (M) {\n                                return new AST_Catch({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    argname: from_moz(M.param),\n                                    body: from_moz(M.body).body\n                                });\n                            },\n                            ObjectExpression: function (M) {\n                                return new AST_Object({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    properties: M.properties.map(function (prop) {\n                                        var key = prop.key;\n                                        var name = key.type == 'Identifier' ? key.name : key.value;\n                                        var args = {\n                                            start: my_start_token(key),\n                                            end: my_end_token(prop.value),\n                                            key: name,\n                                            value: from_moz(prop.value)\n                                        };\n                                        switch (prop.kind) {\n                                        case 'init':\n                                            return new AST_ObjectKeyVal(args);\n                                        case 'set':\n                                            args.value.name = from_moz(key);\n                                            return new AST_ObjectSetter(args);\n                                        case 'get':\n                                            args.value.name = from_moz(key);\n                                            return new AST_ObjectGetter(args);\n                                        }\n                                    })\n                                });\n                            },\n                            SequenceExpression: function (M) {\n                                return AST_Seq.from_array(M.expressions.map(from_moz));\n                            },\n                            MemberExpression: function (M) {\n                                return new (M.computed ? AST_Sub : AST_Dot)({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    property: M.computed ? from_moz(M.property) : M.property.name,\n                                    expression: from_moz(M.object)\n                                });\n                            },\n                            SwitchCase: function (M) {\n                                return new (M.test ? AST_Case : AST_Default)({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    expression: from_moz(M.test),\n                                    body: M.consequent.map(from_moz)\n                                });\n                            },\n                            Literal: function (M) {\n                                var val = M.value, args = {\n                                        start: my_start_token(M),\n                                        end: my_end_token(M)\n                                    };\n                                if (val === null)\n                                    return new AST_Null(args);\n                                switch (typeof val) {\n                                case 'string':\n                                    args.value = val;\n                                    return new AST_String(args);\n                                case 'number':\n                                    args.value = val;\n                                    return new AST_Number(args);\n                                case 'boolean':\n                                    return new (val ? AST_True : AST_False)(args);\n                                default:\n                                    args.value = val;\n                                    return new AST_RegExp(args);\n                                }\n                            },\n                            UnaryExpression: From_Moz_Unary,\n                            UpdateExpression: From_Moz_Unary,\n                            Identifier: function (M) {\n                                var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n                                return new (M.name == 'this' ? AST_This : p.type == 'LabeledStatement' ? AST_Label : p.type == 'VariableDeclarator' && p.id === M ? p.kind == 'const' ? AST_SymbolConst : AST_SymbolVar : p.type == 'FunctionExpression' ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == 'FunctionDeclaration' ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == 'CatchClause' ? AST_SymbolCatch : p.type == 'BreakStatement' || p.type == 'ContinueStatement' ? AST_LabelRef : AST_SymbolRef)({\n                                    start: my_start_token(M),\n                                    end: my_end_token(M),\n                                    name: M.name\n                                });\n                            }\n                        };\n                        function From_Moz_Unary(M) {\n                            var prefix = 'prefix' in M ? M.prefix : M.type == 'UnaryExpression' ? true : false;\n                            return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n                                start: my_start_token(M),\n                                end: my_end_token(M),\n                                operator: M.operator,\n                                expression: from_moz(M.argument)\n                            });\n                        }\n                        ;\n                        var ME_TO_MOZ = {};\n                        map('Node', AST_Node);\n                        map('Program', AST_Toplevel, 'body@body');\n                        map('Function', AST_Function, 'id>name, params@argnames, body%body');\n                        map('EmptyStatement', AST_EmptyStatement);\n                        map('BlockStatement', AST_BlockStatement, 'body@body');\n                        map('ExpressionStatement', AST_SimpleStatement, 'expression>body');\n                        map('IfStatement', AST_If, 'test>condition, consequent>body, alternate>alternative');\n                        map('LabeledStatement', AST_LabeledStatement, 'label>label, body>body');\n                        map('BreakStatement', AST_Break, 'label>label');\n                        map('ContinueStatement', AST_Continue, 'label>label');\n                        map('WithStatement', AST_With, 'object>expression, body>body');\n                        map('SwitchStatement', AST_Switch, 'discriminant>expression, cases@body');\n                        map('ReturnStatement', AST_Return, 'argument>value');\n                        map('ThrowStatement', AST_Throw, 'argument>value');\n                        map('WhileStatement', AST_While, 'test>condition, body>body');\n                        map('DoWhileStatement', AST_Do, 'test>condition, body>body');\n                        map('ForStatement', AST_For, 'init>init, test>condition, update>step, body>body');\n                        map('ForInStatement', AST_ForIn, 'left>init, right>object, body>body');\n                        map('DebuggerStatement', AST_Debugger);\n                        map('FunctionDeclaration', AST_Defun, 'id>name, params@argnames, body%body');\n                        map('VariableDeclaration', AST_Var, 'declarations@definitions');\n                        map('VariableDeclarator', AST_VarDef, 'id>name, init>value');\n                        map('ThisExpression', AST_This);\n                        map('ArrayExpression', AST_Array, 'elements@elements');\n                        map('FunctionExpression', AST_Function, 'id>name, params@argnames, body%body');\n                        map('BinaryExpression', AST_Binary, 'operator=operator, left>left, right>right');\n                        map('AssignmentExpression', AST_Assign, 'operator=operator, left>left, right>right');\n                        map('LogicalExpression', AST_Binary, 'operator=operator, left>left, right>right');\n                        map('ConditionalExpression', AST_Conditional, 'test>condition, consequent>consequent, alternate>alternative');\n                        map('NewExpression', AST_New, 'callee>expression, arguments@args');\n                        map('CallExpression', AST_Call, 'callee>expression, arguments@args');\n                        function my_start_token(moznode) {\n                            return new AST_Token({\n                                file: moznode.loc && moznode.loc.source,\n                                line: moznode.loc && moznode.loc.start.line,\n                                col: moznode.loc && moznode.loc.start.column,\n                                pos: moznode.start,\n                                endpos: moznode.start\n                            });\n                        }\n                        ;\n                        function my_end_token(moznode) {\n                            return new AST_Token({\n                                file: moznode.loc && moznode.loc.source,\n                                line: moznode.loc && moznode.loc.end.line,\n                                col: moznode.loc && moznode.loc.end.column,\n                                pos: moznode.end,\n                                endpos: moznode.end\n                            });\n                        }\n                        ;\n                        function map(moztype, mytype, propmap) {\n                            var moz_to_me = 'function From_Moz_' + moztype + '(M){\\n';\n                            moz_to_me += 'return new mytype({\\n' + 'start: my_start_token(M),\\n' + 'end: my_end_token(M)';\n                            if (propmap)\n                                propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n                                    var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n                                    if (!m)\n                                        throw new Error(\"Can't understand property map: \" + prop);\n                                    var moz = 'M.' + m[1], how = m[2], my = m[3];\n                                    moz_to_me += ',\\n' + my + ': ';\n                                    if (how == '@') {\n                                        moz_to_me += moz + '.map(from_moz)';\n                                    } else if (how == '>') {\n                                        moz_to_me += 'from_moz(' + moz + ')';\n                                    } else if (how == '=') {\n                                        moz_to_me += moz;\n                                    } else if (how == '%') {\n                                        moz_to_me += 'from_moz(' + moz + ').body';\n                                    } else\n                                        throw new Error(\"Can't understand operator in propmap: \" + prop);\n                                });\n                            moz_to_me += '\\n})}';\n                            moz_to_me = new Function('mytype', 'my_start_token', 'my_end_token', 'from_moz', 'return(' + moz_to_me + ')')(mytype, my_start_token, my_end_token, from_moz);\n                            return MOZ_TO_ME[moztype] = moz_to_me;\n                        }\n                        ;\n                        var FROM_MOZ_STACK = null;\n                        function from_moz(node) {\n                            FROM_MOZ_STACK.push(node);\n                            var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n                            FROM_MOZ_STACK.pop();\n                            return ret;\n                        }\n                        ;\n                        AST_Node.from_mozilla_ast = function (node) {\n                            var save_stack = FROM_MOZ_STACK;\n                            FROM_MOZ_STACK = [];\n                            var ast = from_moz(node);\n                            FROM_MOZ_STACK = save_stack;\n                            return ast;\n                        };\n                    }());\n                    exports.sys = sys;\n                    exports.MOZ_SourceMap = MOZ_SourceMap;\n                    exports.UglifyJS = UglifyJS;\n                    exports.array_to_hash = array_to_hash;\n                    exports.slice = slice;\n                    exports.characters = characters;\n                    exports.member = member;\n                    exports.find_if = find_if;\n                    exports.repeat_string = repeat_string;\n                    exports.DefaultsError = DefaultsError;\n                    exports.defaults = defaults;\n                    exports.merge = merge;\n                    exports.noop = noop;\n                    exports.MAP = MAP;\n                    exports.push_uniq = push_uniq;\n                    exports.string_template = string_template;\n                    exports.remove = remove;\n                    exports.mergeSort = mergeSort;\n                    exports.set_difference = set_difference;\n                    exports.set_intersection = set_intersection;\n                    exports.makePredicate = makePredicate;\n                    exports.all = all;\n                    exports.Dictionary = Dictionary;\n                    exports.DEFNODE = DEFNODE;\n                    exports.AST_Token = AST_Token;\n                    exports.AST_Node = AST_Node;\n                    exports.AST_Statement = AST_Statement;\n                    exports.AST_Debugger = AST_Debugger;\n                    exports.AST_Directive = AST_Directive;\n                    exports.AST_SimpleStatement = AST_SimpleStatement;\n                    exports.walk_body = walk_body;\n                    exports.AST_Block = AST_Block;\n                    exports.AST_BlockStatement = AST_BlockStatement;\n                    exports.AST_EmptyStatement = AST_EmptyStatement;\n                    exports.AST_StatementWithBody = AST_StatementWithBody;\n                    exports.AST_LabeledStatement = AST_LabeledStatement;\n                    exports.AST_IterationStatement = AST_IterationStatement;\n                    exports.AST_DWLoop = AST_DWLoop;\n                    exports.AST_Do = AST_Do;\n                    exports.AST_While = AST_While;\n                    exports.AST_For = AST_For;\n                    exports.AST_ForIn = AST_ForIn;\n                    exports.AST_With = AST_With;\n                    exports.AST_Scope = AST_Scope;\n                    exports.AST_Toplevel = AST_Toplevel;\n                    exports.AST_Lambda = AST_Lambda;\n                    exports.AST_Accessor = AST_Accessor;\n                    exports.AST_Function = AST_Function;\n                    exports.AST_Defun = AST_Defun;\n                    exports.AST_Jump = AST_Jump;\n                    exports.AST_Exit = AST_Exit;\n                    exports.AST_Return = AST_Return;\n                    exports.AST_Throw = AST_Throw;\n                    exports.AST_LoopControl = AST_LoopControl;\n                    exports.AST_Break = AST_Break;\n                    exports.AST_Continue = AST_Continue;\n                    exports.AST_If = AST_If;\n                    exports.AST_Switch = AST_Switch;\n                    exports.AST_SwitchBranch = AST_SwitchBranch;\n                    exports.AST_Default = AST_Default;\n                    exports.AST_Case = AST_Case;\n                    exports.AST_Try = AST_Try;\n                    exports.AST_Catch = AST_Catch;\n                    exports.AST_Finally = AST_Finally;\n                    exports.AST_Definitions = AST_Definitions;\n                    exports.AST_Var = AST_Var;\n                    exports.AST_Const = AST_Const;\n                    exports.AST_VarDef = AST_VarDef;\n                    exports.AST_Call = AST_Call;\n                    exports.AST_New = AST_New;\n                    exports.AST_Seq = AST_Seq;\n                    exports.AST_PropAccess = AST_PropAccess;\n                    exports.AST_Dot = AST_Dot;\n                    exports.AST_Sub = AST_Sub;\n                    exports.AST_Unary = AST_Unary;\n                    exports.AST_UnaryPrefix = AST_UnaryPrefix;\n                    exports.AST_UnaryPostfix = AST_UnaryPostfix;\n                    exports.AST_Binary = AST_Binary;\n                    exports.AST_Conditional = AST_Conditional;\n                    exports.AST_Assign = AST_Assign;\n                    exports.AST_Array = AST_Array;\n                    exports.AST_Object = AST_Object;\n                    exports.AST_ObjectProperty = AST_ObjectProperty;\n                    exports.AST_ObjectKeyVal = AST_ObjectKeyVal;\n                    exports.AST_ObjectSetter = AST_ObjectSetter;\n                    exports.AST_ObjectGetter = AST_ObjectGetter;\n                    exports.AST_Symbol = AST_Symbol;\n                    exports.AST_SymbolAccessor = AST_SymbolAccessor;\n                    exports.AST_SymbolDeclaration = AST_SymbolDeclaration;\n                    exports.AST_SymbolVar = AST_SymbolVar;\n                    exports.AST_SymbolConst = AST_SymbolConst;\n                    exports.AST_SymbolFunarg = AST_SymbolFunarg;\n                    exports.AST_SymbolDefun = AST_SymbolDefun;\n                    exports.AST_SymbolLambda = AST_SymbolLambda;\n                    exports.AST_SymbolCatch = AST_SymbolCatch;\n                    exports.AST_Label = AST_Label;\n                    exports.AST_SymbolRef = AST_SymbolRef;\n                    exports.AST_LabelRef = AST_LabelRef;\n                    exports.AST_This = AST_This;\n                    exports.AST_Constant = AST_Constant;\n                    exports.AST_String = AST_String;\n                    exports.AST_Number = AST_Number;\n                    exports.AST_RegExp = AST_RegExp;\n                    exports.AST_Atom = AST_Atom;\n                    exports.AST_Null = AST_Null;\n                    exports.AST_NaN = AST_NaN;\n                    exports.AST_Undefined = AST_Undefined;\n                    exports.AST_Hole = AST_Hole;\n                    exports.AST_Infinity = AST_Infinity;\n                    exports.AST_Boolean = AST_Boolean;\n                    exports.AST_False = AST_False;\n                    exports.AST_True = AST_True;\n                    exports.TreeWalker = TreeWalker;\n                    exports.KEYWORDS = KEYWORDS;\n                    exports.KEYWORDS_ATOM = KEYWORDS_ATOM;\n                    exports.RESERVED_WORDS = RESERVED_WORDS;\n                    exports.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;\n                    exports.OPERATOR_CHARS = OPERATOR_CHARS;\n                    exports.RE_HEX_NUMBER = RE_HEX_NUMBER;\n                    exports.RE_OCT_NUMBER = RE_OCT_NUMBER;\n                    exports.RE_DEC_NUMBER = RE_DEC_NUMBER;\n                    exports.OPERATORS = OPERATORS;\n                    exports.WHITESPACE_CHARS = WHITESPACE_CHARS;\n                    exports.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;\n                    exports.PUNC_CHARS = PUNC_CHARS;\n                    exports.REGEXP_MODIFIERS = REGEXP_MODIFIERS;\n                    exports.UNICODE = UNICODE;\n                    exports.is_letter = is_letter;\n                    exports.is_digit = is_digit;\n                    exports.is_alphanumeric_char = is_alphanumeric_char;\n                    exports.is_unicode_combining_mark = is_unicode_combining_mark;\n                    exports.is_unicode_connector_punctuation = is_unicode_connector_punctuation;\n                    exports.is_identifier = is_identifier;\n                    exports.is_identifier_start = is_identifier_start;\n                    exports.is_identifier_char = is_identifier_char;\n                    exports.is_identifier_string = is_identifier_string;\n                    exports.parse_js_number = parse_js_number;\n                    exports.JS_Parse_Error = JS_Parse_Error;\n                    exports.js_error = js_error;\n                    exports.is_token = is_token;\n                    exports.EX_EOF = EX_EOF;\n                    exports.tokenizer = tokenizer;\n                    exports.UNARY_PREFIX = UNARY_PREFIX;\n                    exports.UNARY_POSTFIX = UNARY_POSTFIX;\n                    exports.ASSIGNMENT = ASSIGNMENT;\n                    exports.PRECEDENCE = PRECEDENCE;\n                    exports.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;\n                    exports.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\n                    exports.parse = parse;\n                    exports.TreeTransformer = TreeTransformer;\n                    exports.SymbolDef = SymbolDef;\n                    exports.base54 = base54;\n                    exports.OutputStream = OutputStream;\n                    exports.Compressor = Compressor;\n                    exports.SourceMap = SourceMap;\n                    exports.AST_Node.warn_function = function (txt) {\n                        if (typeof console != 'undefined' && typeof console.warn === 'function')\n                            console.warn(txt);\n                    };\n                    exports.minify = function (files, options) {\n                        options = UglifyJS.defaults(options, {\n                            spidermonkey: false,\n                            outSourceMap: null,\n                            sourceRoot: null,\n                            inSourceMap: null,\n                            fromString: false,\n                            warnings: false,\n                            mangle: {},\n                            output: null,\n                            compress: {}\n                        });\n                        UglifyJS.base54.reset();\n                        var toplevel = null, sourcesContent = {};\n                        if (options.spidermonkey) {\n                            toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);\n                        } else {\n                            if (typeof files == 'string')\n                                files = [files];\n                            files.forEach(function (file) {\n                                var code = options.fromString ? file : fs.readFileSync(file, 'utf8');\n                                sourcesContent[file] = code;\n                                toplevel = UglifyJS.parse(code, {\n                                    filename: options.fromString ? '?' : file,\n                                    toplevel: toplevel\n                                });\n                            });\n                        }\n                        if (options.compress) {\n                            var compress = { warnings: options.warnings };\n                            UglifyJS.merge(compress, options.compress);\n                            toplevel.figure_out_scope();\n                            var sq = UglifyJS.Compressor(compress);\n                            toplevel = toplevel.transform(sq);\n                        }\n                        if (options.mangle) {\n                            toplevel.figure_out_scope();\n                            toplevel.compute_char_frequency();\n                            toplevel.mangle_names(options.mangle);\n                        }\n                        var inMap = options.inSourceMap;\n                        var output = {};\n                        if (typeof options.inSourceMap == 'string') {\n                            inMap = fs.readFileSync(options.inSourceMap, 'utf8');\n                        }\n                        if (options.outSourceMap) {\n                            output.source_map = UglifyJS.SourceMap({\n                                file: options.outSourceMap,\n                                orig: inMap,\n                                root: options.sourceRoot\n                            });\n                            if (options.sourceMapIncludeSources) {\n                                for (var file in sourcesContent) {\n                                    if (sourcesContent.hasOwnProperty(file)) {\n                                        options.source_map.get().setSourceContent(file, sourcesContent[file]);\n                                    }\n                                }\n                            }\n                        }\n                        if (options.output) {\n                            UglifyJS.merge(output, options.output);\n                        }\n                        var stream = UglifyJS.OutputStream(output);\n                        toplevel.print(stream);\n                        return {\n                            code: stream + '',\n                            map: output.source_map + ''\n                        };\n                    };\n                    exports.describe_ast = function () {\n                        var out = UglifyJS.OutputStream({ beautify: true });\n                        function doitem(ctor) {\n                            out.print('AST_' + ctor.TYPE);\n                            var props = ctor.SELF_PROPS.filter(function (prop) {\n                                return !/^\\$/.test(prop);\n                            });\n                            if (props.length > 0) {\n                                out.space();\n                                out.with_parens(function () {\n                                    props.forEach(function (prop, i) {\n                                        if (i)\n                                            out.space();\n                                        out.print(prop);\n                                    });\n                                });\n                            }\n                            if (ctor.documentation) {\n                                out.space();\n                                out.print_string(ctor.documentation);\n                            }\n                            if (ctor.SUBCLASSES.length > 0) {\n                                out.space();\n                                out.with_block(function () {\n                                    ctor.SUBCLASSES.forEach(function (ctor, i) {\n                                        out.indent();\n                                        doitem(ctor);\n                                        out.newline();\n                                    });\n                                });\n                            }\n                        }\n                        ;\n                        doitem(UglifyJS.AST_Node);\n                        return out + '';\n                    };\n                },\n                {\n                    'source-map': 35,\n                    'util': 32\n                }\n            ],\n            46: [\n                function (_dereq_, module, exports) {\n                    var uglify = _dereq_('uglify-js');\n                    module.exports = addWith;\n                    function addWith(obj, src, exclude) {\n                        obj = obj + '';\n                        src = src + '';\n                        exclude = exclude || [];\n                        exclude = exclude.concat(detect(obj));\n                        var vars = detect(src).filter(function (v) {\n                            return exclude.indexOf(v) === -1;\n                        });\n                        if (vars.length === 0)\n                            return src;\n                        var declareLocal = '';\n                        var local = 'locals_for_with';\n                        var result = 'result_of_with';\n                        if (/^[a-zA-Z0-9$_]+$/.test(obj)) {\n                            local = obj;\n                        } else {\n                            while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {\n                                local += '_';\n                            }\n                            declareLocal = 'var ' + local + ' = (' + obj + ')';\n                        }\n                        while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {\n                            result += '_';\n                        }\n                        var inputVars = vars.map(function (v) {\n                            return JSON.stringify(v) + ' in ' + local + '?' + local + '.' + v + ':' + 'typeof ' + v + '!==\"undefined\"?' + v + ':undefined';\n                        });\n                        src = '(function (' + vars.join(', ') + ') {' + src + '}(' + inputVars.join(',') + '))';\n                        return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';';\n                    }\n                    function detect(src) {\n                        var ast = uglify.parse('(function () {' + src + '}())');\n                        ast.figure_out_scope();\n                        var globals = ast.globals.map(function (node, name) {\n                            return name;\n                        });\n                        return globals;\n                    }\n                    function unwrapReturns(src, result) {\n                        var originalSource = src;\n                        var hasReturn = false;\n                        var ast = uglify.parse(src);\n                        src = src.split('');\n                        if (ast.body.length !== 1 || ast.body[0].TYPE !== 'SimpleStatement' || ast.body[0].body.TYPE !== 'Call' || ast.body[0].body.expression.TYPE !== 'Function')\n                            throw new Error('AST does not seem to represent a self-calling function');\n                        var fn = ast.body[0].body.expression;\n                        var walker = new uglify.TreeWalker(visitor);\n                        function visitor(node, descend) {\n                            if (node !== fn && (node.TYPE === 'Defun' || node.TYPE === 'Function')) {\n                                return true;\n                            }\n                            if (node.TYPE === 'Return') {\n                                descend();\n                                hasReturn = true;\n                                replace(node, 'return {value: ' + source(node.value) + '};');\n                                return true;\n                            }\n                        }\n                        function source(node) {\n                            return src.slice(node.start.pos, node.end.endpos).join('');\n                        }\n                        function replace(node, str) {\n                            for (var i = node.start.pos; i < node.end.endpos; i++) {\n                                src[i] = '';\n                            }\n                            src[node.start.pos] = str;\n                        }\n                        ast.walk(walker);\n                        if (!hasReturn)\n                            return originalSource;\n                        else\n                            return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value';\n                    }\n                },\n                { 'uglify-js': 45 }\n            ]\n        }, {}, [5])(5);\n    });\n    function __isEmptyObject(obj) {\n        var attr;\n        for (attr in obj)\n            return !1;\n        return !0;\n    }\n    function __isValidToReturn(obj) {\n        return typeof obj != 'object' || Array.isArray(obj) || !__isEmptyObject(obj);\n    }\n    if (__isValidToReturn(module.exports))\n        return module.exports;\n    else if (__isValidToReturn(exports))\n        return exports;\n});\ndefine(\"skylark-jade/primitives/jade\", function(){});\n\ndefine('skylark-jade/jade',[\r\n\t\"skylark-langx/skylark\",\r\n\t\"./primitives/jade\"\r\n],function(skylark, _jade) {\r\n\treturn skylark.jade = {\r\n\t\tCompiler : _jade.Compiler,\r\n\t\tLexer : _jade.Lexer,\r\n\t\tParser : _jade.Parser,\r\n\t\tcompile : _jade.compile,\r\n\t\trender : render\r\n\t};\r\n});\ndefine('skylark-jade/main',[\r\n\t\"./jade\"\r\n],function(jade){\r\n\treturn jade;\r\n});\ndefine('skylark-jade', ['skylark-jade/main'], function (main) { return main; });\n\n"]}